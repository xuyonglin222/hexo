<<<<<<< HEAD
{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"6224041a5b0039720f1ad195f43105f54b82dc10","modified":1566803497000},{"_id":"source/favicon.ico","hash":"a0ee6863f92492517d169171f528b0cd4d650cc0","modified":1564451778000},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1564451893000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1564451893000},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1564451893000},{"_id":"themes/maupassant/README.md","hash":"90032cb3a46f741a3d6198de9f83ce384505519e","modified":1564451893000},{"_id":"themes/maupassant/_config.yml","hash":"0b5bf2cfe1928c2e210b1d4566bd9ae546eae749","modified":1564452690000},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1564451893000},{"_id":"source/_posts/js-Array.md","hash":"2dca078e46744e0f0a06a12202c6886a42a6410f","modified":1568687938000},{"_id":"source/_posts/js-axioshhh.md","hash":"aad3c54ca4074ed83fba258524cd2798501608f1","modified":1568687947000},{"_id":"source/_posts/js-debounce.md","hash":"14907657ed142222dfc3ff36270a91d8bb892422","modified":1568687973000},{"_id":"source/_posts/js-instanceof.md","hash":"e5b7eb8e31bf49de05fab29adf5725ea018f1fab","modified":1568688038000},{"_id":"source/_posts/js-jsMemoryManagent.md","hash":"b4236c084970a5a65f3921f338819d0256530ec1","modified":1568688047000},{"_id":"source/_posts/js-prototype.md","hash":"1207822fa57ba99fceddc8d704361b10e49afa51","modified":1568688102000},{"_id":"source/_posts/js-selfPromise.md","hash":"543ecc9cb5415a3c87307a75fb5e187e4b058fec","modified":1568688144000},{"_id":"source/_posts/js-sort.md","hash":"35312e14fdde0bb448722f2918fa53d050794ab7","modified":1568688159000},{"_id":"source/_posts/js-this.md","hash":"8fddfc2cf406ab2b232b737551ec07cd2a526f92","modified":1568688173000},{"_id":"source/_posts/js-面试.md","hash":"c429846da195fb3e314a2ac05ad00957ae4af5fc","modified":1568687930000},{"_id":"source/_posts/node-koaMiddle.md","hash":"3863c621d592c4b6df981a34cd00806c1110d25c","modified":1568688072000},{"_id":"source/_posts/react-JSX.md","hash":"ee62b60b99332200bd26cc4c31c34b55245908e0","modified":1568688064000},{"_id":"source/_posts/react-react的setState.md","hash":"decb111e95a87446e383babc9a57aec59745c92a","modified":1568688120000},{"_id":"source/_posts/rn-ReactNativeComponent.md","hash":"a1f3f4e5b77f4639b66501b5c5c8ba029c2ffaa7","modified":1568688136000},{"_id":"source/_posts/rn-choppingHand1.md","hash":"13e464d6db80af2ce4c39768c9407e9d0fabec9a","modified":1568687956000},{"_id":"source/_posts/rn-choppingHand2.md","hash":"75d1e655c0cb2976c94225e29da97c16107c0ac1","modified":1568687966000},{"_id":"source/_posts/vue-VueInAction1.md","hash":"d8a5827f28e6d8aa7783708e5b4f9c7c01bd978c","modified":1568688223000},{"_id":"source/_posts/vue-VueInAction2.md","hash":"4cf785e84449e45640981160f2d8e8f039c3fedc","modified":1568688231000},{"_id":"source/_posts/vue-lifecycle.md","hash":"362b672834dc6712fadec9cb4a7613457fc56452","modified":1568688199000},{"_id":"source/_posts/vue-template.md","hash":"05149ea43fe9ee8679adc4a3ae996a5153c17ced","modified":1568688167000},{"_id":"source/_posts/vue-v-model.md","hash":"a2337d565d4fd6bacae1399bbb1e932f968691c9","modified":1568688189000},{"_id":"source/_posts/指弹-friendships.md","hash":"c3ee0e93f315c756bc994891d4b41f983f133e07","modified":1568687980000},{"_id":"source/_posts/vue-vue的diff.md","hash":"96762dfa92864a515afd4db7dd8dfa93bbbf4d2b","modified":1568688210000},{"_id":"source/_posts/其他-封培总结.md","hash":"c351ed792a665f33af4cddb2e254420850ebdcfe","modified":1568687919000},{"_id":"source/_posts/指弹-timetravel.md","hash":"21880ec75c35fdacc2293d15daa756dbb64ac0db","modified":1568688181000},{"_id":"source/_posts/指弹-流行的云.md","hash":"1b588a865ee106e1fb290f0e0f16187dd9437f35","modified":1568687859000},{"_id":"source/_posts/杂记-MingJingNote.md","hash":"5756bdaa9053c0e14bb0a29502d61f4ade6c0482","modified":1568688085000},{"_id":"source/_posts/杂记-Ngnix.md","hash":"6b543bc3e2924e1e013bd3b2c688a5ae0a43de01","modified":1568688092000},{"_id":"source/_posts/杂记-git杂记.md","hash":"fd58613ab9440606350c6dbddab292f5c0530ac1","modified":1568687995000},{"_id":"source/_posts/浏览器-渲染.md","hash":"aac302faec61a14752717c3b4feb1d81dd9c3ac7","modified":1570119491000},{"_id":"source/_posts/网络-Quic.md","hash":"b769ce9ed5cb22e48dea3b0893c173352a72c800","modified":1568688109000},{"_id":"source/_posts/网络-http.md","hash":"09782ae3da61dbdf7a14ded42414d1dea111227e","modified":1568688028000},{"_id":"source/about/index.md","hash":"ed9ae68bb753ecf3156f41bd289941603df5db56","modified":1568688293000},{"_id":"source/youlian/index.md","hash":"77ac6ea5391630bec3edfe00ba01e319b2d54dbf","modified":1564393426000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1564451893000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1564451893000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1564451887000},{"_id":"themes/maupassant/.git/index","hash":"080531ef337a44c8d2235e8a475e36af486f3056","modified":1564451941000},{"_id":"themes/maupassant/.git/packed-refs","hash":"4abcc58543ef23fdb894778f62d5597928dbd2aa","modified":1564451893000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1564451893000},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1564451893000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1564451893000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1564451893000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1564451893000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1564451893000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1564451893000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1564451893000},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1564451893000},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1564451893000},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1564451893000},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1564451893000},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1564451893000},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1564451893000},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1564451893000},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1564451893000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1564451887000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1564451887000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1564451887000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"b23b3d4b5e55e0eb513a5178771689a46b9bde1a","modified":1564451893000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1564451887000},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"507fd8d2fde98df6216ed7c8f60ebea7cf77bfb2","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1564451893000},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1564451893000},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1564451893000},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1564451893000},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1564451893000},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1564451893000},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1564451893000},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1564451893000},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1564451893000},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1564451893000},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1564451893000},{"_id":"themes/maupassant/source/css/style.scss","hash":"fa5dfd0867f95fe1708e6fda90e41db6364c01d9","modified":1564451893000},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1564451893000},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1564451893000},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1564451893000},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1564451893000},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1564451893000},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1564451893000},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1564451893000},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1564451893000},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1564451893000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1564451893000},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1564451893000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1564451893000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1564451893000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1564451893000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1564451893000},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1564451893000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"4038440af2ee0106fac646477c3d97866ea52a2f","modified":1564451893000},{"_id":"themes/maupassant/.git/objects/pack/pack-830a89f81a3bdff38e17ab046e80fe65049cee0e.idx","hash":"4742a8f1e30a3be5d0ee33ae1d040738cd73a54c","modified":1564451893000},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1564451893000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"b23b3d4b5e55e0eb513a5178771689a46b9bde1a","modified":1564451893000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1564451893000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"b23b3d4b5e55e0eb513a5178771689a46b9bde1a","modified":1564451893000},{"_id":"themes/maupassant/.git/objects/pack/pack-830a89f81a3bdff38e17ab046e80fe65049cee0e.pack","hash":"f8229e1064e453950eb977fc70da5e2e3cf9e172","modified":1564451893000},{"_id":"public/atom.xml","hash":"85507fbc516bbea3f3cade35d5d338e7bd40a532","modified":1570119504814},{"_id":"public/youlian/index.html","hash":"aedffc0bb07c0cb20f59a35344a351878ea80350","modified":1569216668302},{"_id":"public/about/index.html","hash":"7bb4ffc5c1afac2b3bd4fd3e51839345c8cd212b","modified":1569216668302},{"_id":"public/tags/javascript/index.html","hash":"7b3e6e686e517a52b776be7a23746dd478531c8c","modified":1569216668314},{"_id":"public/tags/学习/index.html","hash":"b0b0e4a085cacd7a6d881478b297460bd1e537e6","modified":1569216668314},{"_id":"public/tags/react/index.html","hash":"b0217578cedfd8a593bfcde6dff829900aa7d178","modified":1569216668314},{"_id":"public/tags/React-Native/index.html","hash":"2c62c8ca74a8978768a95b3d79c47ad5b37b7fc3","modified":1569216668314},{"_id":"public/tags/vue/index.html","hash":"b34b7448f7794ba758abee0364c614deb3a59795","modified":1569216668314},{"_id":"public/tags/指弹/index.html","hash":"448184a94159ffb54c88cff60e80ac2497cd6191","modified":1569216668315},{"_id":"public/tags/算法/index.html","hash":"fca3cf5766913705c4e534a453047669e41231bf","modified":1569216668316},{"_id":"public/tags/koa/index.html","hash":"afabe7d1fe217f6a6392d26b08aae79cf646edfb","modified":1569216668316},{"_id":"public/categories/学习/index.html","hash":"0ac39956c228ef1ee12f3886b1e2ce37d54993c3","modified":1569216668303},{"_id":"public/categories/学习/page/2/index.html","hash":"93473baeeb8b1e00103089457e619ba1dfd1cf68","modified":1569216668303},{"_id":"public/categories/学习/page/3/index.html","hash":"008add2fdc7636f916fd25fa400c8f56056b9367","modified":1569216668304},{"_id":"public/categories/指弹/index.html","hash":"efd1fdda391369af7bbf7a5f2dda3fa6f7672411","modified":1569216668305},{"_id":"public/archives/index.html","hash":"7ae4a5c0cbd97b9768aceac3bc06a82fd5ade665","modified":1569216668305},{"_id":"public/archives/page/2/index.html","hash":"4e230368431a6930b3a1bea26f5daac7692a7170","modified":1569216668306},{"_id":"public/archives/page/4/index.html","hash":"29e9d8423866956d259aaf7b598b242fad4fd344","modified":1569216668307},{"_id":"public/archives/2018/index.html","hash":"a34696989c0d663e5b8a89aef25702a97dc8e181","modified":1569216668307},{"_id":"public/archives/2018/page/2/index.html","hash":"4c007ce1d4cee94efa25cec0c2a89e8fde3ee711","modified":1569216668308},{"_id":"public/archives/2018/page/3/index.html","hash":"2e434b7df356275f0b79425ba555d0d02c11a353","modified":1569216668308},{"_id":"public/archives/2018/01/index.html","hash":"fad1bb2a4f6c3ab8c6dd8df13c53f16664c61db1","modified":1569216668308},{"_id":"public/archives/2018/03/index.html","hash":"4dee4a3ebc18cc2368f7e8edd903f6c97133f55e","modified":1569216668308},{"_id":"public/archives/2018/04/index.html","hash":"8f8bbb99258b752dcfd0a18f6cd59aa3fe694e13","modified":1569216668308},{"_id":"public/archives/2018/05/index.html","hash":"6ece73764f6dedb63155eb318521461de8b0fea5","modified":1569216668308},{"_id":"public/archives/2018/06/index.html","hash":"b4143c25140e97a11377c8398c82aee364dc5271","modified":1569216668309},{"_id":"public/archives/2018/07/index.html","hash":"2f17f7ba3cf9b18ec66aaed0c467dbce286c1ec4","modified":1569216668309},{"_id":"public/archives/2018/08/index.html","hash":"59425b29b8917ef42e599266ad11fa11599f68e8","modified":1569216668309},{"_id":"public/archives/2018/12/index.html","hash":"a7fc6610b7e7a4a8d0bcecfc5f66b907269676aa","modified":1569216668310},{"_id":"public/archives/2019/index.html","hash":"1a30d9dbb9e5034ddbfd4ee8a671453664f71076","modified":1569216668310},{"_id":"public/archives/2019/01/index.html","hash":"edeb9d0264059a2fb8e605f1ab62a51e5e1e8eb8","modified":1569216668311},{"_id":"public/archives/2019/07/index.html","hash":"1aabb83e4f81f67e6f65c05a2a1ca4051c3e311a","modified":1569216668311},{"_id":"public/archives/2019/08/index.html","hash":"1eba9640a0603ee8c0665cd346247bcd06f8f1df","modified":1569216668312},{"_id":"public/archives/page/3/index.html","hash":"2c57f56cb36a4521c15267005a44291986751fe9","modified":1569216668306},{"_id":"public/index.html","hash":"ed3bcd420a33b23b6c57e3d8a49760afe2ea9842","modified":1569216668313},{"_id":"public/page/2/index.html","hash":"e2699393deae8e3d7da24e1b7cdbba86bffb99ea","modified":1569216668313},{"_id":"public/page/3/index.html","hash":"5b40cf31c34232b04b29c6b114c0419784db293e","modified":1569216668313},{"_id":"public/page/4/index.html","hash":"cde7d1b447ceb35a7db0ea0290d5f0691a1218a7","modified":1569216668313},{"_id":"public/tags/杂记/index.html","hash":"3dbaa44951f174f9e08da620e2b2af81f1babe7c","modified":1569216668315},{"_id":"public/2018/04/29/vue-lifecycle/index.html","hash":"4fe2a0ff12f9db46f74b2121c90aac17c2adc9b0","modified":1569216668317},{"_id":"public/2018/12/07/杂记-git杂记/index.html","hash":"591a9b7d93c51013ce0d4514ab5af85ddc13febe","modified":1569216668303},{"_id":"public/2019/09/17/浏览器-渲染/index.html","hash":"2d97cb8dc6d6f46595152344b7c7ce1555591b7c","modified":1570119504934},{"_id":"public/2018/05/23/指弹-friendships/index.html","hash":"77aa83d2dec1de2bec2d2ac0a7ea59465575fc63","modified":1569216668303},{"_id":"public/2018/05/20/指弹-流行的云/index.html","hash":"827c04888a6f2b20bbe1c582c0bf143685add650","modified":1569216668303},{"_id":"public/2018/04/29/指弹-timetravel/index.html","hash":"03aa31975c229a83bf5c6cf1d9b3def9dca90ad6","modified":1569216668303},{"_id":"public/2018/03/25/js-debounce/index.html","hash":"a950fa39da663b5693101e95a6a9ccdca04b5dab","modified":1569216668303},{"_id":"public/tags/其他/index.html","hash":"d7020065c8f4e47c9398b2f14d9a3c5a872e0023","modified":1569216668315},{"_id":"public/tags/浏览器/index.html","hash":"4376fe2b6280c857d6511219fcf0bbd6841803e5","modified":1569216668316},{"_id":"public/tags/网络/index.html","hash":"32d80a46b5467701fe000b687c785568d644b5c5","modified":1569216668316},{"_id":"public/2019/07/22/其他-封培总结/index.html","hash":"3361672090df62b2a0ae876064278dc1b9b9dce1","modified":1569216668302},{"_id":"public/2018/06/15/rn-choppingHand2/index.html","hash":"af89ff2de134fe0f8d3c7614c38b56c0b1198d5f","modified":1569216668303},{"_id":"public/archives/2019/09/index.html","hash":"037f9952aa3763e1b9e3afd83716cb9e36f839f8","modified":1569216668312},{"_id":"public/2019/07/25/杂记-MingJingNote/index.html","hash":"b2706fbc687bd7397498f5b2856ee930215ae65d","modified":1569216668316},{"_id":"public/2019/01/17/vue-vue的diff/index.html","hash":"f16ef041d4ed203a2cc828e14dd75ecc449d230a","modified":1569216668316},{"_id":"public/2019/01/04/react-react的setState/index.html","hash":"10d0445dbee2a8060d903bc7debbe26bd093542a","modified":1569216668316},{"_id":"public/2018/12/31/js-selfPromise/index.html","hash":"98c2398bfc0be089706a7f63e1c57bd092b56248","modified":1569216668316},{"_id":"public/2018/08/07/node-koaMiddle/index.html","hash":"119986d562381a62bab04dddc7c05d8c8b75aca1","modified":1569216668316},{"_id":"public/2018/07/25/js-sort/index.html","hash":"db5ca92ca35ff18ae62fec732b86e3070716df2b","modified":1569216668317},{"_id":"public/2018/07/19/杂记-Ngnix/index.html","hash":"a91a2330078978965b31ac1c1a76f9d6186c62f5","modified":1569216668317},{"_id":"public/2018/06/08/rn-choppingHand1/index.html","hash":"24a8aee3e9dec8c90ea42299ace17485154636a8","modified":1569216668317},{"_id":"public/2018/06/01/rn-ReactNativeComponent/index.html","hash":"98466526c612a1f7895d3c2e782386ef97e0f7cb","modified":1569216668317},{"_id":"public/2018/04/19/网络-http/index.html","hash":"cc72a8024a1c33ca2125375372ab75039641d313","modified":1569216668317},{"_id":"public/2018/04/18/vue-template/index.html","hash":"bfc6de391efb6cd43fd5298bb98366b055a183ae","modified":1569216668317},{"_id":"public/2018/04/10/js-axioshhh/index.html","hash":"5977e4812d3d27059143992f4383b3e1f66642ca","modified":1569216668318},{"_id":"public/2018/04/05/react-JSX/index.html","hash":"ef793443d41c9ffcabff4ec796d81ff30098e83a","modified":1569216668318},{"_id":"public/2018/04/02/js-面试/index.html","hash":"bf5b8cca20c24587d50942aef53ee556cb9b7ae1","modified":1569216668318},{"_id":"public/2018/03/10/js-jsMemoryManagent/index.html","hash":"87a7f1c228a60e95e22fbe494dad2e26bed16da8","modified":1569216668318},{"_id":"public/2018/03/07/js-this/index.html","hash":"7c43202cfebe9683606d5221a11af6b48be136b8","modified":1569216668318},{"_id":"public/2018/01/18/js-prototype/index.html","hash":"1042c2a5cb35d925555bd01ce022f4efaec10d6e","modified":1569216668318},{"_id":"public/2018/01/16/js-instanceof/index.html","hash":"c5d2c8fb0c8ada7f48e95e6a7a4a3ccd5c8e8d0f","modified":1569216668318},{"_id":"public/2018/01/13/js-Array/index.html","hash":"1a6322d90df2b902394e780211856b391e9886ac","modified":1569216668318},{"_id":"public/2018/01/12/vue-VueInAction2/index.html","hash":"cf17c1fcbe29f42954468930ee25bd9e93aa2617","modified":1569216668318},{"_id":"public/2018/01/08/vue-v-model/index.html","hash":"9564fca8320115e965cd482e5b3079584fb59c47","modified":1569216668318},{"_id":"public/2018/01/05/vue-VueInAction1/index.html","hash":"d111c783aede1833a9ff6ed8b33d1c2c3635eaa2","modified":1569216668318},{"_id":"public/2019/08/07/网络-Quic/index.html","hash":"c5af5556705ef29927b9ca052b2bebf0c3941a5c","modified":1569216668316},{"_id":"public/CNAME","hash":"6224041a5b0039720f1ad195f43105f54b82dc10","modified":1569216668329},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1569216668329},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1569216668341},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1569216668329},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1569216668329},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1569216668329},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1569216668342},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1569216668330},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1569216668330},{"_id":"public/live2d/device.min.js","hash":"ad8ffa5cc29d478f718c73eef31052dd4cdae7b6","modified":1569216668330},{"_id":"public/live2d/assets/mtn/idle_03.mtn","hash":"84684914ebf5dc5b2df160338bb97dcc0a978476","modified":1569216668330},{"_id":"public/live2d/assets/mtn/idle_02.mtn","hash":"865874c50848fbc9a55011391531e2ec171c9b91","modified":1569216668330},{"_id":"public/live2d/assets/mtn/idle_01.mtn","hash":"908abce18f6cf7fd4bc1486f048c25a517f4a34a","modified":1569216668330},{"_id":"public/live2d/assets/mtn/idle_04.mtn","hash":"78e22091792abb0600f724a5dfd60371257954e8","modified":1569216668330},{"_id":"public/live2d/assets/mtn/shake_01.mtn","hash":"dffc54733127832f8f5e91aced55a83da58fa215","modified":1569216668330},{"_id":"public/live2d/assets/mtn/shake_02.mtn","hash":"7b6c914f6c33450eda2e53d9b638fd7045c0f683","modified":1569216668330},{"_id":"public/live2d/assets/mtn/touch_02.mtn","hash":"4d1f099fbd18d15c598a644227ed5bf942a2ba71","modified":1569216668330},{"_id":"public/live2d/assets/mtn/touch_01.mtn","hash":"99270ea8fe1f8f5d88eadb94f36bd0810009d1e6","modified":1569216668330},{"_id":"public/live2d/assets/mtn/touch_04.mtn","hash":"8d2302cfdaec698e575048797ff4f30ae4d202de","modified":1569216668330},{"_id":"public/live2d/assets/mtn/touch_03.mtn","hash":"9c394975083915f0f3786caff1762381348b041e","modified":1569216668330},{"_id":"public/live2d/assets/mtn/touch_05.mtn","hash":"9610bb8a937ba9b11445a3894d8cc0733a2b67e5","modified":1569216668330},{"_id":"public/live2d/assets/mtn/touch_06.mtn","hash":"feb9237c73f2045ed1704c01b5362c9a54ee5a18","modified":1569216668331},{"_id":"public/live2d/assets/wanko.model.json","hash":"b98a8ce54fbcf1606a489f1bc5f26b1a18c82d79","modified":1569216668330},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1569216668331},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1569216668343},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1569216668331},{"_id":"public/assets/css/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1569216668331},{"_id":"public/favicon.ico","hash":"a0ee6863f92492517d169171f528b0cd4d650cc0","modified":1569216668340},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1569216668329},{"_id":"public/live2d/assets/moc/wanko.1024/texture_00.png","hash":"c405c1eeb82bcced7aa7a20f04a76168f60ad561","modified":1569216668342},{"_id":"public/live2d/assets/moc/wanko.moc","hash":"7b188cd4dcddfe5bdba8ec51a65cb1c21cd2e57a","modified":1569216668342},{"_id":"public/assets/js/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1569216668351},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1569216668350},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1569216668351},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1569216668351},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1569216668351},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1569216668351},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1569216668351},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1569216668351},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1569216668351},{"_id":"public/donate/index.html","hash":"7374db74b42ed03f138d25f10f8d47e5aab4efec","modified":1569216668351},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1569216668367},{"_id":"public/live2d/script.js","hash":"6b85d115e5785ab244c8ffa8073be3930868589a","modified":1569216668351},{"_id":"public/css/style.css","hash":"50dac51e44b24279f14cd3756bf1b388e5977f74","modified":1569216668439},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1569216668453}],"Category":[{"name":"学习","_id":"ck0n9rv7h0004kwfyiaykw1le"},{"name":"指弹","_id":"ck0n9rv8q001bkwfyfp7tkpmv"}],"Data":[],"Page":[{"title":"在下","date":"2018-01-05T15:54:06.000Z","tags":"friends","_content":"","source":"youlian/index.md","raw":"---\ntitle: 在下\ndate: 2018-01-05 23:54:06\ntags: friends\n---\n","updated":"2019-07-29T09:43:46.000Z","path":"youlian/index.html","comments":1,"layout":"page","_id":"ck0n9rv790001kwfyc0b3mavt","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"在下","date":"2018-01-05T15:54:06.000Z","tags":"About","_content":"我，徐永林，叫爸爸","source":"about/index.md","raw":"---\ntitle: 在下\ndate: 2018-01-05 23:54:06\ntags: About\n---\n我，徐永林，叫爸爸","updated":"2019-09-17T02:44:53.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck0n9rv7g0003kwfyn0tojrjh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>我，徐永林，叫爸爸</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我，徐永林，叫爸爸</p>\n"}],"Post":[{"title":"Array","date":"2018-01-13T06:30:15.000Z","_content":"\n>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。\n\n<!--more-->\n\n### Array.length\nlength是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br>\n它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：\n```bash\nvar a=[1,,3];\nconsole.log(a[0]);//1\n\nconsole.log(a[2]);//3\n\nconsole.log(a.length);//长度为3\n\n```\n如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。\n代码如下：\n```bash\nvar a=[1,2,3];\na[-1]='c';\n\nconsole.log(a.length);//3\nconsole.log(a[-1]);//c\nconsole.log(a);//[1, 2, 3, -1: \"c\"]\n\n```\n<strong>故length有时并不能体现一个数组的真实长度</strong>\n另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。\n```bash\n\nvar a1=[1,2,3];\nvar a2=a1;\na1.length=0;//清空数组，是对对象本身的操作\nconsole.log(a2) //[]\n\nvar a3=[4,5,6];\nvar a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，\na3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值\nconsole.log(a4)//[4,5,6]\n\n```\n### Array.method\n\n#### push\n该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。\n```bash\nvar a=[1,2,3];\na.push(4); //a [1,2,3,4]\n\na.push(5,6);//a [1,2,3,4,5,6]\n\nvar b= a.push(7) ;\nconsole.log(b); //b=7\n```\n\n#### pop\n与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素\n```bash\nvar a=[1,2,3];\na.pop(); //a [1,2]\n\n```\n#### shift\n该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。\n与push方法常用来解决约瑟夫环的问题。代码如下：\n```Bash\nvar a=[1,2,3,4,5,6,7,8];\nfunction circle(arr,flag){\n  var count = 0;\n  while(arr.length>1){\n      var e =arr.shift();\n    if(++count == flag){\n      count=0;\n      continue;\n    }\n    arr.push(e);\n  }\n  console.log(arr);\n}\ncircle(a,3);\n//[ 7 ]\n\n```\n#### unshift\n与shift相反的是unshift，往数组头部添加一个元素。\n\n\n#### delete\n与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。\n```bash\nvar a=[1,2,3];\ndelete a[0];\nconsole.log(a);//[2, 3]\nconsole.log(a.length); //3\n```\n#### forEach\n该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。\n<em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em>\n```bash\nvar a=[1,,3];\n\na[-1]='c';\n\na.forEach(function(item,index){\n  console.log(index,item);\n  //输出为\n  //0 1\n  //2 3\n})\n```\n#### every\n语法：array.every(function(currentValue,index,arr), thisValue)\n在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。\n换个浅显的解释：\n```bash\nvar a=[{name:'Jack',age:15},{name:'Tom',age:13}];\na.every(function(value,index){\n  此时value和index是一一对应的\n  当index==0时，value代表{name:'Jack',age:15}\n  当index==1时，value代表{name:'Tom',age:13}\n});\n\n```\n<br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。\n```bash\nfunction isEven(num){\n  return num%2===0;\n}\nvar nums = [2,4,6,8];\nvar even = nums.every(isEven);\nif(even){\n  console.log('所有元素均为偶数');\n}else{\n  ocnsole.log('并不是所有的数字皆为偶数');\n}\n```\n\n\n#### map\n该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。\n```Bash\nvar m=['a',,'c'];\nvar n=m.map(function(e){\n    return e = e+'z';\n  })\n  console.log(n);\n//[ 'az', <1 empty item>, 'cz' ]\n\n```\n<em>ps:关于数组遍历函数的比较有张图描述的特别好<em>\n​\n![](http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png)\n\n#### sort\n该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color='blue'>而是按首字符（多为数字按第一位）<font>。代码如下：\n```Bash\n//数字\nvar a=[1,3,4,7,2,5,13,30];\n\na.sort();\n\nconsole.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]\n\n```\n示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。\n\n#### reverse\n该方法会反转数组，会改变原数组，返回的是反转后的数组。\n```Bash\nvar a=[1,3,4,7,2,5,13,30];\n\nconsole.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n\nconsole.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n```\n\n#### splice\n该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br>\n参数一：截取的起始索引。<br>\n参数二：截取的长度。<br>\n参数三：删除截取后要添加进去数组的元素（可以是个数组）。\n```bash\n\nvar nums = [1,2,3,7,8,9];\nvar newElements = [4,5,6];\nnums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)\nconsole.log(nums); // 1,2,3,4,5,6,7,8,9\n```\n#### find\n该方法返回通过函数内判断的数组的第一个元素的值。\n```bash\nvar ages = [3, 10, 18, 20];\nfunction checkAdult(age) {\n    return age >= 18;\n}\nfunction myFunction() {\n    document.getElementById(\"demo\").innerHTML = ages.find(checkAdult);\n}\n```\n### 类数组\n除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy...方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br>\n类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。\n","source":"_posts/js-Array.md","raw":"---\ntitle: Array\ndate: 2018-01-13 14:30:15\ntags: javascript\ncategories: 学习\n---\n\n>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。\n\n<!--more-->\n\n### Array.length\nlength是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br>\n它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：\n```bash\nvar a=[1,,3];\nconsole.log(a[0]);//1\n\nconsole.log(a[2]);//3\n\nconsole.log(a.length);//长度为3\n\n```\n如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。\n代码如下：\n```bash\nvar a=[1,2,3];\na[-1]='c';\n\nconsole.log(a.length);//3\nconsole.log(a[-1]);//c\nconsole.log(a);//[1, 2, 3, -1: \"c\"]\n\n```\n<strong>故length有时并不能体现一个数组的真实长度</strong>\n另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。\n```bash\n\nvar a1=[1,2,3];\nvar a2=a1;\na1.length=0;//清空数组，是对对象本身的操作\nconsole.log(a2) //[]\n\nvar a3=[4,5,6];\nvar a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，\na3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值\nconsole.log(a4)//[4,5,6]\n\n```\n### Array.method\n\n#### push\n该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。\n```bash\nvar a=[1,2,3];\na.push(4); //a [1,2,3,4]\n\na.push(5,6);//a [1,2,3,4,5,6]\n\nvar b= a.push(7) ;\nconsole.log(b); //b=7\n```\n\n#### pop\n与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素\n```bash\nvar a=[1,2,3];\na.pop(); //a [1,2]\n\n```\n#### shift\n该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。\n与push方法常用来解决约瑟夫环的问题。代码如下：\n```Bash\nvar a=[1,2,3,4,5,6,7,8];\nfunction circle(arr,flag){\n  var count = 0;\n  while(arr.length>1){\n      var e =arr.shift();\n    if(++count == flag){\n      count=0;\n      continue;\n    }\n    arr.push(e);\n  }\n  console.log(arr);\n}\ncircle(a,3);\n//[ 7 ]\n\n```\n#### unshift\n与shift相反的是unshift，往数组头部添加一个元素。\n\n\n#### delete\n与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。\n```bash\nvar a=[1,2,3];\ndelete a[0];\nconsole.log(a);//[2, 3]\nconsole.log(a.length); //3\n```\n#### forEach\n该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。\n<em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em>\n```bash\nvar a=[1,,3];\n\na[-1]='c';\n\na.forEach(function(item,index){\n  console.log(index,item);\n  //输出为\n  //0 1\n  //2 3\n})\n```\n#### every\n语法：array.every(function(currentValue,index,arr), thisValue)\n在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。\n换个浅显的解释：\n```bash\nvar a=[{name:'Jack',age:15},{name:'Tom',age:13}];\na.every(function(value,index){\n  此时value和index是一一对应的\n  当index==0时，value代表{name:'Jack',age:15}\n  当index==1时，value代表{name:'Tom',age:13}\n});\n\n```\n<br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。\n```bash\nfunction isEven(num){\n  return num%2===0;\n}\nvar nums = [2,4,6,8];\nvar even = nums.every(isEven);\nif(even){\n  console.log('所有元素均为偶数');\n}else{\n  ocnsole.log('并不是所有的数字皆为偶数');\n}\n```\n\n\n#### map\n该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。\n```Bash\nvar m=['a',,'c'];\nvar n=m.map(function(e){\n    return e = e+'z';\n  })\n  console.log(n);\n//[ 'az', <1 empty item>, 'cz' ]\n\n```\n<em>ps:关于数组遍历函数的比较有张图描述的特别好<em>\n​\n![](http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png)\n\n#### sort\n该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color='blue'>而是按首字符（多为数字按第一位）<font>。代码如下：\n```Bash\n//数字\nvar a=[1,3,4,7,2,5,13,30];\n\na.sort();\n\nconsole.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]\n\n```\n示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。\n\n#### reverse\n该方法会反转数组，会改变原数组，返回的是反转后的数组。\n```Bash\nvar a=[1,3,4,7,2,5,13,30];\n\nconsole.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n\nconsole.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n```\n\n#### splice\n该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br>\n参数一：截取的起始索引。<br>\n参数二：截取的长度。<br>\n参数三：删除截取后要添加进去数组的元素（可以是个数组）。\n```bash\n\nvar nums = [1,2,3,7,8,9];\nvar newElements = [4,5,6];\nnums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)\nconsole.log(nums); // 1,2,3,4,5,6,7,8,9\n```\n#### find\n该方法返回通过函数内判断的数组的第一个元素的值。\n```bash\nvar ages = [3, 10, 18, 20];\nfunction checkAdult(age) {\n    return age >= 18;\n}\nfunction myFunction() {\n    document.getElementById(\"demo\").innerHTML = ages.find(checkAdult);\n}\n```\n### 类数组\n除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy...方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br>\n类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。\n","slug":"js-Array","published":1,"updated":"2019-09-17T02:38:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv730000kwfyydbgd6ht","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Array-length\"><a href=\"#Array-length\" class=\"headerlink\" title=\"Array.length\"></a>Array.length</h3><p>length是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br><br>它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\">console.log(a[0]);//1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a[2]);//3</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//长度为3</span><br></pre></td></tr></table></figure></p>\n<p>如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。<br>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//3</span><br><span class=\"line\">console.log(a[-1]);//c</span><br><span class=\"line\">console.log(a);//[1, 2, 3, -1: <span class=\"string\">\"c\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p><strong>故length有时并不能体现一个数组的真实长度</strong><br>另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var a1=[1,2,3];</span><br><span class=\"line\">var a2=a1;</span><br><span class=\"line\">a1.length=0;//清空数组，是对对象本身的操作</span><br><span class=\"line\">console.log(a2) //[]</span><br><span class=\"line\"></span><br><span class=\"line\">var a3=[4,5,6];</span><br><span class=\"line\">var a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，</span><br><span class=\"line\">a3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值</span><br><span class=\"line\">console.log(a4)//[4,5,6]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-method\"><a href=\"#Array-method\" class=\"headerlink\" title=\"Array.method\"></a>Array.method</h3><h4 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h4><p>该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.push(4); //a [1,2,3,4]</span><br><span class=\"line\"></span><br><span class=\"line\">a.push(5,6);//a [1,2,3,4,5,6]</span><br><span class=\"line\"></span><br><span class=\"line\">var b= a.push(7) ;</span><br><span class=\"line\">console.log(b); //b=7</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h4><p>与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.pop(); //a [1,2]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h4><p>该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。<br>与push方法常用来解决约瑟夫环的问题。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3,4,5,6,7,8];</span><br><span class=\"line\"><span class=\"keyword\">function</span> circle(arr,flag)&#123;</span><br><span class=\"line\">  var count = 0;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.length&gt;1)&#123;</span><br><span class=\"line\">      var e =arr.shift();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(++count == flag)&#123;</span><br><span class=\"line\">      count=0;</span><br><span class=\"line\">      <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr.push(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">circle(a,3);</span><br><span class=\"line\">//[ 7 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h4><p>与shift相反的是unshift，往数组头部添加一个元素。</p>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h4><p>与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">delete a[0];</span><br><span class=\"line\">console.log(a);//[2, 3]</span><br><span class=\"line\">console.log(a.length); //3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h4><p>该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。<br><em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\"></span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a.forEach(<span class=\"keyword\">function</span>(item,index)&#123;</span><br><span class=\"line\">  console.log(index,item);</span><br><span class=\"line\">  //输出为</span><br><span class=\"line\">  //0 1</span><br><span class=\"line\">  //2 3</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h4><p>语法：array.every(function(currentValue,index,arr), thisValue)<br>在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。<br>换个浅显的解释：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;,&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;];</span><br><span class=\"line\">a.every(<span class=\"keyword\">function</span>(value,index)&#123;</span><br><span class=\"line\">  此时value和index是一一对应的</span><br><span class=\"line\">  当index==0时，value代表&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;</span><br><span class=\"line\">  当index==1时，value代表&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> isEven(num)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> num%2===0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var nums = [2,4,6,8];</span><br><span class=\"line\">var even = nums.every(isEven);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(even)&#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">'所有元素均为偶数'</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  ocnsole.log(<span class=\"string\">'并不是所有的数字皆为偶数'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var m=[<span class=\"string\">'a'</span>,,<span class=\"string\">'c'</span>];</span><br><span class=\"line\">var n=m.map(<span class=\"keyword\">function</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> e = e+<span class=\"string\">'z'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  console.log(n);</span><br><span class=\"line\">//[ <span class=\"string\">'az'</span>, &lt;1 empty item&gt;, <span class=\"string\">'cz'</span> ]</span><br></pre></td></tr></table></figure></p>\n<p><em>ps:关于数组遍历函数的比较有张图描述的特别好<em><br>​<br><img src=\"http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png\" alt></em></em></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color=\"blue\">而是按首字符（多为数字按第一位）<font>。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数字</span><br><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">a.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]</span><br></pre></td></tr></table></figure></font></font></p>\n<p>示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>该方法会反转数组，会改变原数组，返回的是反转后的数组。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p>该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br><br>参数一：截取的起始索引。<br><br>参数二：截取的长度。<br><br>参数三：删除截取后要添加进去数组的元素（可以是个数组）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var nums = [1,2,3,7,8,9];</span><br><span class=\"line\">var newElements = [4,5,6];</span><br><span class=\"line\">nums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)</span><br><span class=\"line\">console.log(nums); // 1,2,3,4,5,6,7,8,9</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h4><p>该方法返回通过函数内判断的数组的第一个元素的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ages = [3, 10, 18, 20];</span><br><span class=\"line\"><span class=\"keyword\">function</span> checkAdult(age) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> age &gt;= 18;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">myFunction</span></span>() &#123;</span><br><span class=\"line\">    document.getElementById(<span class=\"string\">\"demo\"</span>).innerHTML = ages.find(checkAdult);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><p>除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy…方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br><br>类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。</p>\n</blockquote>","more":"<h3 id=\"Array-length\"><a href=\"#Array-length\" class=\"headerlink\" title=\"Array.length\"></a>Array.length</h3><p>length是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br><br>它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\">console.log(a[0]);//1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a[2]);//3</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//长度为3</span><br></pre></td></tr></table></figure></p>\n<p>如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。<br>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//3</span><br><span class=\"line\">console.log(a[-1]);//c</span><br><span class=\"line\">console.log(a);//[1, 2, 3, -1: <span class=\"string\">\"c\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p><strong>故length有时并不能体现一个数组的真实长度</strong><br>另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var a1=[1,2,3];</span><br><span class=\"line\">var a2=a1;</span><br><span class=\"line\">a1.length=0;//清空数组，是对对象本身的操作</span><br><span class=\"line\">console.log(a2) //[]</span><br><span class=\"line\"></span><br><span class=\"line\">var a3=[4,5,6];</span><br><span class=\"line\">var a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，</span><br><span class=\"line\">a3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值</span><br><span class=\"line\">console.log(a4)//[4,5,6]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-method\"><a href=\"#Array-method\" class=\"headerlink\" title=\"Array.method\"></a>Array.method</h3><h4 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h4><p>该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.push(4); //a [1,2,3,4]</span><br><span class=\"line\"></span><br><span class=\"line\">a.push(5,6);//a [1,2,3,4,5,6]</span><br><span class=\"line\"></span><br><span class=\"line\">var b= a.push(7) ;</span><br><span class=\"line\">console.log(b); //b=7</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h4><p>与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.pop(); //a [1,2]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h4><p>该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。<br>与push方法常用来解决约瑟夫环的问题。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3,4,5,6,7,8];</span><br><span class=\"line\"><span class=\"keyword\">function</span> circle(arr,flag)&#123;</span><br><span class=\"line\">  var count = 0;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.length&gt;1)&#123;</span><br><span class=\"line\">      var e =arr.shift();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(++count == flag)&#123;</span><br><span class=\"line\">      count=0;</span><br><span class=\"line\">      <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr.push(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">circle(a,3);</span><br><span class=\"line\">//[ 7 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h4><p>与shift相反的是unshift，往数组头部添加一个元素。</p>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h4><p>与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">delete a[0];</span><br><span class=\"line\">console.log(a);//[2, 3]</span><br><span class=\"line\">console.log(a.length); //3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h4><p>该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。<br><em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\"></span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a.forEach(<span class=\"keyword\">function</span>(item,index)&#123;</span><br><span class=\"line\">  console.log(index,item);</span><br><span class=\"line\">  //输出为</span><br><span class=\"line\">  //0 1</span><br><span class=\"line\">  //2 3</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h4><p>语法：array.every(function(currentValue,index,arr), thisValue)<br>在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。<br>换个浅显的解释：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;,&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;];</span><br><span class=\"line\">a.every(<span class=\"keyword\">function</span>(value,index)&#123;</span><br><span class=\"line\">  此时value和index是一一对应的</span><br><span class=\"line\">  当index==0时，value代表&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;</span><br><span class=\"line\">  当index==1时，value代表&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> isEven(num)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> num%2===0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var nums = [2,4,6,8];</span><br><span class=\"line\">var even = nums.every(isEven);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(even)&#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">'所有元素均为偶数'</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  ocnsole.log(<span class=\"string\">'并不是所有的数字皆为偶数'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var m=[<span class=\"string\">'a'</span>,,<span class=\"string\">'c'</span>];</span><br><span class=\"line\">var n=m.map(<span class=\"keyword\">function</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> e = e+<span class=\"string\">'z'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  console.log(n);</span><br><span class=\"line\">//[ <span class=\"string\">'az'</span>, &lt;1 empty item&gt;, <span class=\"string\">'cz'</span> ]</span><br></pre></td></tr></table></figure></p>\n<p><em>ps:关于数组遍历函数的比较有张图描述的特别好<em><br>​<br><img src=\"http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png\" alt></em></em></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color=\"blue\">而是按首字符（多为数字按第一位）<font>。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数字</span><br><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">a.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]</span><br></pre></td></tr></table></figure></font></font></p>\n<p>示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>该方法会反转数组，会改变原数组，返回的是反转后的数组。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p>该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br><br>参数一：截取的起始索引。<br><br>参数二：截取的长度。<br><br>参数三：删除截取后要添加进去数组的元素（可以是个数组）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var nums = [1,2,3,7,8,9];</span><br><span class=\"line\">var newElements = [4,5,6];</span><br><span class=\"line\">nums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)</span><br><span class=\"line\">console.log(nums); // 1,2,3,4,5,6,7,8,9</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h4><p>该方法返回通过函数内判断的数组的第一个元素的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ages = [3, 10, 18, 20];</span><br><span class=\"line\"><span class=\"keyword\">function</span> checkAdult(age) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> age &gt;= 18;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">myFunction</span></span>() &#123;</span><br><span class=\"line\">    document.getElementById(<span class=\"string\">\"demo\"</span>).innerHTML = ages.find(checkAdult);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><p>除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy…方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br><br>类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。</p>"},{"title":"debounce","date":"2018-03-25T04:59:53.000Z","_content":"\n>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。\n\n\n<!--more-->\n\n### 防抖\n\n在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。\n在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。\n\n\n```bash\n//最简单的防抖函数\n\nfunction  debounce(fun , delay){\n  var timer = null;\n\n  return function(){\n\n    if(!timer) clearTimeout(timer);\n    timer = setTimeout(fun,delay);\n  }\n}\n\nfunction handleClick(){\n  //一个http请求的骚操作\n}\n//比如当我们点击登陆按钮时，\nbtn.addEventListener('click',debounce(handleClick,500));\n\n```\n上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。\n\n\n### 节流\n\n对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br>\n\n这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br>\n来一个简单的节流函数。\n```bash\nfunction throttle(fun,timeCell){\n\n  var last =new Date().getTime();\n\n  return function(){\n     var now =new Date().getTime();\n    if(last - now >= timeCell){\n      fun();\n      last = now;\n    }\n  }\n}\n\n```\n\n以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。\n","source":"_posts/js-debounce.md","raw":"---\ntitle: debounce\ndate: 2018-03-25 12:59:53\ntags: javascript\ncategories: 学习\n---\n\n>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。\n\n\n<!--more-->\n\n### 防抖\n\n在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。\n在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。\n\n\n```bash\n//最简单的防抖函数\n\nfunction  debounce(fun , delay){\n  var timer = null;\n\n  return function(){\n\n    if(!timer) clearTimeout(timer);\n    timer = setTimeout(fun,delay);\n  }\n}\n\nfunction handleClick(){\n  //一个http请求的骚操作\n}\n//比如当我们点击登陆按钮时，\nbtn.addEventListener('click',debounce(handleClick,500));\n\n```\n上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。\n\n\n### 节流\n\n对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br>\n\n这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br>\n来一个简单的节流函数。\n```bash\nfunction throttle(fun,timeCell){\n\n  var last =new Date().getTime();\n\n  return function(){\n     var now =new Date().getTime();\n    if(last - now >= timeCell){\n      fun();\n      last = now;\n    }\n  }\n}\n\n```\n\n以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。\n","slug":"js-debounce","published":1,"updated":"2019-09-17T02:39:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv7c0002kwfy3bq2ae5b","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。<br>在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//最简单的防抖函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>  debounce(fun , delay)&#123;</span><br><span class=\"line\">  var timer = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer) clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(fun,delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">handleClick</span></span>()&#123;</span><br><span class=\"line\">  //一个http请求的骚操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//比如当我们点击登陆按钮时，</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>,debounce(handleClick,500));</span><br></pre></td></tr></table></figure>\n<p>上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。</p>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br></p>\n<p>这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br><br>来一个简单的节流函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> throttle(fun,timeCell)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var last =new Date().getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">     var now =new Date().getTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(last - now &gt;= timeCell)&#123;</span><br><span class=\"line\">      fun();</span><br><span class=\"line\">      last = now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。</p>\n</blockquote>","more":"<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。<br>在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//最简单的防抖函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>  debounce(fun , delay)&#123;</span><br><span class=\"line\">  var timer = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer) clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(fun,delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">handleClick</span></span>()&#123;</span><br><span class=\"line\">  //一个http请求的骚操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//比如当我们点击登陆按钮时，</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>,debounce(handleClick,500));</span><br></pre></td></tr></table></figure>\n<p>上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。</p>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br></p>\n<p>这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br><br>来一个简单的节流函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> throttle(fun,timeCell)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var last =new Date().getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">     var now =new Date().getTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(last - now &gt;= timeCell)&#123;</span><br><span class=\"line\">      fun();</span><br><span class=\"line\">      last = now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。</p>"},{"title":"instanceof","date":"2018-01-16T03:35:29.000Z","_content":"\n>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。\n\n\n<!--more-->\n\n#### 说明\n\n\n是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。\n\n<weight>expression instanceof class</weight><br>expression和class都是必选项。\n\n\n#### 注意\n关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，\n>VM1621:3 Uncaught TypeError: arguments.push is not a function\n\narguments instanceof Array，返回值是false\n这时得知arguments是一个Array-like对象，并不是真的数组。\n\n另外<br>\n\nclass应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得\n\n```bash\nconsole.log(typeof window); //Object\nconsole.log(window instanceof Object); //true\n```\n网上很多文章都说window instanceof Object返回是false，不知为啥。\n\n#### 常规用法\n\n通常用来判断一个实例是否属于某种类型。\n\n```bash\nfunction Foo(){}\nvar foo = new Foo();\nconsole.log(foo instanceof Foo)//true\n```\n更重要的是用来判断继承关系。\n\n```bash\n\nfunction A() {}\nfunction B() {}\n\nB.prototype = new A(); //原型继承\nvar b = new B();\n\nconsole.log(b instanceof B); //true\nconsole.log(b instanceof A); //true\n\n```\n多层继承关系依然适用。\n\n#### 复杂用法\n```bash\n\nconsole.log(Object instanceof Object);//true\nconsole.log(Function instanceof Function);//true\nconsole.log(Number instanceof Number);//false\nconsole.log(String instanceof String);//false\n\nconsole.log(Function instanceof Object);//true\n\nconsole.log(Foo instanceof Function);//true\nconsole.log(Foo instanceof Foo);//false\n\n```\n参考网上的文章，就是[这一篇](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/)，得知要从两个方面着手：\n + 语言规范是怎么定义instanceof的。\n + Javascript原型继承机制。\n\n #### ECMAScript-262 edition 3 中 instanceof 运算符的定义\n\n 定义如下：\n ```bash\n 11.8.6 The instanceof operator\n The production RelationalExpression:\n     RelationalExpression instanceof ShiftExpression is evaluated as follows:\n\n 1. Evaluate RelationalExpression.\n 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)\n 3. Evaluate ShiftExpression.\n 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)\n 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，\n                                                                //抛出异常\n /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，\n在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。\n所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */\n 6. If Result(4) does not have a [[HasInstance]] method,\n   throw a TypeError exception.\n // 相当于这样调用：Result(4).[[HasInstance]](Result(2))\n 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).\n 8. Return Result(7).\n\n // 相关的 HasInstance 方法定义\n 15.3.5.3 [[HasInstance]] (V)\n Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)\n When the [[HasInstance]] method of F is called with value V,\n     the following steps are taken:\n 1. If V is not an object, return false.// 如果 V 不是 object，直接返回 false\n 2. Call the [[Get]] method of F with property name \"prototype\".// 用 [[Get]] 方法取\n                                                                // F 的 prototype 属性\n 3. Let O be Result(2).//O = F.[[Get]](\"prototype\")\n 4. If O is not an object, throw a TypeError exception.\n 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]\n 6. If V is null, return false.\n // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 true；否则，到 Step 8 返回 Step 5 继续循环\n 7. If O and V refer to the same object or if they refer to objects\n   joined to each other (section 13.1.2), return true.\n 8. Go to step 5.\n\n ```\n上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：\n```bash\n\nfunction instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n var O = R.prototype;// 取 R 的显示原型\n L = L.__proto__;// 取 L 的隐式原型\n while (true) {\n   if (L === null)\n     return false;\n   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true\n     return true;\n   L = L.__proto__;\n }\n}\n```\n当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n","source":"_posts/js-instanceof.md","raw":"---\ntitle: instanceof\ndate: 2018-01-16 11:35:29\ntags: javascript\ncategories: 学习\n---\n\n>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。\n\n\n<!--more-->\n\n#### 说明\n\n\n是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。\n\n<weight>expression instanceof class</weight><br>expression和class都是必选项。\n\n\n#### 注意\n关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，\n>VM1621:3 Uncaught TypeError: arguments.push is not a function\n\narguments instanceof Array，返回值是false\n这时得知arguments是一个Array-like对象，并不是真的数组。\n\n另外<br>\n\nclass应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得\n\n```bash\nconsole.log(typeof window); //Object\nconsole.log(window instanceof Object); //true\n```\n网上很多文章都说window instanceof Object返回是false，不知为啥。\n\n#### 常规用法\n\n通常用来判断一个实例是否属于某种类型。\n\n```bash\nfunction Foo(){}\nvar foo = new Foo();\nconsole.log(foo instanceof Foo)//true\n```\n更重要的是用来判断继承关系。\n\n```bash\n\nfunction A() {}\nfunction B() {}\n\nB.prototype = new A(); //原型继承\nvar b = new B();\n\nconsole.log(b instanceof B); //true\nconsole.log(b instanceof A); //true\n\n```\n多层继承关系依然适用。\n\n#### 复杂用法\n```bash\n\nconsole.log(Object instanceof Object);//true\nconsole.log(Function instanceof Function);//true\nconsole.log(Number instanceof Number);//false\nconsole.log(String instanceof String);//false\n\nconsole.log(Function instanceof Object);//true\n\nconsole.log(Foo instanceof Function);//true\nconsole.log(Foo instanceof Foo);//false\n\n```\n参考网上的文章，就是[这一篇](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/)，得知要从两个方面着手：\n + 语言规范是怎么定义instanceof的。\n + Javascript原型继承机制。\n\n #### ECMAScript-262 edition 3 中 instanceof 运算符的定义\n\n 定义如下：\n ```bash\n 11.8.6 The instanceof operator\n The production RelationalExpression:\n     RelationalExpression instanceof ShiftExpression is evaluated as follows:\n\n 1. Evaluate RelationalExpression.\n 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)\n 3. Evaluate ShiftExpression.\n 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)\n 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，\n                                                                //抛出异常\n /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，\n在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。\n所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */\n 6. If Result(4) does not have a [[HasInstance]] method,\n   throw a TypeError exception.\n // 相当于这样调用：Result(4).[[HasInstance]](Result(2))\n 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).\n 8. Return Result(7).\n\n // 相关的 HasInstance 方法定义\n 15.3.5.3 [[HasInstance]] (V)\n Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)\n When the [[HasInstance]] method of F is called with value V,\n     the following steps are taken:\n 1. If V is not an object, return false.// 如果 V 不是 object，直接返回 false\n 2. Call the [[Get]] method of F with property name \"prototype\".// 用 [[Get]] 方法取\n                                                                // F 的 prototype 属性\n 3. Let O be Result(2).//O = F.[[Get]](\"prototype\")\n 4. If O is not an object, throw a TypeError exception.\n 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]\n 6. If V is null, return false.\n // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 true；否则，到 Step 8 返回 Step 5 继续循环\n 7. If O and V refer to the same object or if they refer to objects\n   joined to each other (section 13.1.2), return true.\n 8. Go to step 5.\n\n ```\n上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：\n```bash\n\nfunction instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n var O = R.prototype;// 取 R 的显示原型\n L = L.__proto__;// 取 L 的隐式原型\n while (true) {\n   if (L === null)\n     return false;\n   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true\n     return true;\n   L = L.__proto__;\n }\n}\n```\n当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n","slug":"js-instanceof","published":1,"updated":"2019-09-17T02:40:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv7k0006kwfyl77u00w3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。</p>\n<p><weight>expression instanceof class</weight><br>expression和class都是必选项。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，</p>\n<blockquote>\n<p>VM1621:3 Uncaught TypeError: arguments.push is not a function</p>\n</blockquote>\n<p>arguments instanceof Array，返回值是false<br>这时得知arguments是一个Array-like对象，并不是真的数组。</p>\n<p>另外<br></p>\n<p>class应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(typeof window); //Object</span><br><span class=\"line\">console.log(window instanceof Object); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>网上很多文章都说window instanceof Object返回是false，不知为啥。</p>\n<h4 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h4><p>通常用来判断一个实例是否属于某种类型。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">console.log(foo instanceof Foo)//<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>更重要的是用来判断继承关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = new A(); //原型继承</span><br><span class=\"line\">var b = new B();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b instanceof B); //<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(b instanceof A); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>多层继承关系依然适用。</p>\n<h4 id=\"复杂用法\"><a href=\"#复杂用法\" class=\"headerlink\" title=\"复杂用法\"></a>复杂用法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">console.log(Object instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Function instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Number instanceof Number);//<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(String instanceof String);//<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Foo instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Foo instanceof Foo);//<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>参考网上的文章，就是<a href=\"https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\" target=\"_blank\" rel=\"noopener\">这一篇</a>，得知要从两个方面着手：</p>\n<ul>\n<li>语言规范是怎么定义instanceof的。</li>\n<li><p>Javascript原型继承机制。</p>\n<h4 id=\"ECMAScript-262-edition-3-中-instanceof-运算符的定义\"><a href=\"#ECMAScript-262-edition-3-中-instanceof-运算符的定义\" class=\"headerlink\" title=\"ECMAScript-262 edition 3 中 instanceof 运算符的定义\"></a>ECMAScript-262 edition 3 中 instanceof 运算符的定义</h4><p>定义如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 11.8.6 The instanceof operator</span><br><span class=\"line\"> The production RelationalExpression:</span><br><span class=\"line\">     RelationalExpression instanceof ShiftExpression is evaluated as follows:</span><br><span class=\"line\"></span><br><span class=\"line\"> 1. Evaluate RelationalExpression.</span><br><span class=\"line\"> 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)</span><br><span class=\"line\"> 3. Evaluate ShiftExpression.</span><br><span class=\"line\"> 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)</span><br><span class=\"line\"> 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，</span><br><span class=\"line\">                                                                //抛出异常</span><br><span class=\"line\"> /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，</span><br><span class=\"line\">在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。</span><br><span class=\"line\">所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */</span><br><span class=\"line\"> 6. If Result(4) does not have a [[HasInstance]] method,</span><br><span class=\"line\">   throw a TypeError exception.</span><br><span class=\"line\"> // 相当于这样调用：Result(4).[[HasInstance]](Result(2))</span><br><span class=\"line\"> 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).</span><br><span class=\"line\"> 8. Return Result(7).</span><br><span class=\"line\"></span><br><span class=\"line\"> // 相关的 HasInstance 方法定义</span><br><span class=\"line\"> 15.3.5.3 [[HasInstance]] (V)</span><br><span class=\"line\"> Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)</span><br><span class=\"line\"> When the [[HasInstance]] method of F is called with value V,</span><br><span class=\"line\">     the following steps are taken:</span><br><span class=\"line\"> 1. If V is not an object, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.// 如果 V 不是 object，直接返回 <span class=\"literal\">false</span></span><br><span class=\"line\"> 2. Call the [[Get]] method of F with property name <span class=\"string\">\"prototype\"</span>.// 用 [[Get]] 方法取</span><br><span class=\"line\">                                                                // F 的 prototype 属性</span><br><span class=\"line\"> 3. Let O be Result(2).//O = F.[[Get]](<span class=\"string\">\"prototype\"</span>)</span><br><span class=\"line\"> 4. If O is not an object, throw a TypeError exception.</span><br><span class=\"line\"> 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]</span><br><span class=\"line\"> 6. If V is null, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.</span><br><span class=\"line\"> // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 <span class=\"literal\">true</span>；否则，到 Step 8 返回 Step 5 继续循环</span><br><span class=\"line\"> 7. If O and V refer to the same object or <span class=\"keyword\">if</span> they refer to objects</span><br><span class=\"line\">   joined to each other (section 13.1.2), <span class=\"built_in\">return</span> <span class=\"literal\">true</span>.</span><br><span class=\"line\"> 8. Go to step 5.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class=\"line\"> var O = R.prototype;// 取 R 的显示原型</span><br><span class=\"line\"> L = L.__proto__;// 取 L 的隐式原型</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (L === null)</span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (O === L)// 这里重点：当 O 严格等于 L 时，返回 <span class=\"literal\">true</span></span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   L = L.__proto__;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。</p>\n</blockquote>","more":"<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。</p>\n<p><weight>expression instanceof class</weight><br>expression和class都是必选项。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，</p>\n<blockquote>\n<p>VM1621:3 Uncaught TypeError: arguments.push is not a function</p>\n</blockquote>\n<p>arguments instanceof Array，返回值是false<br>这时得知arguments是一个Array-like对象，并不是真的数组。</p>\n<p>另外<br></p>\n<p>class应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(typeof window); //Object</span><br><span class=\"line\">console.log(window instanceof Object); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>网上很多文章都说window instanceof Object返回是false，不知为啥。</p>\n<h4 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h4><p>通常用来判断一个实例是否属于某种类型。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">console.log(foo instanceof Foo)//<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>更重要的是用来判断继承关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = new A(); //原型继承</span><br><span class=\"line\">var b = new B();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b instanceof B); //<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(b instanceof A); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>多层继承关系依然适用。</p>\n<h4 id=\"复杂用法\"><a href=\"#复杂用法\" class=\"headerlink\" title=\"复杂用法\"></a>复杂用法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">console.log(Object instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Function instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Number instanceof Number);//<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(String instanceof String);//<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Foo instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Foo instanceof Foo);//<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>参考网上的文章，就是<a href=\"https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\" target=\"_blank\" rel=\"noopener\">这一篇</a>，得知要从两个方面着手：</p>\n<ul>\n<li>语言规范是怎么定义instanceof的。</li>\n<li><p>Javascript原型继承机制。</p>\n<h4 id=\"ECMAScript-262-edition-3-中-instanceof-运算符的定义\"><a href=\"#ECMAScript-262-edition-3-中-instanceof-运算符的定义\" class=\"headerlink\" title=\"ECMAScript-262 edition 3 中 instanceof 运算符的定义\"></a>ECMAScript-262 edition 3 中 instanceof 运算符的定义</h4><p>定义如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 11.8.6 The instanceof operator</span><br><span class=\"line\"> The production RelationalExpression:</span><br><span class=\"line\">     RelationalExpression instanceof ShiftExpression is evaluated as follows:</span><br><span class=\"line\"></span><br><span class=\"line\"> 1. Evaluate RelationalExpression.</span><br><span class=\"line\"> 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)</span><br><span class=\"line\"> 3. Evaluate ShiftExpression.</span><br><span class=\"line\"> 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)</span><br><span class=\"line\"> 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，</span><br><span class=\"line\">                                                                //抛出异常</span><br><span class=\"line\"> /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，</span><br><span class=\"line\">在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。</span><br><span class=\"line\">所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */</span><br><span class=\"line\"> 6. If Result(4) does not have a [[HasInstance]] method,</span><br><span class=\"line\">   throw a TypeError exception.</span><br><span class=\"line\"> // 相当于这样调用：Result(4).[[HasInstance]](Result(2))</span><br><span class=\"line\"> 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).</span><br><span class=\"line\"> 8. Return Result(7).</span><br><span class=\"line\"></span><br><span class=\"line\"> // 相关的 HasInstance 方法定义</span><br><span class=\"line\"> 15.3.5.3 [[HasInstance]] (V)</span><br><span class=\"line\"> Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)</span><br><span class=\"line\"> When the [[HasInstance]] method of F is called with value V,</span><br><span class=\"line\">     the following steps are taken:</span><br><span class=\"line\"> 1. If V is not an object, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.// 如果 V 不是 object，直接返回 <span class=\"literal\">false</span></span><br><span class=\"line\"> 2. Call the [[Get]] method of F with property name <span class=\"string\">\"prototype\"</span>.// 用 [[Get]] 方法取</span><br><span class=\"line\">                                                                // F 的 prototype 属性</span><br><span class=\"line\"> 3. Let O be Result(2).//O = F.[[Get]](<span class=\"string\">\"prototype\"</span>)</span><br><span class=\"line\"> 4. If O is not an object, throw a TypeError exception.</span><br><span class=\"line\"> 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]</span><br><span class=\"line\"> 6. If V is null, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.</span><br><span class=\"line\"> // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 <span class=\"literal\">true</span>；否则，到 Step 8 返回 Step 5 继续循环</span><br><span class=\"line\"> 7. If O and V refer to the same object or <span class=\"keyword\">if</span> they refer to objects</span><br><span class=\"line\">   joined to each other (section 13.1.2), <span class=\"built_in\">return</span> <span class=\"literal\">true</span>.</span><br><span class=\"line\"> 8. Go to step 5.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class=\"line\"> var O = R.prototype;// 取 R 的显示原型</span><br><span class=\"line\"> L = L.__proto__;// 取 L 的隐式原型</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (L === null)</span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (O === L)// 这里重点：当 O 严格等于 L 时，返回 <span class=\"literal\">true</span></span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   L = L.__proto__;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt></p>"},{"title":"内存管理","date":"2018-03-09T16:24:22.000Z","_content":"\n>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。\n\n\n### 所有之前\n\n```bash\nvar a = {n:1};\nvar b = a;\na.x = a ={n:2};\nconsole.log(a.x);\nconsole.log(b.x);\n```\n\n<!--more-->\n在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。\n众所周知，js在微观上(以代码块为单位)是先定义，再执行的。\n+ 第一行，将{n:1}对象所在的内存地址，存到变量a；\n+ 第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。\n+ 第三行，比较麻烦，js有意思的地方(坑)就在这。\n    + 按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。\n    + 接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。\n    + a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。\n+ 于是乎，结果就是undefined  {n:2}。\n\n之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。\nok，开始BB....\n### 内存模型\njs中内存空间，大致分为三类：\n+ 常量池：保存着诸如数字，字符的常量。\n+ 栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。\n### 内存生命周期\njs(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：\n#### 1.分配内存\n分配内存往往意味着新的'值(包括变量，数字，字符，对象等)'的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：\n```bash\nvar a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里\n\nvar b = 'laalal'; //给字符串分配内存\n\nvar obj ={\n  n:1,\n  x:2\n};//给对象分配内存\n\nfunction C(){\n  console.log(a);\n} //给函数(可调用对象)分配内存\n\nvar a = new C();//函数调用的的结果会分配内存\n```\n思考一段非常简单的代码:\n```bash\nvar a ={n:1};\nvar b=a;\na = {n:2};\nconsole.log(b); //{n:1}\n```\n从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的'值'的产生往往意味着新的内存被开辟。\n#### 2.调用内存\n使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。\n\n#### 3.内存回收\n全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br>\n而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。\n来来来，再看一段代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n}\nA();\n```\n当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br>\n但是如果稍微改变一下代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n  return obj;\n}\nvar a = A();\n```\n函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。\n 闭包以后再说。\n","source":"_posts/js-jsMemoryManagent.md","raw":"---\ntitle: 内存管理\ndate: 2018-03-10 00:24:22\ntags: javascript\ncategories: 学习\n---\n\n>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。\n\n\n### 所有之前\n\n```bash\nvar a = {n:1};\nvar b = a;\na.x = a ={n:2};\nconsole.log(a.x);\nconsole.log(b.x);\n```\n\n<!--more-->\n在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。\n众所周知，js在微观上(以代码块为单位)是先定义，再执行的。\n+ 第一行，将{n:1}对象所在的内存地址，存到变量a；\n+ 第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。\n+ 第三行，比较麻烦，js有意思的地方(坑)就在这。\n    + 按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。\n    + 接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。\n    + a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。\n+ 于是乎，结果就是undefined  {n:2}。\n\n之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。\nok，开始BB....\n### 内存模型\njs中内存空间，大致分为三类：\n+ 常量池：保存着诸如数字，字符的常量。\n+ 栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。\n### 内存生命周期\njs(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：\n#### 1.分配内存\n分配内存往往意味着新的'值(包括变量，数字，字符，对象等)'的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：\n```bash\nvar a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里\n\nvar b = 'laalal'; //给字符串分配内存\n\nvar obj ={\n  n:1,\n  x:2\n};//给对象分配内存\n\nfunction C(){\n  console.log(a);\n} //给函数(可调用对象)分配内存\n\nvar a = new C();//函数调用的的结果会分配内存\n```\n思考一段非常简单的代码:\n```bash\nvar a ={n:1};\nvar b=a;\na = {n:2};\nconsole.log(b); //{n:1}\n```\n从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的'值'的产生往往意味着新的内存被开辟。\n#### 2.调用内存\n使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。\n\n#### 3.内存回收\n全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br>\n而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。\n来来来，再看一段代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n}\nA();\n```\n当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br>\n但是如果稍微改变一下代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n  return obj;\n}\nvar a = A();\n```\n函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。\n 闭包以后再说。\n","slug":"js-jsMemoryManagent","published":1,"updated":"2019-09-17T02:40:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv7l0007kwfyz2iqniri","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。</p>\n</blockquote>\n<h3 id=\"所有之前\"><a href=\"#所有之前\" class=\"headerlink\" title=\"所有之前\"></a>所有之前</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;n:1&#125;;</span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">a.x = a =&#123;n:2&#125;;</span><br><span class=\"line\">console.log(a.x);</span><br><span class=\"line\">console.log(b.x);</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。<br>众所周知，js在微观上(以代码块为单位)是先定义，再执行的。</p>\n<ul>\n<li>第一行，将{n:1}对象所在的内存地址，存到变量a；</li>\n<li>第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。</li>\n<li>第三行，比较麻烦，js有意思的地方(坑)就在这。<ul>\n<li>按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。</li>\n<li>接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。</li>\n<li>a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。</li>\n</ul>\n</li>\n<li>于是乎，结果就是undefined  {n:2}。</li>\n</ul>\n<p>之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。<br>ok，开始BB….</p>\n<h3 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h3><p>js中内存空间，大致分为三类：</p>\n<ul>\n<li>常量池：保存着诸如数字，字符的常量。</li>\n<li>栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。<h3 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h3>js(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：<h4 id=\"1-分配内存\"><a href=\"#1-分配内存\" class=\"headerlink\" title=\"1.分配内存\"></a>1.分配内存</h4>分配内存往往意味着新的’值(包括变量，数字，字符，对象等)’的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里</span><br><span class=\"line\"></span><br><span class=\"line\">var b = <span class=\"string\">'laalal'</span>; //给字符串分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var obj =&#123;</span><br><span class=\"line\">  n:1,</span><br><span class=\"line\">  x:2</span><br><span class=\"line\">&#125;;//给对象分配内存</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">C</span></span>()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125; //给函数(可调用对象)分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var a = new C();//函数调用的的结果会分配内存</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>思考一段非常简单的代码:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a =&#123;n:1&#125;;</span><br><span class=\"line\">var b=a;</span><br><span class=\"line\">a = &#123;n:2&#125;;</span><br><span class=\"line\">console.log(b); //&#123;n:1&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的’值’的产生往往意味着新的内存被开辟。</p>\n<h4 id=\"2-调用内存\"><a href=\"#2-调用内存\" class=\"headerlink\" title=\"2.调用内存\"></a>2.调用内存</h4><p>使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。</p>\n<h4 id=\"3-内存回收\"><a href=\"#3-内存回收\" class=\"headerlink\" title=\"3.内存回收\"></a>3.内存回收</h4><p>全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br><br>而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。<br>来来来，再看一段代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();</span><br></pre></td></tr></table></figure></p>\n<p>当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br><br>但是如果稍微改变一下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = A();</span><br></pre></td></tr></table></figure></p>\n<p>函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。<br> 闭包以后再说。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。</p>\n</blockquote>\n<h3 id=\"所有之前\"><a href=\"#所有之前\" class=\"headerlink\" title=\"所有之前\"></a>所有之前</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;n:1&#125;;</span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">a.x = a =&#123;n:2&#125;;</span><br><span class=\"line\">console.log(a.x);</span><br><span class=\"line\">console.log(b.x);</span><br></pre></td></tr></table></figure>","more":"<p>在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。<br>众所周知，js在微观上(以代码块为单位)是先定义，再执行的。</p>\n<ul>\n<li>第一行，将{n:1}对象所在的内存地址，存到变量a；</li>\n<li>第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。</li>\n<li>第三行，比较麻烦，js有意思的地方(坑)就在这。<ul>\n<li>按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。</li>\n<li>接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。</li>\n<li>a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。</li>\n</ul>\n</li>\n<li>于是乎，结果就是undefined  {n:2}。</li>\n</ul>\n<p>之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。<br>ok，开始BB….</p>\n<h3 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h3><p>js中内存空间，大致分为三类：</p>\n<ul>\n<li>常量池：保存着诸如数字，字符的常量。</li>\n<li>栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。<h3 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h3>js(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：<h4 id=\"1-分配内存\"><a href=\"#1-分配内存\" class=\"headerlink\" title=\"1.分配内存\"></a>1.分配内存</h4>分配内存往往意味着新的’值(包括变量，数字，字符，对象等)’的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里</span><br><span class=\"line\"></span><br><span class=\"line\">var b = <span class=\"string\">'laalal'</span>; //给字符串分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var obj =&#123;</span><br><span class=\"line\">  n:1,</span><br><span class=\"line\">  x:2</span><br><span class=\"line\">&#125;;//给对象分配内存</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">C</span></span>()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125; //给函数(可调用对象)分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var a = new C();//函数调用的的结果会分配内存</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>思考一段非常简单的代码:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a =&#123;n:1&#125;;</span><br><span class=\"line\">var b=a;</span><br><span class=\"line\">a = &#123;n:2&#125;;</span><br><span class=\"line\">console.log(b); //&#123;n:1&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的’值’的产生往往意味着新的内存被开辟。</p>\n<h4 id=\"2-调用内存\"><a href=\"#2-调用内存\" class=\"headerlink\" title=\"2.调用内存\"></a>2.调用内存</h4><p>使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。</p>\n<h4 id=\"3-内存回收\"><a href=\"#3-内存回收\" class=\"headerlink\" title=\"3.内存回收\"></a>3.内存回收</h4><p>全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br><br>而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。<br>来来来，再看一段代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();</span><br></pre></td></tr></table></figure></p>\n<p>当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br><br>但是如果稍微改变一下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = A();</span><br></pre></td></tr></table></figure></p>\n<p>函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。<br> 闭包以后再说。</p>"},{"title":"prototype","date":"2018-01-18T03:35:52.000Z","_content":"\n>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。\n> 就当是重新学一遍。\n\n<!--more-->\n\n### 原型和原型链\n>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，\n>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.\\_\\_proto\\_\\_ ===null，这便是原型链的顶端。\n\n举个例子：\n首先定义一个构造器函数\n```bash\nfunction Person(name, age, gender){\n  this.name = name;\n  this.age = age;\n  this.gender = gender;\n}\n\n```\n然后通过此方法创建实例\n\n```bash\nvar person = new Person('xyl', 18, '男');\n```\n然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况\n\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\">\n这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在\\_\\_proto\\_\\_里，我们依然可以调用这些方法，就是因为原型链的存在。\n举个栗子：\n当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：\n+ js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。\n+ 解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。\n+ 解释器会在Person.prototype.\\_\\_proto\\_\\_也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.\\_\\_proto\\_\\_ ===null，因此没有再往上查找的必要。\n\n\n### “继承”\n原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：\n```bash\n//声明两个构造函数\nfunction A(){}\nfunction B(){}\n//改变原型链的指向\nB.prototype = new A();//原型“继承”\nlet b = new B();\n```\n这就是“继承”的方式，通过改变\\_\\_proto\\_\\_的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的\\_\\_proto\\_\\_是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-> B.prototype ->Object.prototype，现在确是 对象本身-> B.prototype ->A.prototype ->Object.prototype。\n<br>\n\n另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是\\_\\_proto\\_\\_（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。\n\n\n\n### prototype和\\_\\_proto\\_\\_\n\n原型分两种，隐式原型(\\_\\_proto\\_\\_)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。\n<br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。\n咳咳，这个时候，就要放出珍藏已久的图喽。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n来两到测试题\n```bash\n# 测试题1\nfunction A(){}\nA.prototype.n=1;\nvar b= new A();\n\nA.prototype ={\n  n:2,\n  m:3\n}\nvar c = new A();\n\nconsole.log(b.n,b.m,c.n,c.m);\n\n```\n答案是1 undefined 2 3。\n其实现在倒觉得一个对象的__proto__指向它的构造函数的prototype有点不准确，他们俩的关系其实就是\n```bash\nvar a={};\n\nvar b = a;\n\n\n```\n如果a改变了，指向一个新对象，然而b指向的依然是原来的内存\n### constructor\n\n```bash\n   function Foo(){}\n   Foo.prototype.constructor === Foo; //true\n   let foo = new Foo();\n   foo.constructor === Foo; //true\n```\n一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。\n举个例子：\n\n```bash\nfunction Foo(){}\nfunction Bar(){}\nFoo.prototype = new Bar();\nlet f = new Foo();\nf.constructor === Foo; //false\nf.constructor === Object; //true\n\n```\n\n将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br>\nf并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。\n```bash\nObject.defineProperty(Foo.prototype, \"constructor\", {\n  enumerable :false,\n  writable:true,\n  configurable:true,\n  value:Foo  //让constructor指向Foo\n})\n\n```\n","source":"_posts/js-prototype.md","raw":"---\ntitle: prototype\ndate: 2018-01-18 11:35:52\ntags: javascript\ncategories: 学习\n---\n\n>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。\n> 就当是重新学一遍。\n\n<!--more-->\n\n### 原型和原型链\n>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，\n>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.\\_\\_proto\\_\\_ ===null，这便是原型链的顶端。\n\n举个例子：\n首先定义一个构造器函数\n```bash\nfunction Person(name, age, gender){\n  this.name = name;\n  this.age = age;\n  this.gender = gender;\n}\n\n```\n然后通过此方法创建实例\n\n```bash\nvar person = new Person('xyl', 18, '男');\n```\n然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况\n\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\">\n这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在\\_\\_proto\\_\\_里，我们依然可以调用这些方法，就是因为原型链的存在。\n举个栗子：\n当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：\n+ js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。\n+ 解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。\n+ 解释器会在Person.prototype.\\_\\_proto\\_\\_也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.\\_\\_proto\\_\\_ ===null，因此没有再往上查找的必要。\n\n\n### “继承”\n原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：\n```bash\n//声明两个构造函数\nfunction A(){}\nfunction B(){}\n//改变原型链的指向\nB.prototype = new A();//原型“继承”\nlet b = new B();\n```\n这就是“继承”的方式，通过改变\\_\\_proto\\_\\_的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的\\_\\_proto\\_\\_是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-> B.prototype ->Object.prototype，现在确是 对象本身-> B.prototype ->A.prototype ->Object.prototype。\n<br>\n\n另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是\\_\\_proto\\_\\_（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。\n\n\n\n### prototype和\\_\\_proto\\_\\_\n\n原型分两种，隐式原型(\\_\\_proto\\_\\_)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。\n<br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。\n咳咳，这个时候，就要放出珍藏已久的图喽。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n来两到测试题\n```bash\n# 测试题1\nfunction A(){}\nA.prototype.n=1;\nvar b= new A();\n\nA.prototype ={\n  n:2,\n  m:3\n}\nvar c = new A();\n\nconsole.log(b.n,b.m,c.n,c.m);\n\n```\n答案是1 undefined 2 3。\n其实现在倒觉得一个对象的__proto__指向它的构造函数的prototype有点不准确，他们俩的关系其实就是\n```bash\nvar a={};\n\nvar b = a;\n\n\n```\n如果a改变了，指向一个新对象，然而b指向的依然是原来的内存\n### constructor\n\n```bash\n   function Foo(){}\n   Foo.prototype.constructor === Foo; //true\n   let foo = new Foo();\n   foo.constructor === Foo; //true\n```\n一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。\n举个例子：\n\n```bash\nfunction Foo(){}\nfunction Bar(){}\nFoo.prototype = new Bar();\nlet f = new Foo();\nf.constructor === Foo; //false\nf.constructor === Object; //true\n\n```\n\n将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br>\nf并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。\n```bash\nObject.defineProperty(Foo.prototype, \"constructor\", {\n  enumerable :false,\n  writable:true,\n  configurable:true,\n  value:Foo  //让constructor指向Foo\n})\n\n```\n","slug":"js-prototype","published":1,"updated":"2019-09-17T02:41:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv7n0008kwfy4q12hie3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。<br>就当是重新学一遍。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a>原型和原型链</h3><blockquote>\n<p>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，<br>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.__proto__ ===null，这便是原型链的顶端。</p>\n</blockquote>\n<p>举个例子：<br>首先定义一个构造器函数<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Person(name, age, gender)&#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  this.gender = gender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过此方法创建实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = new Person(<span class=\"string\">'xyl'</span>, 18, <span class=\"string\">'男'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\"><br>这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在__proto__里，我们依然可以调用这些方法，就是因为原型链的存在。<br>举个栗子：<br>当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：</p>\n<ul>\n<li>js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。</li>\n<li>解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。</li>\n<li>解释器会在Person.prototype.__proto__也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.__proto__ ===null，因此没有再往上查找的必要。</li>\n</ul>\n<h3 id=\"“继承”\"><a href=\"#“继承”\" class=\"headerlink\" title=\"“继承”\"></a>“继承”</h3><p>原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明两个构造函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>()&#123;&#125;</span><br><span class=\"line\">//改变原型链的指向</span><br><span class=\"line\">B.prototype = new A();//原型“继承”</span><br><span class=\"line\"><span class=\"built_in\">let</span> b = new B();</span><br></pre></td></tr></table></figure></p>\n<p>这就是“继承”的方式，通过改变__proto__的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的__proto__是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-&gt; B.prototype -&gt;Object.prototype，现在确是 对象本身-&gt; B.prototype -&gt;A.prototype -&gt;Object.prototype。<br><br></p>\n<p>另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是__proto__（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。</p>\n<h3 id=\"prototype和-proto\"><a href=\"#prototype和-proto\" class=\"headerlink\" title=\"prototype和__proto__\"></a>prototype和__proto__</h3><p>原型分两种，隐式原型(__proto__)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。<br><br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。<br>咳咳，这个时候，就要放出珍藏已久的图喽。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt><br>来两到测试题<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试题1</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\">A.prototype.n=1;</span><br><span class=\"line\">var b= new A();</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype =&#123;</span><br><span class=\"line\">  n:2,</span><br><span class=\"line\">  m:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var c = new A();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.n,b.m,c.n,c.m);</span><br></pre></td></tr></table></figure></p>\n<p>答案是1 undefined 2 3。<br>其实现在倒觉得一个对象的<strong>proto</strong>指向它的构造函数的prototype有点不准确，他们俩的关系其实就是<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br></pre></td></tr></table></figure></p>\n<p>如果a改变了，指向一个新对象，然而b指向的依然是原来的内存</p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype.constructor === Foo; //<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> foo = new Foo();</span><br><span class=\"line\">foo.constructor === Foo; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。<br>举个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Bar</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype = new Bar();</span><br><span class=\"line\"><span class=\"built_in\">let</span> f = new Foo();</span><br><span class=\"line\">f.constructor === Foo; //<span class=\"literal\">false</span></span><br><span class=\"line\">f.constructor === Object; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br><br>f并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Foo.prototype, <span class=\"string\">\"constructor\"</span>, &#123;</span><br><span class=\"line\">  enumerable :<span class=\"literal\">false</span>,</span><br><span class=\"line\">  writable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  configurable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  value:Foo  //让constructor指向Foo</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。<br>就当是重新学一遍。</p>\n</blockquote>","more":"<h3 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a>原型和原型链</h3><blockquote>\n<p>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，<br>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.__proto__ ===null，这便是原型链的顶端。</p>\n</blockquote>\n<p>举个例子：<br>首先定义一个构造器函数<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Person(name, age, gender)&#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  this.gender = gender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过此方法创建实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = new Person(<span class=\"string\">'xyl'</span>, 18, <span class=\"string\">'男'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\"><br>这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在__proto__里，我们依然可以调用这些方法，就是因为原型链的存在。<br>举个栗子：<br>当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：</p>\n<ul>\n<li>js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。</li>\n<li>解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。</li>\n<li>解释器会在Person.prototype.__proto__也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.__proto__ ===null，因此没有再往上查找的必要。</li>\n</ul>\n<h3 id=\"“继承”\"><a href=\"#“继承”\" class=\"headerlink\" title=\"“继承”\"></a>“继承”</h3><p>原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明两个构造函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>()&#123;&#125;</span><br><span class=\"line\">//改变原型链的指向</span><br><span class=\"line\">B.prototype = new A();//原型“继承”</span><br><span class=\"line\"><span class=\"built_in\">let</span> b = new B();</span><br></pre></td></tr></table></figure></p>\n<p>这就是“继承”的方式，通过改变__proto__的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的__proto__是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-&gt; B.prototype -&gt;Object.prototype，现在确是 对象本身-&gt; B.prototype -&gt;A.prototype -&gt;Object.prototype。<br><br></p>\n<p>另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是__proto__（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。</p>\n<h3 id=\"prototype和-proto\"><a href=\"#prototype和-proto\" class=\"headerlink\" title=\"prototype和__proto__\"></a>prototype和__proto__</h3><p>原型分两种，隐式原型(__proto__)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。<br><br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。<br>咳咳，这个时候，就要放出珍藏已久的图喽。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt><br>来两到测试题<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试题1</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\">A.prototype.n=1;</span><br><span class=\"line\">var b= new A();</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype =&#123;</span><br><span class=\"line\">  n:2,</span><br><span class=\"line\">  m:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var c = new A();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.n,b.m,c.n,c.m);</span><br></pre></td></tr></table></figure></p>\n<p>答案是1 undefined 2 3。<br>其实现在倒觉得一个对象的<strong>proto</strong>指向它的构造函数的prototype有点不准确，他们俩的关系其实就是<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br></pre></td></tr></table></figure></p>\n<p>如果a改变了，指向一个新对象，然而b指向的依然是原来的内存</p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype.constructor === Foo; //<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> foo = new Foo();</span><br><span class=\"line\">foo.constructor === Foo; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。<br>举个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Bar</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype = new Bar();</span><br><span class=\"line\"><span class=\"built_in\">let</span> f = new Foo();</span><br><span class=\"line\">f.constructor === Foo; //<span class=\"literal\">false</span></span><br><span class=\"line\">f.constructor === Object; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br><br>f并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Foo.prototype, <span class=\"string\">\"constructor\"</span>, &#123;</span><br><span class=\"line\">  enumerable :<span class=\"literal\">false</span>,</span><br><span class=\"line\">  writable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  configurable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  value:Foo  //让constructor指向Foo</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>"},{"title":"selfPromise","date":"2018-12-30T16:34:38.000Z","_content":"\n> 把之前手写过的promise在梳理一遍\n\n<!--more-->\n\n###  代码\n\n```bash \nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction myPromise(fn) {\n    var state = PENDING;\n    var value = null;\n    var handlers = [];\n    var e =null;\n\n    function resolve(val) {\n        if (val instanceof myPromise) {\n            try{\n                val.then(resolve);\n            }catch(e){\n                reject(e)\n            }\n            return;\n        }\n        state = FULFILLED;\n        value = val;\n        setTimeout(function () {\n            handlers.map(function (handler) {\n                handle(handler)\n            })\n        }, 0)\n    }\n\n    function reject(err) {\n        state = REJECTED;\n        e = err\n    }\n\n    function handle(handler) {\n        if (state === PENDING) {\n            handlers.push(handler);\n            return;\n        }\n        try{\n            if (state === FULFILLED && typeof handler.onFulfilled === 'function') {\n                let ret = handler.onFulfilled(value);\n                handler.resolve(ret);\n            }\n        }catch(e){\n            reject(e)\n        }\n    }\n\n\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略\n    this.then = function (onFulfilled, onRejected) {\n        return new myPromise(function (resolve, reject) {\n            handle({\n                onFulfilled,\n                resolve,\n            })\n        })\n    }\n\n    fn(resolve, reject);\n}\n\n```\n\nPS：状态切换就不说了，很显然。\n\nthen函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。\n\n```bash  \nnew myPromise(function(resolve){\n    GET(url, function(data1){\n        resolve(data1)\n    })\n}).then(function(data1){\n\tconst toChainPoromise = new myPromise(function(resolve){\n    \tPOST(url, function(data2){\n             resolve(data1+data2)\n    \t})\n    });\n    return toChainPoromise;\n}).then(function(data){\n    console.log(data)\n})\n```\n\n为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。\n\n\n\n","source":"_posts/js-selfPromise.md","raw":"---\ntitle: selfPromise\ndate: 2018-12-31 00:34:38\ntags: 学习\n\n---\n\n> 把之前手写过的promise在梳理一遍\n\n<!--more-->\n\n###  代码\n\n```bash \nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction myPromise(fn) {\n    var state = PENDING;\n    var value = null;\n    var handlers = [];\n    var e =null;\n\n    function resolve(val) {\n        if (val instanceof myPromise) {\n            try{\n                val.then(resolve);\n            }catch(e){\n                reject(e)\n            }\n            return;\n        }\n        state = FULFILLED;\n        value = val;\n        setTimeout(function () {\n            handlers.map(function (handler) {\n                handle(handler)\n            })\n        }, 0)\n    }\n\n    function reject(err) {\n        state = REJECTED;\n        e = err\n    }\n\n    function handle(handler) {\n        if (state === PENDING) {\n            handlers.push(handler);\n            return;\n        }\n        try{\n            if (state === FULFILLED && typeof handler.onFulfilled === 'function') {\n                let ret = handler.onFulfilled(value);\n                handler.resolve(ret);\n            }\n        }catch(e){\n            reject(e)\n        }\n    }\n\n\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略\n    this.then = function (onFulfilled, onRejected) {\n        return new myPromise(function (resolve, reject) {\n            handle({\n                onFulfilled,\n                resolve,\n            })\n        })\n    }\n\n    fn(resolve, reject);\n}\n\n```\n\nPS：状态切换就不说了，很显然。\n\nthen函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。\n\n```bash  \nnew myPromise(function(resolve){\n    GET(url, function(data1){\n        resolve(data1)\n    })\n}).then(function(data1){\n\tconst toChainPoromise = new myPromise(function(resolve){\n    \tPOST(url, function(data2){\n             resolve(data1+data2)\n    \t})\n    });\n    return toChainPoromise;\n}).then(function(data){\n    console.log(data)\n})\n```\n\n为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。\n\n\n\n","slug":"js-selfPromise","published":1,"updated":"2019-09-17T02:42:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv7v000ckwfy1kcpc4u3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>把之前手写过的promise在梳理一遍</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var PENDING = 0;</span><br><span class=\"line\">var FULFILLED = 1;</span><br><span class=\"line\">var REJECTED = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> myPromise(fn) &#123;</span><br><span class=\"line\">    var state = PENDING;</span><br><span class=\"line\">    var value = null;</span><br><span class=\"line\">    var handlers = [];</span><br><span class=\"line\">    var e =null;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> resolve(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val instanceof myPromise) &#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                val.then(resolve);</span><br><span class=\"line\">            &#125;catch(e)&#123;</span><br><span class=\"line\">                reject(e)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = FULFILLED;</span><br><span class=\"line\">        value = val;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            handlers.map(<span class=\"keyword\">function</span> (handler) &#123;</span><br><span class=\"line\">                handle(handler)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> reject(err) &#123;</span><br><span class=\"line\">        state = REJECTED;</span><br><span class=\"line\">        e = err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> handle(handler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">            handlers.push(handler);</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">let</span> ret = handler.onFulfilled(value);</span><br><span class=\"line\">                handler.resolve(ret);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;catch(e)&#123;</span><br><span class=\"line\">            reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略</span><br><span class=\"line\">    this.then = <span class=\"keyword\">function</span> (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new myPromise(<span class=\"keyword\">function</span> (resolve, reject) &#123;</span><br><span class=\"line\">            handle(&#123;</span><br><span class=\"line\">                onFulfilled,</span><br><span class=\"line\">                resolve,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS：状态切换就不说了，很显然。</p>\n<p>then函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    GET(url, <span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">        resolve(data1)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">\tconst toChainPoromise = new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    \tPOST(url, <span class=\"keyword\">function</span>(data2)&#123;</span><br><span class=\"line\">             resolve(data1+data2)</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> toChainPoromise;</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data)&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>把之前手写过的promise在梳理一遍</p>\n</blockquote>","more":"<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var PENDING = 0;</span><br><span class=\"line\">var FULFILLED = 1;</span><br><span class=\"line\">var REJECTED = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> myPromise(fn) &#123;</span><br><span class=\"line\">    var state = PENDING;</span><br><span class=\"line\">    var value = null;</span><br><span class=\"line\">    var handlers = [];</span><br><span class=\"line\">    var e =null;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> resolve(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val instanceof myPromise) &#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                val.then(resolve);</span><br><span class=\"line\">            &#125;catch(e)&#123;</span><br><span class=\"line\">                reject(e)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = FULFILLED;</span><br><span class=\"line\">        value = val;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            handlers.map(<span class=\"keyword\">function</span> (handler) &#123;</span><br><span class=\"line\">                handle(handler)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> reject(err) &#123;</span><br><span class=\"line\">        state = REJECTED;</span><br><span class=\"line\">        e = err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> handle(handler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">            handlers.push(handler);</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">let</span> ret = handler.onFulfilled(value);</span><br><span class=\"line\">                handler.resolve(ret);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;catch(e)&#123;</span><br><span class=\"line\">            reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略</span><br><span class=\"line\">    this.then = <span class=\"keyword\">function</span> (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new myPromise(<span class=\"keyword\">function</span> (resolve, reject) &#123;</span><br><span class=\"line\">            handle(&#123;</span><br><span class=\"line\">                onFulfilled,</span><br><span class=\"line\">                resolve,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS：状态切换就不说了，很显然。</p>\n<p>then函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    GET(url, <span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">        resolve(data1)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">\tconst toChainPoromise = new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    \tPOST(url, <span class=\"keyword\">function</span>(data2)&#123;</span><br><span class=\"line\">             resolve(data1+data2)</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> toChainPoromise;</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data)&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。</p>"},{"title":"这个this啊","date":"2018-03-07T03:56:13.000Z","_content":">当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。\n\n<!--more-->\n### 默认绑定\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a)\n}\nA();  //2\n```\n上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。\n像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。\n### 隐式绑定\n话不多说，先上代码\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nobj.A();  //3\n```\n在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，_隐式绑定规则_将this绑定到了obj上，所以this.a就是obj.a。\n接下来稍微改一下代码：\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nfunction B(fn){\n  fn()\n}\nvar obj = {\n  a:3,\n  A:A\n}\nB(obj.A);   //2\n```\n在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在_fn()_，此时的fn是没有函数修饰的，上述代码相当于\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nvar C=obj.A;  //敲重点\nC();    //2\n\n```\n其实参数传递相当于_隐式赋值_，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为_隐式丢失_。\n最近在刷题时，有看到这么几段代码：\n```bash\nvar a = 1;\nsetTimeout(function(){\n  var a = 2;\n  console.log(this.a);\n},1000);\n//otherthing\n```\n当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。\n由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，\n```bash\n//Action为第三方封装的函数\nAction(function(){\n  //....\n  console.log(this);//这一行是自己意淫的\n},selector);\n\n```\n这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：\n```bash\nfunction Action(callback , arg){\n    //...\n    callback()\n}\n```\n无可厚非，this绑定的是全局对象，但是如果：\n\n```bash\nfunction Action(callback , selector){\n    //...\n    var dom  = document.queryselector(selector);\n    dom.callback();\n}\n```\n那么此时的this无疑就是dom。\n后来逛掘金时，又看到这段代码：\n```bash\nvar a = 1;\n\nvar obj = {\n  a: 2,\n  B: function(){\n    var a = 3;\n    (function(){\n      var a = 4；\n      console.log(this.a);\n    }\n    )();\n  }\n}\n\nobj.B();\n\n```\n在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时_默认绑定规则_(我好像该写在上一个篇幅，嘤嘤嘤（'qAq'）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。\n\n### 显式绑定\n\n#### 硬绑定\n在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。\n+ apply\n\n此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。\n```bash\nvar n = 2;\nvar obj = {\n  n:1\n}\nfunction getN(){\n  console.log(this.n);\n}\ngetN.apply(obj);\n```\n+ call\n\n\n此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply\n一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如\nfun.call(obj,arg1,arg2,arg3...)\n\n+ bind\n\n\n此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。\n方法比较简单就不再举例。\n#### new\n\n如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。\n构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值\n```bash\nfunction A(){\n    this.a = 2;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n\n如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果\n\n```bash\nfunction A(){\n    this.a = 2;\n    return;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象\n\n\n```bash\nvar obj = {a:1};\nfunction A(){\n    this.a = 2;\n    return obj;\n}\nvar test = new A();\nconsole.log(test);//{a:1}\n\n```\n尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o\n\n\n```bash\nvar obj = {\n    a: function(){\n        return this;\n    }\n}\nvar o = new obj.a();\nconsole.log(o === obj) //false\nconsole.log(o.constructor === obj.a)  //true\n\n```\n\n### 优先级\n","source":"_posts/js-this.md","raw":"---\ntitle: 这个this啊\ndate: 2018-03-07 11:56:13\ntags: javascript\ncategories: 学习\n---\n>当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。\n\n<!--more-->\n### 默认绑定\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a)\n}\nA();  //2\n```\n上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。\n像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。\n### 隐式绑定\n话不多说，先上代码\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nobj.A();  //3\n```\n在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，_隐式绑定规则_将this绑定到了obj上，所以this.a就是obj.a。\n接下来稍微改一下代码：\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nfunction B(fn){\n  fn()\n}\nvar obj = {\n  a:3,\n  A:A\n}\nB(obj.A);   //2\n```\n在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在_fn()_，此时的fn是没有函数修饰的，上述代码相当于\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nvar C=obj.A;  //敲重点\nC();    //2\n\n```\n其实参数传递相当于_隐式赋值_，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为_隐式丢失_。\n最近在刷题时，有看到这么几段代码：\n```bash\nvar a = 1;\nsetTimeout(function(){\n  var a = 2;\n  console.log(this.a);\n},1000);\n//otherthing\n```\n当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。\n由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，\n```bash\n//Action为第三方封装的函数\nAction(function(){\n  //....\n  console.log(this);//这一行是自己意淫的\n},selector);\n\n```\n这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：\n```bash\nfunction Action(callback , arg){\n    //...\n    callback()\n}\n```\n无可厚非，this绑定的是全局对象，但是如果：\n\n```bash\nfunction Action(callback , selector){\n    //...\n    var dom  = document.queryselector(selector);\n    dom.callback();\n}\n```\n那么此时的this无疑就是dom。\n后来逛掘金时，又看到这段代码：\n```bash\nvar a = 1;\n\nvar obj = {\n  a: 2,\n  B: function(){\n    var a = 3;\n    (function(){\n      var a = 4；\n      console.log(this.a);\n    }\n    )();\n  }\n}\n\nobj.B();\n\n```\n在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时_默认绑定规则_(我好像该写在上一个篇幅，嘤嘤嘤（'qAq'）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。\n\n### 显式绑定\n\n#### 硬绑定\n在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。\n+ apply\n\n此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。\n```bash\nvar n = 2;\nvar obj = {\n  n:1\n}\nfunction getN(){\n  console.log(this.n);\n}\ngetN.apply(obj);\n```\n+ call\n\n\n此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply\n一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如\nfun.call(obj,arg1,arg2,arg3...)\n\n+ bind\n\n\n此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。\n方法比较简单就不再举例。\n#### new\n\n如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。\n构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值\n```bash\nfunction A(){\n    this.a = 2;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n\n如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果\n\n```bash\nfunction A(){\n    this.a = 2;\n    return;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象\n\n\n```bash\nvar obj = {a:1};\nfunction A(){\n    this.a = 2;\n    return obj;\n}\nvar test = new A();\nconsole.log(test);//{a:1}\n\n```\n尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o\n\n\n```bash\nvar obj = {\n    a: function(){\n        return this;\n    }\n}\nvar o = new obj.a();\nconsole.log(o === obj) //false\nconsole.log(o.constructor === obj.a)  //true\n\n```\n\n### 优先级\n","slug":"js-this","published":1,"updated":"2019-09-17T02:42:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv7x000ekwfy06qshqjq","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();  //2</span><br></pre></td></tr></table></figure>\n<p>上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。<br>像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。</p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>话不多说，先上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.A();  //3</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，<em>隐式绑定规则</em>将this绑定到了obj上，所以this.a就是obj.a。<br>接下来稍微改一下代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> B(fn)&#123;</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B(obj.A);   //2</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在<em>fn()</em>，此时的fn是没有函数修饰的，上述代码相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var C=obj.A;  //敲重点</span><br><span class=\"line\">C();    //2</span><br></pre></td></tr></table></figure></p>\n<p>其实参数传递相当于<em>隐式赋值</em>，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为<em>隐式丢失</em>。<br>最近在刷题时，有看到这么几段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;,1000);</span><br><span class=\"line\">//otherthing</span><br></pre></td></tr></table></figure></p>\n<p>当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。<br>由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Action为第三方封装的函数</span><br><span class=\"line\">Action(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  //....</span><br><span class=\"line\">  console.log(this);//这一行是自己意淫的</span><br><span class=\"line\">&#125;,selector);</span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , arg)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>无可厚非，this绑定的是全局对象，但是如果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , selector)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    var dom  = document.queryselector(selector);</span><br><span class=\"line\">    dom.callback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么此时的this无疑就是dom。<br>后来逛掘金时，又看到这段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 2,</span><br><span class=\"line\">  B: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">      var a = 4；</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    )();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.B();</span><br></pre></td></tr></table></figure></p>\n<p>在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时<em>默认绑定规则</em>(我好像该写在上一个篇幅，嘤嘤嘤（’qAq’）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。</p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><h4 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h4><p>在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。</p>\n<ul>\n<li>apply</li>\n</ul>\n<p>此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var n = 2;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  n:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getN</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getN.apply(obj);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>call</li>\n</ul>\n<p>此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply<br>一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如<br>fun.call(obj,arg1,arg2,arg3…)</p>\n<ul>\n<li>bind</li>\n</ul>\n<p>此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。<br>方法比较简单就不再举例。</p>\n<h4 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h4><p>如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。<br>构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure>\n<p>如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a:1&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:1&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o = new obj.a();</span><br><span class=\"line\">console.log(o === obj) //<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(o.constructor === obj.a)  //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3>","site":{"data":{}},"excerpt":"<blockquote>\n<p>当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。</p>\n</blockquote>","more":"<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();  //2</span><br></pre></td></tr></table></figure>\n<p>上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。<br>像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。</p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>话不多说，先上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.A();  //3</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，<em>隐式绑定规则</em>将this绑定到了obj上，所以this.a就是obj.a。<br>接下来稍微改一下代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> B(fn)&#123;</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B(obj.A);   //2</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在<em>fn()</em>，此时的fn是没有函数修饰的，上述代码相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var C=obj.A;  //敲重点</span><br><span class=\"line\">C();    //2</span><br></pre></td></tr></table></figure></p>\n<p>其实参数传递相当于<em>隐式赋值</em>，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为<em>隐式丢失</em>。<br>最近在刷题时，有看到这么几段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;,1000);</span><br><span class=\"line\">//otherthing</span><br></pre></td></tr></table></figure></p>\n<p>当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。<br>由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Action为第三方封装的函数</span><br><span class=\"line\">Action(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  //....</span><br><span class=\"line\">  console.log(this);//这一行是自己意淫的</span><br><span class=\"line\">&#125;,selector);</span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , arg)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>无可厚非，this绑定的是全局对象，但是如果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , selector)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    var dom  = document.queryselector(selector);</span><br><span class=\"line\">    dom.callback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么此时的this无疑就是dom。<br>后来逛掘金时，又看到这段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 2,</span><br><span class=\"line\">  B: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">      var a = 4；</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    )();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.B();</span><br></pre></td></tr></table></figure></p>\n<p>在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时<em>默认绑定规则</em>(我好像该写在上一个篇幅，嘤嘤嘤（’qAq’）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。</p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><h4 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h4><p>在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。</p>\n<ul>\n<li>apply</li>\n</ul>\n<p>此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var n = 2;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  n:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getN</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getN.apply(obj);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>call</li>\n</ul>\n<p>此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply<br>一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如<br>fun.call(obj,arg1,arg2,arg3…)</p>\n<ul>\n<li>bind</li>\n</ul>\n<p>此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。<br>方法比较简单就不再举例。</p>\n<h4 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h4><p>如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。<br>构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure>\n<p>如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a:1&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:1&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o = new obj.a();</span><br><span class=\"line\">console.log(o === obj) //<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(o.constructor === obj.a)  //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3>"},{"title":"react的setState","date":"2019-01-04T10:04:57.000Z","_content":"\n> 记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。\n\n<!--more-->\n\n### 目的\n\n看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？\n\n### setState关键点\n\n+ setState不会立刻改变React组件中state的值\n+ 多次setState函数调用产生的效果会合并。\n+ setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：\n    - shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）\n    - componentWillUpdate（被调用时this.state没有更新）\n    - render（被调用时this.state得到更新）\n    - componentDidUpdate\n\n首先举个🌰，修改了《深入react技术栈》中的代码：\n\n```bash  \nclass App extends Component {\n  state = {\n    num:0\n  };\n  componentDidMount(){\n    this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n     this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n\n     setTimeout(() => {\n      this.setState({ \n        num:this.state.num+1\n       })\n       console.log('timeout', this.state.num);\n        this.setState({ \n          num:this.state.num+1\n         })\n         console.log('timeout', this.state.num);\n        })\n  }\n\n  componentDidUpdate(){\n    // console.log('update',this.state.num);\n\n  }\n  render() {\n    console.log('rendering', this.state.num)\n    return (\n      <div className=\"App\">\n        <p>{this.state.num}</p>\n      </div>\n    );\n  }\n}\n```\n\n输出是这样的\n\n```bash  \nrendering 0\n0\n0\nrendering 1\nrendering 2\ntimeout 2\nrendering 3\ntimeout 3\n```\n\n看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。\n\n```function enqueueUpdate(component) {  // ...  if (!batchingStrategy.isBatchingUpdates) {    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  }  dirtyComponents.push(component);}\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n```\n\nreact在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。\n\n<strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。\n\n### setState另一个用法\n\nsetState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。\n\n### 渲染\n\nseState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。\n\n\n\n\n\n","source":"_posts/react-react的setState.md","raw":"---\ntitle: react的setState\ndate: 2019-01-04 18:04:57\ntags: react\n---\n\n> 记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。\n\n<!--more-->\n\n### 目的\n\n看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？\n\n### setState关键点\n\n+ setState不会立刻改变React组件中state的值\n+ 多次setState函数调用产生的效果会合并。\n+ setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：\n    - shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）\n    - componentWillUpdate（被调用时this.state没有更新）\n    - render（被调用时this.state得到更新）\n    - componentDidUpdate\n\n首先举个🌰，修改了《深入react技术栈》中的代码：\n\n```bash  \nclass App extends Component {\n  state = {\n    num:0\n  };\n  componentDidMount(){\n    this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n     this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n\n     setTimeout(() => {\n      this.setState({ \n        num:this.state.num+1\n       })\n       console.log('timeout', this.state.num);\n        this.setState({ \n          num:this.state.num+1\n         })\n         console.log('timeout', this.state.num);\n        })\n  }\n\n  componentDidUpdate(){\n    // console.log('update',this.state.num);\n\n  }\n  render() {\n    console.log('rendering', this.state.num)\n    return (\n      <div className=\"App\">\n        <p>{this.state.num}</p>\n      </div>\n    );\n  }\n}\n```\n\n输出是这样的\n\n```bash  \nrendering 0\n0\n0\nrendering 1\nrendering 2\ntimeout 2\nrendering 3\ntimeout 3\n```\n\n看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。\n\n```function enqueueUpdate(component) {  // ...  if (!batchingStrategy.isBatchingUpdates) {    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  }  dirtyComponents.push(component);}\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n```\n\nreact在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。\n\n<strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。\n\n### setState另一个用法\n\nsetState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。\n\n### 渲染\n\nseState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。\n\n\n\n\n\n","slug":"react-react的setState","published":1,"updated":"2019-09-17T02:42:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv81000jkwfy6oz6y23j","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？</p>\n<h3 id=\"setState关键点\"><a href=\"#setState关键点\" class=\"headerlink\" title=\"setState关键点\"></a>setState关键点</h3><ul>\n<li>setState不会立刻改变React组件中state的值</li>\n<li>多次setState函数调用产生的效果会合并。</li>\n<li>setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：<ul>\n<li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li>\n<li>componentWillUpdate（被调用时this.state没有更新）</li>\n<li>render（被调用时this.state得到更新）</li>\n<li>componentDidUpdate</li>\n</ul>\n</li>\n</ul>\n<p>首先举个🌰，修改了《深入react技术栈》中的代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    num:0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span></span>()&#123;</span><br><span class=\"line\">    this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\">     this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">     setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123; </span><br><span class=\"line\">        num:this.state.num+1</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">       console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        this.setState(&#123; </span><br><span class=\"line\">          num:this.state.num+1</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">         console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span></span>()&#123;</span><br><span class=\"line\">    // console.log(<span class=\"string\">'update'</span>,this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span></span>() &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'rendering'</span>, this.state.num)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出是这样的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rendering 0</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">rendering 1</span><br><span class=\"line\">rendering 2</span><br><span class=\"line\">timeout 2</span><br><span class=\"line\">rendering 3</span><br><span class=\"line\">timeout 3</span><br></pre></td></tr></table></figure>\n<p>看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。</p>\n<figure class=\"highlight plain\"><figcaption><span>enqueueUpdate(component) &#123;</span><a href=\"//\">...  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  dirtyComponents.push(component);&#125;</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function enqueueUpdate(component) &#123;</span><br><span class=\"line\">  ensureInjected();</span><br><span class=\"line\"></span><br><span class=\"line\">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class=\"line\">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class=\"line\">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class=\"line\">  // function, like setProps, setState, forceUpdate, etc.; creation and</span><br><span class=\"line\">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class=\"line\"></span><br><span class=\"line\">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dirtyComponents.push(component);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>react在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。</p>\n<p><strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。</p>\n<h3 id=\"setState另一个用法\"><a href=\"#setState另一个用法\" class=\"headerlink\" title=\"setState另一个用法\"></a>setState另一个用法</h3><p>setState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。</p>\n<h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><p>seState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。</p>\n</blockquote>","more":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？</p>\n<h3 id=\"setState关键点\"><a href=\"#setState关键点\" class=\"headerlink\" title=\"setState关键点\"></a>setState关键点</h3><ul>\n<li>setState不会立刻改变React组件中state的值</li>\n<li>多次setState函数调用产生的效果会合并。</li>\n<li>setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：<ul>\n<li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li>\n<li>componentWillUpdate（被调用时this.state没有更新）</li>\n<li>render（被调用时this.state得到更新）</li>\n<li>componentDidUpdate</li>\n</ul>\n</li>\n</ul>\n<p>首先举个🌰，修改了《深入react技术栈》中的代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    num:0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span></span>()&#123;</span><br><span class=\"line\">    this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\">     this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">     setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123; </span><br><span class=\"line\">        num:this.state.num+1</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">       console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        this.setState(&#123; </span><br><span class=\"line\">          num:this.state.num+1</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">         console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span></span>()&#123;</span><br><span class=\"line\">    // console.log(<span class=\"string\">'update'</span>,this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span></span>() &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'rendering'</span>, this.state.num)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出是这样的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rendering 0</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">rendering 1</span><br><span class=\"line\">rendering 2</span><br><span class=\"line\">timeout 2</span><br><span class=\"line\">rendering 3</span><br><span class=\"line\">timeout 3</span><br></pre></td></tr></table></figure>\n<p>看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。</p>\n<figure class=\"highlight plain\"><figcaption><span>enqueueUpdate(component) &#123;</span><a href=\"//\">...  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  dirtyComponents.push(component);&#125;</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function enqueueUpdate(component) &#123;</span><br><span class=\"line\">  ensureInjected();</span><br><span class=\"line\"></span><br><span class=\"line\">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class=\"line\">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class=\"line\">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class=\"line\">  // function, like setProps, setState, forceUpdate, etc.; creation and</span><br><span class=\"line\">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class=\"line\"></span><br><span class=\"line\">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dirtyComponents.push(component);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>react在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。</p>\n<p><strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。</p>\n<h3 id=\"setState另一个用法\"><a href=\"#setState另一个用法\" class=\"headerlink\" title=\"setState另一个用法\"></a>setState另一个用法</h3><p>setState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。</p>\n<h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><p>seState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。</p>"},{"title":"choppingHand1","date":"2018-06-08T04:38:50.000Z","_content":"\n>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。\n\n<!--more-->\n\n今天\n\n写了几个界面，登录注册啥的。界面如下：\n<br>\n注册界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png)\n<br>\n登录界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png)\n<br>\n首页\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png)\n\n顺手把页面逻辑跳转写了\n\n```bash\nconst Tab = TabNavigator({\n        Home: {\n            screen: HomeView,\n            navigationOptions: {\n                tabBarLabel: '首页',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/homeSelect.png')}\n                        normalImage={require('./images/home.png')}\n                    />\n                )\n            }\n        },\n        Cart: {\n            screen: CartView,\n            navigationOptions: {\n                tabBarLabel: '购物车',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/cartSelect.png')}\n                        normalImage={require('./images/cart.png')}\n                    />\n                )\n            }\n        },\n        Mine: {\n            screen: MineView,\n            navigationOptions: {\n                tabBarLabel: '我',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/mineSelect.png')}\n                        normalImage={require('./images/mine.png')}\n                    />\n                )\n            }\n        }\n    },\n    // tabScreen配置\n    {\n        tabBarComponent: TabBarBottom, // 自定义\n        tabBarPosition: 'bottom',\n        swipeEnabled: false,\n        animationEnabled: true,\n        lazy: true,\n        tabBarOptions: {\n            activeTintColor: '#e5779c',\n            inactiveTintColor: '#71777c',\n            labelStyle: {\n                fontSize: 12, // 文字大小\n            }\n        }\n\n    }\n);\n\nconst Stack =StackNavigator(\n    {\n        Login: {\n            screen: LoginView,\n            navigationOptions: {\n                header: null\n            }\n        },\n        Tab: {\n            screen: Tab,\n        },\n        GoodPage:{\n            screen: GoodPageView,\n        },\n        Register: {\n            screen: RegisterView,\n            navigationOptions: {\n                header: null\n            }\n        },\n\n\n    }, {\n        navigationOptions: {\n            // 开启动画\n            animationEnabled: true,\n            // 开启边缘触摸返回\n            gesturesEnabled: true\n        },\n        mode: 'card'\n    })\n\n```\n刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。\n","source":"_posts/rn-choppingHand1.md","raw":"---\ntitle: choppingHand1\ndate: 2018-06-8 12:38:50\ntags: React Native\ncategories: 学习\n---\n\n>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。\n\n<!--more-->\n\n今天\n\n写了几个界面，登录注册啥的。界面如下：\n<br>\n注册界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png)\n<br>\n登录界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png)\n<br>\n首页\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png)\n\n顺手把页面逻辑跳转写了\n\n```bash\nconst Tab = TabNavigator({\n        Home: {\n            screen: HomeView,\n            navigationOptions: {\n                tabBarLabel: '首页',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/homeSelect.png')}\n                        normalImage={require('./images/home.png')}\n                    />\n                )\n            }\n        },\n        Cart: {\n            screen: CartView,\n            navigationOptions: {\n                tabBarLabel: '购物车',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/cartSelect.png')}\n                        normalImage={require('./images/cart.png')}\n                    />\n                )\n            }\n        },\n        Mine: {\n            screen: MineView,\n            navigationOptions: {\n                tabBarLabel: '我',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/mineSelect.png')}\n                        normalImage={require('./images/mine.png')}\n                    />\n                )\n            }\n        }\n    },\n    // tabScreen配置\n    {\n        tabBarComponent: TabBarBottom, // 自定义\n        tabBarPosition: 'bottom',\n        swipeEnabled: false,\n        animationEnabled: true,\n        lazy: true,\n        tabBarOptions: {\n            activeTintColor: '#e5779c',\n            inactiveTintColor: '#71777c',\n            labelStyle: {\n                fontSize: 12, // 文字大小\n            }\n        }\n\n    }\n);\n\nconst Stack =StackNavigator(\n    {\n        Login: {\n            screen: LoginView,\n            navigationOptions: {\n                header: null\n            }\n        },\n        Tab: {\n            screen: Tab,\n        },\n        GoodPage:{\n            screen: GoodPageView,\n        },\n        Register: {\n            screen: RegisterView,\n            navigationOptions: {\n                header: null\n            }\n        },\n\n\n    }, {\n        navigationOptions: {\n            // 开启动画\n            animationEnabled: true,\n            // 开启边缘触摸返回\n            gesturesEnabled: true\n        },\n        mode: 'card'\n    })\n\n```\n刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。\n","slug":"rn-choppingHand1","published":1,"updated":"2019-09-17T02:39:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv85000mkwfy9xtm2ltt","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>今天</p>\n<p>写了几个界面，登录注册啥的。界面如下：<br><br><br>注册界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png\" alt><br><br><br>登录界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png\" alt><br><br><br>首页<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png\" alt></p>\n<p>顺手把页面逻辑跳转写了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Tab = TabNavigator(&#123;</span><br><span class=\"line\">        Home: &#123;</span><br><span class=\"line\">            screen: HomeView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/homeSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/home.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Cart: &#123;</span><br><span class=\"line\">            screen: CartView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'购物车'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/cartSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/cart.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Mine: &#123;</span><br><span class=\"line\">            screen: MineView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'我'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/mineSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/mine.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // tabScreen配置</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tabBarComponent: TabBarBottom, // 自定义</span><br><span class=\"line\">        tabBarPosition: <span class=\"string\">'bottom'</span>,</span><br><span class=\"line\">        swipeEnabled: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        lazy: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        tabBarOptions: &#123;</span><br><span class=\"line\">            activeTintColor: <span class=\"string\">'#e5779c'</span>,</span><br><span class=\"line\">            inactiveTintColor: <span class=\"string\">'#71777c'</span>,</span><br><span class=\"line\">            labelStyle: &#123;</span><br><span class=\"line\">                fontSize: 12, // 文字大小</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">const Stack =StackNavigator(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Login: &#123;</span><br><span class=\"line\">            screen: LoginView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Tab: &#123;</span><br><span class=\"line\">            screen: Tab,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        GoodPage:&#123;</span><br><span class=\"line\">            screen: GoodPageView,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Register: &#123;</span><br><span class=\"line\">            screen: RegisterView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        navigationOptions: &#123;</span><br><span class=\"line\">            // 开启动画</span><br><span class=\"line\">            animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            // 开启边缘触摸返回</span><br><span class=\"line\">            gesturesEnabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        mode: <span class=\"string\">'card'</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。</p>\n</blockquote>","more":"<p>今天</p>\n<p>写了几个界面，登录注册啥的。界面如下：<br><br><br>注册界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png\" alt><br><br><br>登录界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png\" alt><br><br><br>首页<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png\" alt></p>\n<p>顺手把页面逻辑跳转写了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Tab = TabNavigator(&#123;</span><br><span class=\"line\">        Home: &#123;</span><br><span class=\"line\">            screen: HomeView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/homeSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/home.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Cart: &#123;</span><br><span class=\"line\">            screen: CartView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'购物车'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/cartSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/cart.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Mine: &#123;</span><br><span class=\"line\">            screen: MineView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'我'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/mineSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/mine.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // tabScreen配置</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tabBarComponent: TabBarBottom, // 自定义</span><br><span class=\"line\">        tabBarPosition: <span class=\"string\">'bottom'</span>,</span><br><span class=\"line\">        swipeEnabled: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        lazy: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        tabBarOptions: &#123;</span><br><span class=\"line\">            activeTintColor: <span class=\"string\">'#e5779c'</span>,</span><br><span class=\"line\">            inactiveTintColor: <span class=\"string\">'#71777c'</span>,</span><br><span class=\"line\">            labelStyle: &#123;</span><br><span class=\"line\">                fontSize: 12, // 文字大小</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">const Stack =StackNavigator(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Login: &#123;</span><br><span class=\"line\">            screen: LoginView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Tab: &#123;</span><br><span class=\"line\">            screen: Tab,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        GoodPage:&#123;</span><br><span class=\"line\">            screen: GoodPageView,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Register: &#123;</span><br><span class=\"line\">            screen: RegisterView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        navigationOptions: &#123;</span><br><span class=\"line\">            // 开启动画</span><br><span class=\"line\">            animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            // 开启边缘触摸返回</span><br><span class=\"line\">            gesturesEnabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        mode: <span class=\"string\">'card'</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。</p>"},{"title":"choppingHand2","date":"2018-06-15T05:07:12.000Z","_content":"\n这段时间把剩下的界面写完了，界面如下：\n<!--more-->\n<br>\n商品详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png)\n<br>\n购物车\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png)\n<br>\n收藏\n<br>\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png)\n<br>\n个人详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png)\n<br>\n订单界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png)\n\n期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来\nreact-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,\n\n```bash\n    constructor(props) {\n        super(props);\n        this.state = {\n            swipeShow: false,\n            store:[]\n        };\n        this.txt = null\n    }\n\n    componentWillMount() {\n        setTimeout(() => {\n            this.setState({\n                swipeShow: true,\n            })\n        })\n    }\n\n    renderSwiper() {\n        return (\n            <Swiper style={styles.swiper} autoplay={true} showsButtons>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide1.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide2.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide3.jpg')}/>\n                </View>\n            </Swiper>\n        )\n    }\n//...\n              <View style={{width: width, height: 150,}}>\n                  {this.state.swipeShow && this.renderSwiper()}\n                </View>\n\n```\n同理react-native-scrollable-tab-view也是同样的解决方案。\n","source":"_posts/rn-choppingHand2.md","raw":"---\ntitle: choppingHand2\ndate: 2018-06-15 13:07:12\ntags: React Native\ncategories: 学习\n---\n\n这段时间把剩下的界面写完了，界面如下：\n<!--more-->\n<br>\n商品详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png)\n<br>\n购物车\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png)\n<br>\n收藏\n<br>\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png)\n<br>\n个人详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png)\n<br>\n订单界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png)\n\n期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来\nreact-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,\n\n```bash\n    constructor(props) {\n        super(props);\n        this.state = {\n            swipeShow: false,\n            store:[]\n        };\n        this.txt = null\n    }\n\n    componentWillMount() {\n        setTimeout(() => {\n            this.setState({\n                swipeShow: true,\n            })\n        })\n    }\n\n    renderSwiper() {\n        return (\n            <Swiper style={styles.swiper} autoplay={true} showsButtons>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide1.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide2.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide3.jpg')}/>\n                </View>\n            </Swiper>\n        )\n    }\n//...\n              <View style={{width: width, height: 150,}}>\n                  {this.state.swipeShow && this.renderSwiper()}\n                </View>\n\n```\n同理react-native-scrollable-tab-view也是同样的解决方案。\n","slug":"rn-choppingHand2","published":1,"updated":"2019-09-17T02:39:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8b000qkwfyjnsepwuw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>这段时间把剩下的界面写完了，界面如下：<br><a id=\"more\"></a><br><br><br>商品详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png\" alt><br><br><br>购物车<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png\" alt><br><br><br>收藏<br><br></p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png\" alt><br><br><br>个人详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png\" alt><br><br><br>订单界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png\" alt></p>\n<p>期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来<br>react-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            swipeShow: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            store:[]</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        this.txt = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentWillMount</span></span>() &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            this.setState(&#123;</span><br><span class=\"line\">                swipeShow: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">renderSwiper</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> (</span><br><span class=\"line\">            &lt;Swiper style=&#123;styles.swiper&#125; autoplay=&#123;<span class=\"literal\">true</span>&#125; showsButtons&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide1.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide2.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide3.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">            &lt;/Swiper&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//...</span><br><span class=\"line\">              &lt;View style=&#123;&#123;width: width, height: 150,&#125;&#125;&gt;</span><br><span class=\"line\">                  &#123;this.state.swipeShow &amp;&amp; this.renderSwiper()&#125;</span><br><span class=\"line\">                &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p>同理react-native-scrollable-tab-view也是同样的解决方案。</p>\n","site":{"data":{}},"excerpt":"<p>这段时间把剩下的界面写完了，界面如下：<br>","more":"<br><br><br>商品详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png\" alt><br><br><br>购物车<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png\" alt><br><br><br>收藏<br><br></p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png\" alt><br><br><br>个人详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png\" alt><br><br><br>订单界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png\" alt></p>\n<p>期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来<br>react-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            swipeShow: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            store:[]</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        this.txt = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentWillMount</span></span>() &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            this.setState(&#123;</span><br><span class=\"line\">                swipeShow: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">renderSwiper</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> (</span><br><span class=\"line\">            &lt;Swiper style=&#123;styles.swiper&#125; autoplay=&#123;<span class=\"literal\">true</span>&#125; showsButtons&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide1.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide2.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide3.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">            &lt;/Swiper&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//...</span><br><span class=\"line\">              &lt;View style=&#123;&#123;width: width, height: 150,&#125;&#125;&gt;</span><br><span class=\"line\">                  &#123;this.state.swipeShow &amp;&amp; this.renderSwiper()&#125;</span><br><span class=\"line\">                &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p>同理react-native-scrollable-tab-view也是同样的解决方案。</p>"},{"title":"Vue学习笔记之啦啦啦","date":"2018-01-05T15:54:06.000Z","_content":"\n\n\n>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue\n>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码\n>再敲一遍，特此记录。\n\n  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br>\n\n<!--more-->\n\n\n\n\n## 生命周期\n\n每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br>\nVue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:\n  > + created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。\n  > + mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。\n  > + beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。\n\n<em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em>\n\n## 计算属性\n计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。\n\n## 一些新学到的指令\n+ v-cloak\n\n\n>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。\n\n\n```bash\n<div id=\"app\" v-cloak>\n  {{message}}\n</div>\n<script>\n  var app = new Vue({\n  el:'#app',\n  data:{\n  message:'这是一段文本'\n}\n})\n</script>\n```\n\n当网速较慢时，Vue.js还没加载完，页面上会出现{{message}}的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。\n\n```bash\n[v-cloak]{\n  display:none;\n}\n```\n\n就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。\n\n+ v-once\n\n>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。\n\n+ v-if,v-else-if,v-else\n\n\n>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            type:'name',\n            status:2\n        },\n        methods:{\n            handleToggleClick:function(){\n                this.type = this.type ==='name'?'mail':'name';\n            }\n        }\n    })\n</script>\n```\n\n点击切换按钮，虽然DOM元素改变了，但是之前在输入\n框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png)\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png)\n\n如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n```\n\n+ v-show\n\n>v-show是通过改变元素的display为none，来隐藏元素的。\n <strong>\nv-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v\n-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em>\n </strong>\n\n+ v-for\n\n\n> 关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br>\n\n\nPS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。\n","source":"_posts/vue-VueInAction1.md","raw":"---\ntitle: Vue学习笔记之啦啦啦\ndate: 2018-01-05 23:54:06\ntags: vue\ncategories: 学习\n---\n\n\n\n>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue\n>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码\n>再敲一遍，特此记录。\n\n  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br>\n\n<!--more-->\n\n\n\n\n## 生命周期\n\n每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br>\nVue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:\n  > + created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。\n  > + mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。\n  > + beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。\n\n<em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em>\n\n## 计算属性\n计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。\n\n## 一些新学到的指令\n+ v-cloak\n\n\n>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。\n\n\n```bash\n<div id=\"app\" v-cloak>\n  {{message}}\n</div>\n<script>\n  var app = new Vue({\n  el:'#app',\n  data:{\n  message:'这是一段文本'\n}\n})\n</script>\n```\n\n当网速较慢时，Vue.js还没加载完，页面上会出现{{message}}的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。\n\n```bash\n[v-cloak]{\n  display:none;\n}\n```\n\n就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。\n\n+ v-once\n\n>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。\n\n+ v-if,v-else-if,v-else\n\n\n>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            type:'name',\n            status:2\n        },\n        methods:{\n            handleToggleClick:function(){\n                this.type = this.type ==='name'?'mail':'name';\n            }\n        }\n    })\n</script>\n```\n\n点击切换按钮，虽然DOM元素改变了，但是之前在输入\n框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png)\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png)\n\n如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n```\n\n+ v-show\n\n>v-show是通过改变元素的display为none，来隐藏元素的。\n <strong>\nv-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v\n-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em>\n </strong>\n\n+ v-for\n\n\n> 关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br>\n\n\nPS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。\n","slug":"vue-VueInAction1","published":1,"updated":"2019-09-17T02:43:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8e000tkwfyx35q7bh8","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue<br>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码<br>再敲一遍，特此记录。</p>\n</blockquote>\n<p>  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br></p>\n<a id=\"more\"></a>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br><br>Vue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:</p>\n<blockquote>\n<ul>\n<li>created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。</li>\n<li>mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。</li>\n<li>beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。</li>\n</ul>\n</blockquote>\n<p><em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em></em></em></p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。</p>\n<h2 id=\"一些新学到的指令\"><a href=\"#一些新学到的指令\" class=\"headerlink\" title=\"一些新学到的指令\"></a>一些新学到的指令</h2><ul>\n<li>v-cloak</li>\n</ul>\n<blockquote>\n<p>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> v-cloak&gt;</span><br><span class=\"line\">  &#123;&#123;message&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var app = new Vue(&#123;</span><br><span class=\"line\">  el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">  message:<span class=\"string\">'这是一段文本'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当网速较慢时，Vue.js还没加载完，页面上会出现的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[v-cloak]&#123;</span><br><span class=\"line\">  display:none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。</p>\n<ul>\n<li>v-once</li>\n</ul>\n<blockquote>\n<p>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。</p>\n</blockquote>\n<ul>\n<li>v-if,v-else-if,v-else</li>\n</ul>\n<blockquote>\n<p>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            <span class=\"built_in\">type</span>:<span class=\"string\">'name'</span>,</span><br><span class=\"line\">            status:2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods:&#123;</span><br><span class=\"line\">            handleToggleClick:<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                this.type = this.type ===<span class=\"string\">'name'</span>?<span class=\"string\">'mail'</span>:<span class=\"string\">'name'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>点击切换按钮，虽然DOM元素改变了，但是之前在输入<br>框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png\" alt><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png\" alt></p>\n<p>如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>v-show</li>\n</ul>\n<blockquote>\n<p>v-show是通过改变元素的display为none，来隐藏元素的。<br> <strong><br>v-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v<br>-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em><br> </strong></p>\n</blockquote>\n<ul>\n<li>v-for</li>\n</ul>\n<blockquote>\n<p>关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br></p>\n</blockquote>\n<p>PS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue<br>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码<br>再敲一遍，特此记录。</p>\n</blockquote>\n<p>  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br></p>","more":"<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br><br>Vue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:</p>\n<blockquote>\n<ul>\n<li>created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。</li>\n<li>mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。</li>\n<li>beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。</li>\n</ul>\n</blockquote>\n<p><em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em></em></em></p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。</p>\n<h2 id=\"一些新学到的指令\"><a href=\"#一些新学到的指令\" class=\"headerlink\" title=\"一些新学到的指令\"></a>一些新学到的指令</h2><ul>\n<li>v-cloak</li>\n</ul>\n<blockquote>\n<p>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> v-cloak&gt;</span><br><span class=\"line\">  &#123;&#123;message&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var app = new Vue(&#123;</span><br><span class=\"line\">  el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">  message:<span class=\"string\">'这是一段文本'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当网速较慢时，Vue.js还没加载完，页面上会出现的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[v-cloak]&#123;</span><br><span class=\"line\">  display:none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。</p>\n<ul>\n<li>v-once</li>\n</ul>\n<blockquote>\n<p>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。</p>\n</blockquote>\n<ul>\n<li>v-if,v-else-if,v-else</li>\n</ul>\n<blockquote>\n<p>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            <span class=\"built_in\">type</span>:<span class=\"string\">'name'</span>,</span><br><span class=\"line\">            status:2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods:&#123;</span><br><span class=\"line\">            handleToggleClick:<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                this.type = this.type ===<span class=\"string\">'name'</span>?<span class=\"string\">'mail'</span>:<span class=\"string\">'name'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>点击切换按钮，虽然DOM元素改变了，但是之前在输入<br>框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png\" alt><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png\" alt></p>\n<p>如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>v-show</li>\n</ul>\n<blockquote>\n<p>v-show是通过改变元素的display为none，来隐藏元素的。<br> <strong><br>v-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v<br>-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em><br> </strong></p>\n</blockquote>\n<ul>\n<li>v-for</li>\n</ul>\n<blockquote>\n<p>关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br></p>\n</blockquote>\n<p>PS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。</p>"},{"title":"VueComponent（一）","date":"2018-01-12T02:50:15.000Z","_content":"\n>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重\n>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有\n>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。\n\n<!--more-->\n### 组件注册的方式\n\n#### 全局注册\n\n用法如下：\n```Bash\n// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)\n// var MyComponent = Vue.extend({\n// 　template : '<p>我是全局注册组件</p>',\n//     data () {\n//          return {\n//               message: 'hello world'\n//             }\n// })\n// vue.componnet('my-component', MyComponnet)\n\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n```\n\n&emsp;&emsp;全局注册后，任何Vue实例都可以使用。\n#### 局部注册\n\n```Bash\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\nnew Vue({\n  el: '#app',\n  componnets: {\n    child: 'child'\n  }\n})\n```\n\n&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。\n\n### 要求\n\n#### 关于模板\ntemplate的DOM结构必须被一个元素包含。下面的情况是不允许的。\n```bash\ntemplate: `<div>这是一个局部的自定义组件，只能在当前Vue实例中使用</div>\n            <button>hello</button>`,\n```\n#### 组件中的data\n\n可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br>\nJS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br>\n```bash\n<div id=\"app\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 };\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data;\n  }\n});\nnew Vue({\n  el: '#app'\n});\n</script>\n```\n\n\n由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：\n\n```bash\ndata: function () {\n  return {\n    counter: 0\n  }\n}\n```\n\n#### html限制\n\nVue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，\n\n```bash\n<div id=\"app\">\n  <table>\n      <tbody is = \"my-component\"></tbody>\n  </table>\n\n</div>\n```\n```bash\nVue.component('simple-counter', {\n  template: '<div>这里是组件的内容</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n\n```\nt-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br>\n应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：\n\n  + JavaScript 内联模版字符串\n  + .vue 组件\n  + x-template\n\n\n其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。\n\n### Props\n\n在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：\n + 字符串数组\n + 对象\n\n代码如下：\n```bash\nVue.component('mycomponent',{\n    template: '<div>这是一个自定义组件,父组件传给我的内容是：{{myMessage}}</div>',\n    props: ['myMessage'],\n    data () {\n      return {\n        message: 'hello world'\n      }\n    }\n  })\n```\n然后调用该组件\n\n```bash\n<div id=\"app\">\n    <mycomponent my-message=\"hello\"></mycomponent>\n</div>\n```\n由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=\"hello\"。\n<br>\n有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：\n```bash\n<div id=\"app\">\n  <input type=\"text\" v-moddel=\"parentMessage\">\n  <my-component :message=\"parentMessage\"></my-componnet>\n</div>\n<script>\nVue.component('my-componentr', {\n  template: '<div>{{message}}</div>',\n  props:['message']\n});\nnew Vue({\n  el: '#app',\n  data:{\n    parentMessage:''\n  }\n});\n</script>\n```\n这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。\n<br>\n要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。\n","source":"_posts/vue-VueInAction2.md","raw":"---\ntitle: VueComponent（一）\ndate: 2018-01-12 10:50:15\ntags: vue\ncategories: 学习\n---\n\n>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重\n>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有\n>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。\n\n<!--more-->\n### 组件注册的方式\n\n#### 全局注册\n\n用法如下：\n```Bash\n// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)\n// var MyComponent = Vue.extend({\n// 　template : '<p>我是全局注册组件</p>',\n//     data () {\n//          return {\n//               message: 'hello world'\n//             }\n// })\n// vue.componnet('my-component', MyComponnet)\n\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n```\n\n&emsp;&emsp;全局注册后，任何Vue实例都可以使用。\n#### 局部注册\n\n```Bash\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\nnew Vue({\n  el: '#app',\n  componnets: {\n    child: 'child'\n  }\n})\n```\n\n&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。\n\n### 要求\n\n#### 关于模板\ntemplate的DOM结构必须被一个元素包含。下面的情况是不允许的。\n```bash\ntemplate: `<div>这是一个局部的自定义组件，只能在当前Vue实例中使用</div>\n            <button>hello</button>`,\n```\n#### 组件中的data\n\n可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br>\nJS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br>\n```bash\n<div id=\"app\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 };\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data;\n  }\n});\nnew Vue({\n  el: '#app'\n});\n</script>\n```\n\n\n由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：\n\n```bash\ndata: function () {\n  return {\n    counter: 0\n  }\n}\n```\n\n#### html限制\n\nVue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，\n\n```bash\n<div id=\"app\">\n  <table>\n      <tbody is = \"my-component\"></tbody>\n  </table>\n\n</div>\n```\n```bash\nVue.component('simple-counter', {\n  template: '<div>这里是组件的内容</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n\n```\nt-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br>\n应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：\n\n  + JavaScript 内联模版字符串\n  + .vue 组件\n  + x-template\n\n\n其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。\n\n### Props\n\n在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：\n + 字符串数组\n + 对象\n\n代码如下：\n```bash\nVue.component('mycomponent',{\n    template: '<div>这是一个自定义组件,父组件传给我的内容是：{{myMessage}}</div>',\n    props: ['myMessage'],\n    data () {\n      return {\n        message: 'hello world'\n      }\n    }\n  })\n```\n然后调用该组件\n\n```bash\n<div id=\"app\">\n    <mycomponent my-message=\"hello\"></mycomponent>\n</div>\n```\n由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=\"hello\"。\n<br>\n有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：\n```bash\n<div id=\"app\">\n  <input type=\"text\" v-moddel=\"parentMessage\">\n  <my-component :message=\"parentMessage\"></my-componnet>\n</div>\n<script>\nVue.component('my-componentr', {\n  template: '<div>{{message}}</div>',\n  props:['message']\n});\nnew Vue({\n  el: '#app',\n  data:{\n    parentMessage:''\n  }\n});\n</script>\n```\n这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。\n<br>\n要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。\n","slug":"vue-VueInAction2","published":1,"updated":"2019-09-17T02:43:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8f000wkwfysdwtwy1y","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重<br>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有<br>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"组件注册的方式\"><a href=\"#组件注册的方式\" class=\"headerlink\" title=\"组件注册的方式\"></a>组件注册的方式</h3><h4 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h4><p>用法如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)</span><br><span class=\"line\">// var MyComponent = Vue.extend(&#123;</span><br><span class=\"line\">// 　template : <span class=\"string\">'&lt;p&gt;我是全局注册组件&lt;/p&gt;'</span>,</span><br><span class=\"line\">//     <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">//          <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">//               message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">//             &#125;</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">// vue.componnet(<span class=\"string\">'my-component'</span>, MyComponnet)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;全局注册后，任何Vue实例都可以使用。</p>\n<h4 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Child = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  componnets: &#123;</span><br><span class=\"line\">    child: <span class=\"string\">'child'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><h4 id=\"关于模板\"><a href=\"#关于模板\" class=\"headerlink\" title=\"关于模板\"></a>关于模板</h4><p>template的DOM结构必须被一个元素包含。下面的情况是不允许的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `&lt;div&gt;这是一个局部的自定义组件，只能在当前Vue实例中使用&lt;/div&gt;</span><br><span class=\"line\">            &lt;button&gt;hello&lt;/button&gt;`,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"组件中的data\"><a href=\"#组件中的data\" class=\"headerlink\" title=\"组件中的data\"></a>组件中的data</h4><p>可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br><br>JS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var data = &#123; counter: 0 &#125;;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">    counter: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"html限制\"><a href=\"#html限制\" class=\"headerlink\" title=\"html限制\"></a>html限制</h4><p>Vue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;table&gt;</span><br><span class=\"line\">      &lt;tbody is = <span class=\"string\">\"my-component\"</span>&gt;&lt;/tbody&gt;</span><br><span class=\"line\">  &lt;/table&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;这里是组件的内容&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>t-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br><br>应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：</p>\n<ul>\n<li>JavaScript 内联模版字符串</li>\n<li>.vue 组件</li>\n<li>x-template</li>\n</ul>\n<p>其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。</p>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p>在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：</p>\n<ul>\n<li>字符串数组</li>\n<li>对象</li>\n</ul>\n<p>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycomponent'</span>,&#123;</span><br><span class=\"line\">    template: <span class=\"string\">'&lt;div&gt;这是一个自定义组件,父组件传给我的内容是：&#123;&#123;myMessage&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">    props: [<span class=\"string\">'myMessage'</span>],</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">        message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>然后调用该组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;mycomponent my-message=<span class=\"string\">\"hello\"</span>&gt;&lt;/mycomponent&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=”hello”。<br><br><br>有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-moddel=<span class=\"string\">\"parentMessage\"</span>&gt;</span><br><span class=\"line\">  &lt;my-component :message=<span class=\"string\">\"parentMessage\"</span>&gt;&lt;/my-componnet&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-componentr'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">  props:[<span class=\"string\">'message'</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    parentMessage:<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。<br><br><br>要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重<br>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有<br>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。</p>\n</blockquote>","more":"<h3 id=\"组件注册的方式\"><a href=\"#组件注册的方式\" class=\"headerlink\" title=\"组件注册的方式\"></a>组件注册的方式</h3><h4 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h4><p>用法如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)</span><br><span class=\"line\">// var MyComponent = Vue.extend(&#123;</span><br><span class=\"line\">// 　template : <span class=\"string\">'&lt;p&gt;我是全局注册组件&lt;/p&gt;'</span>,</span><br><span class=\"line\">//     <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">//          <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">//               message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">//             &#125;</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">// vue.componnet(<span class=\"string\">'my-component'</span>, MyComponnet)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;全局注册后，任何Vue实例都可以使用。</p>\n<h4 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Child = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  componnets: &#123;</span><br><span class=\"line\">    child: <span class=\"string\">'child'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><h4 id=\"关于模板\"><a href=\"#关于模板\" class=\"headerlink\" title=\"关于模板\"></a>关于模板</h4><p>template的DOM结构必须被一个元素包含。下面的情况是不允许的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `&lt;div&gt;这是一个局部的自定义组件，只能在当前Vue实例中使用&lt;/div&gt;</span><br><span class=\"line\">            &lt;button&gt;hello&lt;/button&gt;`,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"组件中的data\"><a href=\"#组件中的data\" class=\"headerlink\" title=\"组件中的data\"></a>组件中的data</h4><p>可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br><br>JS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var data = &#123; counter: 0 &#125;;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">    counter: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"html限制\"><a href=\"#html限制\" class=\"headerlink\" title=\"html限制\"></a>html限制</h4><p>Vue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;table&gt;</span><br><span class=\"line\">      &lt;tbody is = <span class=\"string\">\"my-component\"</span>&gt;&lt;/tbody&gt;</span><br><span class=\"line\">  &lt;/table&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;这里是组件的内容&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>t-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br><br>应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：</p>\n<ul>\n<li>JavaScript 内联模版字符串</li>\n<li>.vue 组件</li>\n<li>x-template</li>\n</ul>\n<p>其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。</p>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p>在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：</p>\n<ul>\n<li>字符串数组</li>\n<li>对象</li>\n</ul>\n<p>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycomponent'</span>,&#123;</span><br><span class=\"line\">    template: <span class=\"string\">'&lt;div&gt;这是一个自定义组件,父组件传给我的内容是：&#123;&#123;myMessage&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">    props: [<span class=\"string\">'myMessage'</span>],</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">        message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>然后调用该组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;mycomponent my-message=<span class=\"string\">\"hello\"</span>&gt;&lt;/mycomponent&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=”hello”。<br><br><br>有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-moddel=<span class=\"string\">\"parentMessage\"</span>&gt;</span><br><span class=\"line\">  &lt;my-component :message=<span class=\"string\">\"parentMessage\"</span>&gt;&lt;/my-componnet&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-componentr'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">  props:[<span class=\"string\">'message'</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    parentMessage:<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。<br><br><br>要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。</p>"},{"title":"template","date":"2018-04-18T03:38:08.000Z","_content":"\n>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？\n<!--more-->\n\ncompile编译主要分为parse、optimize与generate三个阶段，最终得到render function。\n\n### parse\n\nparse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。\n形如：\n```bash\n<div :class=\"c\" class=\"demo\" v-if=\"isShow\">\n    <span v-for=\"item in sz\">{{item}}</span>\n</div>\n\n\n\n\n{\n    /* 标签属性的map，记录了标签上属性 */\n    'attrsMap': {\n        ':class': 'c',\n        'class': 'demo',\n        'v-if': 'isShow'\n    },\n    /* 解析得到的:class */\n    'classBinding': 'c',\n    /* 标签属性v-if */\n    'if': 'isShow',\n    /* v-if的条件 */\n    'ifConditions': [\n        'exp': 'isShow'\n    ],\n    /* 标签属性class */\n    'staticClass': 'demo',\n    /* 标签的tag */\n    'tag': 'div',\n    /* 子标签数组 */\n    'children': [\n        {\n            'attrsMap': {\n                'v-for': \"item in sz\"\n            },\n            /* for循环的参数 */\n            'alias': \"item\",\n            /* for循环的对象 */\n            'for': 'sz',\n            /* for循环是否已经被处理的标记位 */\n            'forProcessed': true,\n            'tag': 'span',\n            'children': [\n                {\n                    /* 表达式，_s是一个转字符串的函数 */\n                    'expression': '_s(item)',\n                    'text': '{{item}}'\n                }\n            ]\n        }\n    ]\n}\n```\n### optimize\noptimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是\n来标记静态节点的。\n经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。\n\n\n### generate\n\ngenerate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。\n\n### VNode\n\nrender function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。\n浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，\n\n这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，\n\nVue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。\n\nVue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React\n那样有利用setState合并状态的过程。\n\n### nextTick\n\n其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。\n\n```bash\n//订阅者\nclass Dep{\n    constructor(){\n        //用来存放watcher对象的数组\n        this.subs = [];\n    }\n\n    //在subs中添加一个watcher对象\n    addSub(sub){\n        this.subs.push(sub);\n    }\n    //通知watcher对象更新视图\n    notify(){\n        this.subs.forEach((sub)=>{\n            sub.update();\n        })\n    }\n}\n//观察者\n\nclass watcher{\n    constructor(){\n        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。\n        Dep.target  =this;\n        console.log(this)\n    }\n    //更新视图的方法\n    update(){\n        console.log('view change')\n    }\n}\n\n```\n好吧！  把Vue和之前提到的双向绑定的也贴上吧\n\n```bash\n\nfunction cb() {\n//    简陋的视图更新函数\n    console.log('视图更新了')\n}\n\nfunction defineReactive(obj, key, val) {\n    const dep = new Dep();\n    Object.defineProperty(obj,key,{\n        enumerable:true,   //属性可枚举\n        configurable:true, //属性可被删除或修改\n        get:function reactiveGetter(){\n\n            dep.addSub(Dep.target);\n            return val;\n        },\n        set:function reactiveSetter(newVal){\n            if(newVal===val) return;\n            //通知watcher对象更新视图\n            val = newVal\n            dep.notify();\n        }\n    })\n}\n\nfunction observer(value){\n    if(!value||(typeof value !== 'object')){\n        return;\n    }\n\n    Object.keys(value).forEach((key)=>{\n        defineReactive(value,key,value[key]);\n    })\n}\n\nclass Vue {\n    constructor(options){\n        this._data = options.data;\n        observer(this._data);\n        //new一个观察者对象，这时候Dep.target会指向这个watcher\n        new watcher();\n        //模拟render过程，为了触发test属性的get函数\n        console.log('render',this._data.test);\n    }\n}\n\n```\n\n依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会\n被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列\n（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。\n","source":"_posts/vue-template.md","raw":"---\ntitle: template\ndate: 2018-04-18 11:38:08\ntags: vue\ncategories: 学习\n---\n\n>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？\n<!--more-->\n\ncompile编译主要分为parse、optimize与generate三个阶段，最终得到render function。\n\n### parse\n\nparse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。\n形如：\n```bash\n<div :class=\"c\" class=\"demo\" v-if=\"isShow\">\n    <span v-for=\"item in sz\">{{item}}</span>\n</div>\n\n\n\n\n{\n    /* 标签属性的map，记录了标签上属性 */\n    'attrsMap': {\n        ':class': 'c',\n        'class': 'demo',\n        'v-if': 'isShow'\n    },\n    /* 解析得到的:class */\n    'classBinding': 'c',\n    /* 标签属性v-if */\n    'if': 'isShow',\n    /* v-if的条件 */\n    'ifConditions': [\n        'exp': 'isShow'\n    ],\n    /* 标签属性class */\n    'staticClass': 'demo',\n    /* 标签的tag */\n    'tag': 'div',\n    /* 子标签数组 */\n    'children': [\n        {\n            'attrsMap': {\n                'v-for': \"item in sz\"\n            },\n            /* for循环的参数 */\n            'alias': \"item\",\n            /* for循环的对象 */\n            'for': 'sz',\n            /* for循环是否已经被处理的标记位 */\n            'forProcessed': true,\n            'tag': 'span',\n            'children': [\n                {\n                    /* 表达式，_s是一个转字符串的函数 */\n                    'expression': '_s(item)',\n                    'text': '{{item}}'\n                }\n            ]\n        }\n    ]\n}\n```\n### optimize\noptimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是\n来标记静态节点的。\n经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。\n\n\n### generate\n\ngenerate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。\n\n### VNode\n\nrender function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。\n浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，\n\n这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，\n\nVue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。\n\nVue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React\n那样有利用setState合并状态的过程。\n\n### nextTick\n\n其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。\n\n```bash\n//订阅者\nclass Dep{\n    constructor(){\n        //用来存放watcher对象的数组\n        this.subs = [];\n    }\n\n    //在subs中添加一个watcher对象\n    addSub(sub){\n        this.subs.push(sub);\n    }\n    //通知watcher对象更新视图\n    notify(){\n        this.subs.forEach((sub)=>{\n            sub.update();\n        })\n    }\n}\n//观察者\n\nclass watcher{\n    constructor(){\n        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。\n        Dep.target  =this;\n        console.log(this)\n    }\n    //更新视图的方法\n    update(){\n        console.log('view change')\n    }\n}\n\n```\n好吧！  把Vue和之前提到的双向绑定的也贴上吧\n\n```bash\n\nfunction cb() {\n//    简陋的视图更新函数\n    console.log('视图更新了')\n}\n\nfunction defineReactive(obj, key, val) {\n    const dep = new Dep();\n    Object.defineProperty(obj,key,{\n        enumerable:true,   //属性可枚举\n        configurable:true, //属性可被删除或修改\n        get:function reactiveGetter(){\n\n            dep.addSub(Dep.target);\n            return val;\n        },\n        set:function reactiveSetter(newVal){\n            if(newVal===val) return;\n            //通知watcher对象更新视图\n            val = newVal\n            dep.notify();\n        }\n    })\n}\n\nfunction observer(value){\n    if(!value||(typeof value !== 'object')){\n        return;\n    }\n\n    Object.keys(value).forEach((key)=>{\n        defineReactive(value,key,value[key]);\n    })\n}\n\nclass Vue {\n    constructor(options){\n        this._data = options.data;\n        observer(this._data);\n        //new一个观察者对象，这时候Dep.target会指向这个watcher\n        new watcher();\n        //模拟render过程，为了触发test属性的get函数\n        console.log('render',this._data.test);\n    }\n}\n\n```\n\n依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会\n被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列\n（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。\n","slug":"vue-template","published":1,"updated":"2019-09-17T02:42:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8h000zkwfyci1b0jj3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？<br><a id=\"more\"></a></p>\n</blockquote>\n<p>compile编译主要分为parse、optimize与generate三个阶段，最终得到render function。</p>\n<h3 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h3><p>parse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。<br>形如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :class=<span class=\"string\">\"c\"</span> class=<span class=\"string\">\"demo\"</span> v-if=<span class=\"string\">\"isShow\"</span>&gt;</span><br><span class=\"line\">    &lt;span v-for=<span class=\"string\">\"item in sz\"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 标签属性的map，记录了标签上属性 */</span><br><span class=\"line\">    <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">':class'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">        <span class=\"string\">'class'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">        <span class=\"string\">'v-if'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 解析得到的:class */</span><br><span class=\"line\">    <span class=\"string\">'classBinding'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    /* 标签属性v-if */</span><br><span class=\"line\">    <span class=\"string\">'if'</span>: <span class=\"string\">'isShow'</span>,</span><br><span class=\"line\">    /* v-if的条件 */</span><br><span class=\"line\">    <span class=\"string\">'ifConditions'</span>: [</span><br><span class=\"line\">        <span class=\"string\">'exp'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    /* 标签属性class */</span><br><span class=\"line\">    <span class=\"string\">'staticClass'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    /* 标签的tag */</span><br><span class=\"line\">    <span class=\"string\">'tag'</span>: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    /* 子标签数组 */</span><br><span class=\"line\">    <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">'v-for'</span>: <span class=\"string\">\"item in sz\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的参数 */</span><br><span class=\"line\">            <span class=\"string\">'alias'</span>: <span class=\"string\">\"item\"</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的对象 */</span><br><span class=\"line\">            <span class=\"string\">'for'</span>: <span class=\"string\">'sz'</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环是否已经被处理的标记位 */</span><br><span class=\"line\">            <span class=\"string\">'forProcessed'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">'tag'</span>: <span class=\"string\">'span'</span>,</span><br><span class=\"line\">            <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    /* 表达式，_s是一个转字符串的函数 */</span><br><span class=\"line\">                    <span class=\"string\">'expression'</span>: <span class=\"string\">'_s(item)'</span>,</span><br><span class=\"line\">                    <span class=\"string\">'text'</span>: <span class=\"string\">'&#123;&#123;item&#125;&#125;'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"optimize\"><a href=\"#optimize\" class=\"headerlink\" title=\"optimize\"></a>optimize</h3><p>optimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是<br>来标记静态节点的。<br>经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。</p>\n<h3 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h3><p>generate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p>\n<h3 id=\"VNode\"><a href=\"#VNode\" class=\"headerlink\" title=\"VNode\"></a>VNode</h3><p>render function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。<br>浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，</p>\n<p>这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，</p>\n<p>Vue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p>\n<p>Vue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React<br>那样有利用setState合并状态的过程。</p>\n<h3 id=\"nextTick\"><a href=\"#nextTick\" class=\"headerlink\" title=\"nextTick\"></a>nextTick</h3><p>其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//订阅者</span><br><span class=\"line\">class Dep&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //用来存放watcher对象的数组</span><br><span class=\"line\">        this.subs = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //在subs中添加一个watcher对象</span><br><span class=\"line\">    addSub(sub)&#123;</span><br><span class=\"line\">        this.subs.push(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //通知watcher对象更新视图</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">notify</span></span>()&#123;</span><br><span class=\"line\">        this.subs.forEach((sub)=&gt;&#123;</span><br><span class=\"line\">            sub.update();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//观察者</span><br><span class=\"line\"></span><br><span class=\"line\">class watcher&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。</span><br><span class=\"line\">        Dep.target  =this;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //更新视图的方法</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">update</span></span>()&#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'view change'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好吧！  把Vue和之前提到的双向绑定的也贴上吧</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">cb</span></span>() &#123;</span><br><span class=\"line\">//    简陋的视图更新函数</span><br><span class=\"line\">    console.log(<span class=\"string\">'视图更新了'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> defineReactive(obj, key, val) &#123;</span><br><span class=\"line\">    const dep = new Dep();</span><br><span class=\"line\">    Object.defineProperty(obj,key,&#123;</span><br><span class=\"line\">        enumerable:<span class=\"literal\">true</span>,   //属性可枚举</span><br><span class=\"line\">        configurable:<span class=\"literal\">true</span>, //属性可被删除或修改</span><br><span class=\"line\">        get:<span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">reactiveGetter</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            dep.addSub(Dep.target);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"built_in\">set</span>:<span class=\"keyword\">function</span> reactiveSetter(newVal)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(newVal===val) <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            //通知watcher对象更新视图</span><br><span class=\"line\">            val = newVal</span><br><span class=\"line\">            dep.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> observer(value)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!value||(typeof value !== <span class=\"string\">'object'</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object.keys(value).forEach((key)=&gt;&#123;</span><br><span class=\"line\">        defineReactive(value,key,value[key]);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Vue &#123;</span><br><span class=\"line\">    constructor(options)&#123;</span><br><span class=\"line\">        this._data = options.data;</span><br><span class=\"line\">        observer(this._data);</span><br><span class=\"line\">        //new一个观察者对象，这时候Dep.target会指向这个watcher</span><br><span class=\"line\">        new watcher();</span><br><span class=\"line\">        //模拟render过程，为了触发<span class=\"built_in\">test</span>属性的get函数</span><br><span class=\"line\">        console.log(<span class=\"string\">'render'</span>,this._data.test);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会<br>被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列<br>（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？<br>","more":"</p>\n</blockquote>\n<p>compile编译主要分为parse、optimize与generate三个阶段，最终得到render function。</p>\n<h3 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h3><p>parse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。<br>形如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :class=<span class=\"string\">\"c\"</span> class=<span class=\"string\">\"demo\"</span> v-if=<span class=\"string\">\"isShow\"</span>&gt;</span><br><span class=\"line\">    &lt;span v-for=<span class=\"string\">\"item in sz\"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 标签属性的map，记录了标签上属性 */</span><br><span class=\"line\">    <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">':class'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">        <span class=\"string\">'class'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">        <span class=\"string\">'v-if'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 解析得到的:class */</span><br><span class=\"line\">    <span class=\"string\">'classBinding'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    /* 标签属性v-if */</span><br><span class=\"line\">    <span class=\"string\">'if'</span>: <span class=\"string\">'isShow'</span>,</span><br><span class=\"line\">    /* v-if的条件 */</span><br><span class=\"line\">    <span class=\"string\">'ifConditions'</span>: [</span><br><span class=\"line\">        <span class=\"string\">'exp'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    /* 标签属性class */</span><br><span class=\"line\">    <span class=\"string\">'staticClass'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    /* 标签的tag */</span><br><span class=\"line\">    <span class=\"string\">'tag'</span>: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    /* 子标签数组 */</span><br><span class=\"line\">    <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">'v-for'</span>: <span class=\"string\">\"item in sz\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的参数 */</span><br><span class=\"line\">            <span class=\"string\">'alias'</span>: <span class=\"string\">\"item\"</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的对象 */</span><br><span class=\"line\">            <span class=\"string\">'for'</span>: <span class=\"string\">'sz'</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环是否已经被处理的标记位 */</span><br><span class=\"line\">            <span class=\"string\">'forProcessed'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">'tag'</span>: <span class=\"string\">'span'</span>,</span><br><span class=\"line\">            <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    /* 表达式，_s是一个转字符串的函数 */</span><br><span class=\"line\">                    <span class=\"string\">'expression'</span>: <span class=\"string\">'_s(item)'</span>,</span><br><span class=\"line\">                    <span class=\"string\">'text'</span>: <span class=\"string\">'&#123;&#123;item&#125;&#125;'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"optimize\"><a href=\"#optimize\" class=\"headerlink\" title=\"optimize\"></a>optimize</h3><p>optimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是<br>来标记静态节点的。<br>经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。</p>\n<h3 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h3><p>generate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p>\n<h3 id=\"VNode\"><a href=\"#VNode\" class=\"headerlink\" title=\"VNode\"></a>VNode</h3><p>render function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。<br>浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，</p>\n<p>这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，</p>\n<p>Vue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p>\n<p>Vue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React<br>那样有利用setState合并状态的过程。</p>\n<h3 id=\"nextTick\"><a href=\"#nextTick\" class=\"headerlink\" title=\"nextTick\"></a>nextTick</h3><p>其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//订阅者</span><br><span class=\"line\">class Dep&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //用来存放watcher对象的数组</span><br><span class=\"line\">        this.subs = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //在subs中添加一个watcher对象</span><br><span class=\"line\">    addSub(sub)&#123;</span><br><span class=\"line\">        this.subs.push(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //通知watcher对象更新视图</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">notify</span></span>()&#123;</span><br><span class=\"line\">        this.subs.forEach((sub)=&gt;&#123;</span><br><span class=\"line\">            sub.update();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//观察者</span><br><span class=\"line\"></span><br><span class=\"line\">class watcher&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。</span><br><span class=\"line\">        Dep.target  =this;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //更新视图的方法</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">update</span></span>()&#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'view change'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好吧！  把Vue和之前提到的双向绑定的也贴上吧</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">cb</span></span>() &#123;</span><br><span class=\"line\">//    简陋的视图更新函数</span><br><span class=\"line\">    console.log(<span class=\"string\">'视图更新了'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> defineReactive(obj, key, val) &#123;</span><br><span class=\"line\">    const dep = new Dep();</span><br><span class=\"line\">    Object.defineProperty(obj,key,&#123;</span><br><span class=\"line\">        enumerable:<span class=\"literal\">true</span>,   //属性可枚举</span><br><span class=\"line\">        configurable:<span class=\"literal\">true</span>, //属性可被删除或修改</span><br><span class=\"line\">        get:<span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">reactiveGetter</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            dep.addSub(Dep.target);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"built_in\">set</span>:<span class=\"keyword\">function</span> reactiveSetter(newVal)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(newVal===val) <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            //通知watcher对象更新视图</span><br><span class=\"line\">            val = newVal</span><br><span class=\"line\">            dep.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> observer(value)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!value||(typeof value !== <span class=\"string\">'object'</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object.keys(value).forEach((key)=&gt;&#123;</span><br><span class=\"line\">        defineReactive(value,key,value[key]);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Vue &#123;</span><br><span class=\"line\">    constructor(options)&#123;</span><br><span class=\"line\">        this._data = options.data;</span><br><span class=\"line\">        observer(this._data);</span><br><span class=\"line\">        //new一个观察者对象，这时候Dep.target会指向这个watcher</span><br><span class=\"line\">        new watcher();</span><br><span class=\"line\">        //模拟render过程，为了触发<span class=\"built_in\">test</span>属性的get函数</span><br><span class=\"line\">        console.log(<span class=\"string\">'render'</span>,this._data.test);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会<br>被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列<br>（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。</p>"},{"title":"Vue学习笔记之v-model指令","date":"2018-01-08T04:05:36.000Z","_content":"\n\n&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。\n\n<!--more-->\n\n### 表单控件绑定\n----------------\n\n#### 基础语法\n\n+ v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型\n自动选取正确的方法来更新元素。\n+ v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。\n\n##### 简单示例\n\n```bash\n<!--单行-->\n<!--直接绑定变量,这个变量需要在vue实例里面的-->\n<div id=\"aa\">\n    <input v-model=\"message\" placeholder=\"edit me\">\n    <p>Message is: {{ message }}</p>\n</div>\n```\n\n```Bash\n<script src=\"js/vue.js\"></script> //引用vue\n<script>\n    new Vue({\n        el: '#aa', //挂载vue实例\n        data: {\n            message: '' //需要有一个做双向绑定的变量\n        }\n    })\n</script>\n```\n\n##### textarea\n\n```bash\n<!--多行textarea,其实类似单行-->\n<span>Multiline message is:</span>\n<p style=\"white-space: pre\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n##### radio\n\n```bash\n<!--单选,类似单行,不过需要注意的是他们使用同一个v-model-->\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n```bash\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            picked:'One'\n        }\n    })\n</script>\n```\n&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。\n#### checkbox\n&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。\n组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：\n```bash\n<div id=\"app\">\n    <input type=\"text\" v-model=\"text\">\n    {{text}}\n    <input type=\"radio\" :checked=\"picked\"><br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"html\" id=\"checked\">\n    <label for=\"html\">HTML</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"js\" id=\"js\">\n    <label for=\"js\">JS</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"css\" id=\"css\">\n    <label for=\"css\">CSS</label>\n    <br>\n    <p>选择的是{{checked}}</p>\n</div>\n```\n```Bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            text:'',\n            picked:true,\n            checked:['html','css']\n        }\n    })\n</script>\n```\n##### select\n\n```bash\n<!--选择列表,类似单行-->\n<select v-model=\"selected\">\n  <option>A</option>\n  <option value='b'>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。\n<em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em>\n\n### v-model的背后\n-----------------\n\n&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：\n   1. v-bind绑定一个value值\n   2. v-on指令绑定一个input事件或者说是change事件\n&emsp;&emsp;举个栗子：\n#### 在原生表单中\n```Bash\n<input v-model='message'>\n```\n\n相当于\n\n```bash\n<input v-bind:value='message' @input='message = $event.target.value'>\n```\n &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素\n\n#### 在自定义组件中\n\n```Bash\n<my-component v-model='message' ></my-component>\n```\n相当于\n```Bash\n<my-component :value='message' @input='message = arguments[0]' ></my-component>\n```\n&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。\n```Bash\nthis.$emit('input',value);\n```\n\n### 修饰符\n---------\n\n与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。\n\n#### .lazy\n\n&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。\n\n```bash\n<div id=\"app\">\n    <input type='text' v-model.lazy='message' >\n    <p>{{message}}</p>\n</div>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n这时，message并不是实时更新的，而是在在失焦或按回车时才更新。\n\n#### .number\n&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"number\" v-model.number='message' value=\"\">\n    <p>{{typeof message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n\n#### .trim\n修饰符.trim会自动过滤输入的首尾空格，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"text\" v-model.trim='message' value=\"\">\n    <p>{{message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n","source":"_posts/vue-v-model.md","raw":"---\ntitle: Vue学习笔记之v-model指令\ndate: 2018-01-08 12:05:36\ntags: vue\ncategories: 学习\n---\n\n\n&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。\n\n<!--more-->\n\n### 表单控件绑定\n----------------\n\n#### 基础语法\n\n+ v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型\n自动选取正确的方法来更新元素。\n+ v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。\n\n##### 简单示例\n\n```bash\n<!--单行-->\n<!--直接绑定变量,这个变量需要在vue实例里面的-->\n<div id=\"aa\">\n    <input v-model=\"message\" placeholder=\"edit me\">\n    <p>Message is: {{ message }}</p>\n</div>\n```\n\n```Bash\n<script src=\"js/vue.js\"></script> //引用vue\n<script>\n    new Vue({\n        el: '#aa', //挂载vue实例\n        data: {\n            message: '' //需要有一个做双向绑定的变量\n        }\n    })\n</script>\n```\n\n##### textarea\n\n```bash\n<!--多行textarea,其实类似单行-->\n<span>Multiline message is:</span>\n<p style=\"white-space: pre\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n##### radio\n\n```bash\n<!--单选,类似单行,不过需要注意的是他们使用同一个v-model-->\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n```bash\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            picked:'One'\n        }\n    })\n</script>\n```\n&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。\n#### checkbox\n&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。\n组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：\n```bash\n<div id=\"app\">\n    <input type=\"text\" v-model=\"text\">\n    {{text}}\n    <input type=\"radio\" :checked=\"picked\"><br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"html\" id=\"checked\">\n    <label for=\"html\">HTML</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"js\" id=\"js\">\n    <label for=\"js\">JS</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"css\" id=\"css\">\n    <label for=\"css\">CSS</label>\n    <br>\n    <p>选择的是{{checked}}</p>\n</div>\n```\n```Bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            text:'',\n            picked:true,\n            checked:['html','css']\n        }\n    })\n</script>\n```\n##### select\n\n```bash\n<!--选择列表,类似单行-->\n<select v-model=\"selected\">\n  <option>A</option>\n  <option value='b'>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。\n<em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em>\n\n### v-model的背后\n-----------------\n\n&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：\n   1. v-bind绑定一个value值\n   2. v-on指令绑定一个input事件或者说是change事件\n&emsp;&emsp;举个栗子：\n#### 在原生表单中\n```Bash\n<input v-model='message'>\n```\n\n相当于\n\n```bash\n<input v-bind:value='message' @input='message = $event.target.value'>\n```\n &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素\n\n#### 在自定义组件中\n\n```Bash\n<my-component v-model='message' ></my-component>\n```\n相当于\n```Bash\n<my-component :value='message' @input='message = arguments[0]' ></my-component>\n```\n&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。\n```Bash\nthis.$emit('input',value);\n```\n\n### 修饰符\n---------\n\n与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。\n\n#### .lazy\n\n&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。\n\n```bash\n<div id=\"app\">\n    <input type='text' v-model.lazy='message' >\n    <p>{{message}}</p>\n</div>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n这时，message并不是实时更新的，而是在在失焦或按回车时才更新。\n\n#### .number\n&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"number\" v-model.number='message' value=\"\">\n    <p>{{typeof message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n\n#### .trim\n修饰符.trim会自动过滤输入的首尾空格，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"text\" v-model.trim='message' value=\"\">\n    <p>{{message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n","slug":"vue-v-model","published":1,"updated":"2019-09-17T02:43:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8i0012kwfyekqox3ci","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。</p>\n<a id=\"more\"></a>\n<h3 id=\"表单控件绑定\"><a href=\"#表单控件绑定\" class=\"headerlink\" title=\"表单控件绑定\"></a>表单控件绑定</h3><hr>\n<h4 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h4><ul>\n<li>v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型<br>自动选取正确的方法来更新元素。</li>\n<li>v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。</li>\n</ul>\n<h5 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单行--&gt;</span><br><span class=\"line\">&lt;!--直接绑定变量,这个变量需要在vue实例里面的--&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"aa\"</span>&gt;</span><br><span class=\"line\">    &lt;input v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"edit me\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"js/vue.js\"</span>&gt;&lt;/script&gt; //引用vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#aa'</span>, //挂载vue实例</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            message: <span class=\"string\">''</span> //需要有一个做双向绑定的变量</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"textarea\"><a href=\"#textarea\" class=\"headerlink\" title=\"textarea\"></a>textarea</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--多行textarea,其实类似单行--&gt;</span><br><span class=\"line\">&lt;span&gt;Multiline message is:&lt;/span&gt;</span><br><span class=\"line\">&lt;p style=<span class=\"string\">\"white-space: pre\"</span>&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;textarea v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"add multiple lines\"</span>&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"radio\"><a href=\"#radio\" class=\"headerlink\" title=\"radio\"></a>radio</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单选,类似单行,不过需要注意的是他们使用同一个v-model--&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"one\"</span> value=<span class=\"string\">\"One\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"one\"</span>&gt;One&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"two\"</span> value=<span class=\"string\">\"Two\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"two\"</span>&gt;Two&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            picked:<span class=\"string\">'One'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。</p>\n<h4 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h4><p>&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。<br>组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"text\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123;text&#125;&#125;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> :checked=<span class=\"string\">\"picked\"</span>&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"html\"</span> id=<span class=\"string\">\"checked\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"html\"</span>&gt;HTML&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"js\"</span> id=<span class=\"string\">\"js\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"js\"</span>&gt;JS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"css\"</span> id=<span class=\"string\">\"css\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"css\"</span>&gt;CSS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;p&gt;选择的是&#123;&#123;checked&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            text:<span class=\"string\">''</span>,</span><br><span class=\"line\">            picked:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            checked:[<span class=\"string\">'html'</span>,<span class=\"string\">'css'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--选择列表,类似单行--&gt;</span><br><span class=\"line\">&lt;select v-model=<span class=\"string\">\"selected\"</span>&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option value=<span class=\"string\">'b'</span>&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。<br><em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em></option></p>\n<h3 id=\"v-model的背后\"><a href=\"#v-model的背后\" class=\"headerlink\" title=\"v-model的背后\"></a>v-model的背后</h3><hr>\n<p>&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：</p>\n<ol>\n<li>v-bind绑定一个value值</li>\n<li>v-on指令绑定一个input事件或者说是change事件<br>&emsp;&emsp;举个栗子：<h4 id=\"在原生表单中\"><a href=\"#在原生表单中\" class=\"headerlink\" title=\"在原生表单中\"></a>在原生表单中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=<span class=\"string\">'message'</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>相当于</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-bind:value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = $event.target.value'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p> &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素</p>\n<h4 id=\"在自定义组件中\"><a href=\"#在自定义组件中\" class=\"headerlink\" title=\"在自定义组件中\"></a>在自定义组件中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component v-model=<span class=\"string\">'message'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>\n<p>相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component :value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = arguments[0]'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$emit</span>(<span class=\"string\">'input'</span>,value);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><hr>\n<p>与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。</p>\n<h4 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h4><p>&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">'text'</span> v-model.lazy=<span class=\"string\">'message'</span> &gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这时，message并不是实时更新的，而是在在失焦或按回车时才更新。</p>\n<h4 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h4><p>&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"number\"</span> v-model.number=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;typeof message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h4><p>修饰符.trim会自动过滤输入的首尾空格，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model.trim=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。</p>","more":"<h3 id=\"表单控件绑定\"><a href=\"#表单控件绑定\" class=\"headerlink\" title=\"表单控件绑定\"></a>表单控件绑定</h3><hr>\n<h4 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h4><ul>\n<li>v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型<br>自动选取正确的方法来更新元素。</li>\n<li>v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。</li>\n</ul>\n<h5 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单行--&gt;</span><br><span class=\"line\">&lt;!--直接绑定变量,这个变量需要在vue实例里面的--&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"aa\"</span>&gt;</span><br><span class=\"line\">    &lt;input v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"edit me\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"js/vue.js\"</span>&gt;&lt;/script&gt; //引用vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#aa'</span>, //挂载vue实例</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            message: <span class=\"string\">''</span> //需要有一个做双向绑定的变量</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"textarea\"><a href=\"#textarea\" class=\"headerlink\" title=\"textarea\"></a>textarea</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--多行textarea,其实类似单行--&gt;</span><br><span class=\"line\">&lt;span&gt;Multiline message is:&lt;/span&gt;</span><br><span class=\"line\">&lt;p style=<span class=\"string\">\"white-space: pre\"</span>&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;textarea v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"add multiple lines\"</span>&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"radio\"><a href=\"#radio\" class=\"headerlink\" title=\"radio\"></a>radio</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单选,类似单行,不过需要注意的是他们使用同一个v-model--&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"one\"</span> value=<span class=\"string\">\"One\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"one\"</span>&gt;One&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"two\"</span> value=<span class=\"string\">\"Two\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"two\"</span>&gt;Two&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            picked:<span class=\"string\">'One'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。</p>\n<h4 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h4><p>&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。<br>组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"text\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123;text&#125;&#125;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> :checked=<span class=\"string\">\"picked\"</span>&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"html\"</span> id=<span class=\"string\">\"checked\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"html\"</span>&gt;HTML&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"js\"</span> id=<span class=\"string\">\"js\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"js\"</span>&gt;JS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"css\"</span> id=<span class=\"string\">\"css\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"css\"</span>&gt;CSS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;p&gt;选择的是&#123;&#123;checked&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            text:<span class=\"string\">''</span>,</span><br><span class=\"line\">            picked:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            checked:[<span class=\"string\">'html'</span>,<span class=\"string\">'css'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--选择列表,类似单行--&gt;</span><br><span class=\"line\">&lt;select v-model=<span class=\"string\">\"selected\"</span>&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option value=<span class=\"string\">'b'</span>&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。<br><em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em></option></p>\n<h3 id=\"v-model的背后\"><a href=\"#v-model的背后\" class=\"headerlink\" title=\"v-model的背后\"></a>v-model的背后</h3><hr>\n<p>&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：</p>\n<ol>\n<li>v-bind绑定一个value值</li>\n<li>v-on指令绑定一个input事件或者说是change事件<br>&emsp;&emsp;举个栗子：<h4 id=\"在原生表单中\"><a href=\"#在原生表单中\" class=\"headerlink\" title=\"在原生表单中\"></a>在原生表单中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=<span class=\"string\">'message'</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>相当于</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-bind:value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = $event.target.value'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p> &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素</p>\n<h4 id=\"在自定义组件中\"><a href=\"#在自定义组件中\" class=\"headerlink\" title=\"在自定义组件中\"></a>在自定义组件中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component v-model=<span class=\"string\">'message'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>\n<p>相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component :value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = arguments[0]'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$emit</span>(<span class=\"string\">'input'</span>,value);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><hr>\n<p>与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。</p>\n<h4 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h4><p>&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">'text'</span> v-model.lazy=<span class=\"string\">'message'</span> &gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这时，message并不是实时更新的，而是在在失焦或按回车时才更新。</p>\n<h4 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h4><p>&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"number\"</span> v-model.number=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;typeof message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h4><p>修饰符.trim会自动过滤输入的首尾空格，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model.trim=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>"},{"title":"friendships","date":"2018-05-23T04:03:10.000Z","_content":"\n发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br>\n\n之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。\n<!--more-->\n<div style=\"width:100%;\">\n<div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\">\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n\n</div>\n</div>\n","source":"_posts/指弹-friendships.md","raw":"---\ntitle: friendships\ndate: 2018-05-23 12:03:10\ntags: 指弹\ncategories: 指弹\n---\n\n发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br>\n\n之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。\n<!--more-->\n<div style=\"width:100%;\">\n<div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\">\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n\n</div>\n</div>\n","slug":"指弹-friendships","published":1,"updated":"2019-09-17T02:39:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8k0015kwfyew129s4p","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br></p>\n<p>之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。<br><a id=\"more\"></a></p>\n<div style=\"width:100%;\"><br><div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\"><br><div id=\"dplayer0\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br><br></div><br></div>\n","site":{"data":{}},"excerpt":"<p>发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br></p>\n<p>之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。<br>","more":"</p>\n<div style=\"width:100%;\"><br><div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\"><br><div id=\"dplayer0\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br><br></div><br></div>"},{"title":"封培总结","date":"2019-07-22T02:44:48.000Z","_content":">正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’\n\n<!--more-->\n\n此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。\n\n+ 难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。\n\n### 优点:\n+ 帮助另外非react技术栈的同学开发。\n+ 能够为遇到的问题提供合适的解决方案。\n+ 开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。\n\n### 不足：\n+ 在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。\n+ 功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。\n+ 前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。\n+ 部分接口缺少mock。\n\t\n\n### 收获以及感悟：\n+ 在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。\n+ 功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。\n+ 在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。\n\n\n此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。","source":"_posts/其他-封培总结.md","raw":"---\ntitle: 封培总结\ndate: 2019-07-22 10:44:48\ntags: 其他\ncategories:\n---\n>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’\n\n<!--more-->\n\n此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。\n\n+ 难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。\n\n### 优点:\n+ 帮助另外非react技术栈的同学开发。\n+ 能够为遇到的问题提供合适的解决方案。\n+ 开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。\n\n### 不足：\n+ 在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。\n+ 功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。\n+ 前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。\n+ 部分接口缺少mock。\n\t\n\n### 收获以及感悟：\n+ 在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。\n+ 功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。\n+ 在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。\n\n\n此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。","slug":"其他-封培总结","published":1,"updated":"2019-09-17T02:38:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8m0018kwfyefidm2um","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。</p>\n<ul>\n<li>难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>帮助另外非react技术栈的同学开发。</li>\n<li>能够为遇到的问题提供合适的解决方案。</li>\n<li>开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。</li>\n</ul>\n<h3 id=\"不足：\"><a href=\"#不足：\" class=\"headerlink\" title=\"不足：\"></a>不足：</h3><ul>\n<li>在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。</li>\n<li>功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。</li>\n<li>前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。</li>\n<li>部分接口缺少mock。</li>\n</ul>\n<h3 id=\"收获以及感悟：\"><a href=\"#收获以及感悟：\" class=\"headerlink\" title=\"收获以及感悟：\"></a>收获以及感悟：</h3><ul>\n<li>在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。</li>\n<li>功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。</li>\n<li>在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。</li>\n</ul>\n<p>此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’</p>\n</blockquote>","more":"<p>此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。</p>\n<ul>\n<li>难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>帮助另外非react技术栈的同学开发。</li>\n<li>能够为遇到的问题提供合适的解决方案。</li>\n<li>开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。</li>\n</ul>\n<h3 id=\"不足：\"><a href=\"#不足：\" class=\"headerlink\" title=\"不足：\"></a>不足：</h3><ul>\n<li>在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。</li>\n<li>功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。</li>\n<li>前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。</li>\n<li>部分接口缺少mock。</li>\n</ul>\n<h3 id=\"收获以及感悟：\"><a href=\"#收获以及感悟：\" class=\"headerlink\" title=\"收获以及感悟：\"></a>收获以及感悟：</h3><ul>\n<li>在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。</li>\n<li>功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。</li>\n<li>在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。</li>\n</ul>\n<p>此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。</p>"},{"title":"time travel","date":"2018-04-29T12:50:28.000Z","_content":"\n>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。\n\n<!--more-->\n\n喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。\n(录得效果不好)\n\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"  \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","source":"_posts/指弹-timetravel.md","raw":"---\ntitle: time travel\ndate: 2018-04-29 20:50:28\ntags: 指弹\ncategories: 指弹\n---\n\n>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。\n\n<!--more-->\n\n喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。\n(录得效果不好)\n\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"  \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","slug":"指弹-timetravel","published":1,"updated":"2019-09-17T02:43:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8r001ckwfyinjmkllb","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。<br>(录得效果不好)</p>\n<div id=\"dplayer1\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。</p>\n</blockquote>","more":"<p>喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。<br>(录得效果不好)</p>\n<div id=\"dplayer1\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>"},{"title":"流行的云","date":"2018-05-20T08:41:37.000Z","_content":"\n又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。\n\n<!--more-->\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","source":"_posts/指弹-流行的云.md","raw":"---\ntitle: 流行的云\ndate: 2018-05-20 16:41:37\ntags: 指弹\ncategories: 指弹\n---\n\n又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。\n\n<!--more-->\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","slug":"指弹-流行的云","published":1,"updated":"2019-09-17T02:37:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8u001fkwfycb7ttcil","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。</p>\n<a id=\"more\"></a>\n<div id=\"dplayer2\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>\n","site":{"data":{}},"excerpt":"<p>又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。</p>","more":"<div id=\"dplayer2\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>"},{"title":"明镜小结","date":"2019-07-25T15:54:06.000Z","_content":"\n>将项目里遇到的坑，或者说一些优秀的想法记下来\n\n<!--more-->\n\n### import\n\nimport('/src/nav.js')是import的动态用法，返回值是一个promise，resolve的形如{ default: nav, __esModule: true }\n\n### asyncComponent\n\n对于加载页面时，并未立即显示的组件，可以采用异步组件的模式按需加载。\n\n```bash\n\nfunction loadComponent(getComponent){\n    return class AsyncComponent extend PureComponent{\n        static AsyComponent = null;\n        state = {\n            AsyComponent : AsyncComponent.AsyComponent\n        };\n        componentDidMount(){\n            if(!this.state.AsyComponent){\n                getComponent().then(({ default: Component }) => {\n                    this.setState({\n                        AsyComponent: Component\n                    })\n                })\n            }\n        }\n        render(){\n            const { AsyComponent } = this.state;\n            return (\n                if(AsyComponent){\n                    <AsyComponent/>\n                }\n\n                return <Spin title='加载中....'/>\n            )\n        }\n    }\n}\n\n\n```\n\n\n### mapDispatchToProps\n\n+ mapDispatchToProps用于建立组件跟store.dispatch的映射关系\n+ 可以是一个object，也可以传入函数\n+ 如果mapDispatchToProps是一个函数，它可以传入dispatch,ownProps, 定义UI组件如何发出action，实际上就是要调用dispatch这个方法\n\n```bash\n/* 假设actions是一个import进来的值为actionCreator的object */\naction.increase = function (info) {\n  return {\n     {\n        type:'INCREASE'，\n        info\n     }\n  }\n}\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    increase: (...args) => dispatch(actions.increase(...args)),\n    decrease: (...args) => dispatch(actions.decrease(...args))\n  }\n}\n```\n\n调用actions.increase()只能得到一个 action对象{type:'INCREASE'} ，要触发这个 action必须在store 上调用 dispatch 方法。 diapatch正是 mapDispatchToProps的第一个参数。但是，为了不让 组件感知到 dispatch 的存在，需要将increase 和 decrease 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 dispatch ）。\n\n#### bindActionCreator\nbindActionCreator可以将action包装成可以被调用的函数。\n```bash\nimport {bindActionCreators} from 'redux';\n\nconst mapDispatchToProps = {\n} = (dispatch, ownProps) => {\n  return bindActionCreators({\n    increase: action.increase,\n    decrease: action.decrease\n  }, dispatch);\n}\n\n/* 返回跟上面一样的object */\n{\n   increase: (...args) => dispatch(action.increase(...args)),\n   decrease: (...args) => dispatch(action.decrease(...args)),\n}\n```\n\n+ 如果mapDispatchToProps是一个函数, 并且传入ownProps, 当组件获取新的props的时候，mapDispatchToProps也会被调用.\n+ 传入一个object，其中这个object所对应的value必须是actionCreator，这样redux里面会自动帮我们调用bindActionCreator，所以上面又可以变成\n\n```bash\nconst mapDispatchToProps = {\n    ...action\n}\n```\n\n##### 参考地址\n[https://imweb.io/topic/5a426d32a192c3b460fce354](https://imweb.io/topic/5a426d32a192c3b460fce354)\n\n### antd \n#### CheckBox \n+ 描述： form.resetFields时，不能重置checkbox\n+ 解决办法：在getFieldDecorator(key, options)的options里添加{valuePropName: 'checked'}\n\n#### rangePicker\n+ 默认时间不显示\n+ 解决办法：用initialValue而不是defaultValue更不是defaultPickerValue\n\n#### 小常识\n被form.create()包裹的组件，当form控件的的值方式变化的时候，会触发自定义组件的rerender。","source":"_posts/杂记-MingJingNote.md","raw":"---\ntitle: 明镜小结\ndate: 2019-07-25 23:54:06\ntags: 学习\n---\n\n>将项目里遇到的坑，或者说一些优秀的想法记下来\n\n<!--more-->\n\n### import\n\nimport('/src/nav.js')是import的动态用法，返回值是一个promise，resolve的形如{ default: nav, __esModule: true }\n\n### asyncComponent\n\n对于加载页面时，并未立即显示的组件，可以采用异步组件的模式按需加载。\n\n```bash\n\nfunction loadComponent(getComponent){\n    return class AsyncComponent extend PureComponent{\n        static AsyComponent = null;\n        state = {\n            AsyComponent : AsyncComponent.AsyComponent\n        };\n        componentDidMount(){\n            if(!this.state.AsyComponent){\n                getComponent().then(({ default: Component }) => {\n                    this.setState({\n                        AsyComponent: Component\n                    })\n                })\n            }\n        }\n        render(){\n            const { AsyComponent } = this.state;\n            return (\n                if(AsyComponent){\n                    <AsyComponent/>\n                }\n\n                return <Spin title='加载中....'/>\n            )\n        }\n    }\n}\n\n\n```\n\n\n### mapDispatchToProps\n\n+ mapDispatchToProps用于建立组件跟store.dispatch的映射关系\n+ 可以是一个object，也可以传入函数\n+ 如果mapDispatchToProps是一个函数，它可以传入dispatch,ownProps, 定义UI组件如何发出action，实际上就是要调用dispatch这个方法\n\n```bash\n/* 假设actions是一个import进来的值为actionCreator的object */\naction.increase = function (info) {\n  return {\n     {\n        type:'INCREASE'，\n        info\n     }\n  }\n}\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    increase: (...args) => dispatch(actions.increase(...args)),\n    decrease: (...args) => dispatch(actions.decrease(...args))\n  }\n}\n```\n\n调用actions.increase()只能得到一个 action对象{type:'INCREASE'} ，要触发这个 action必须在store 上调用 dispatch 方法。 diapatch正是 mapDispatchToProps的第一个参数。但是，为了不让 组件感知到 dispatch 的存在，需要将increase 和 decrease 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 dispatch ）。\n\n#### bindActionCreator\nbindActionCreator可以将action包装成可以被调用的函数。\n```bash\nimport {bindActionCreators} from 'redux';\n\nconst mapDispatchToProps = {\n} = (dispatch, ownProps) => {\n  return bindActionCreators({\n    increase: action.increase,\n    decrease: action.decrease\n  }, dispatch);\n}\n\n/* 返回跟上面一样的object */\n{\n   increase: (...args) => dispatch(action.increase(...args)),\n   decrease: (...args) => dispatch(action.decrease(...args)),\n}\n```\n\n+ 如果mapDispatchToProps是一个函数, 并且传入ownProps, 当组件获取新的props的时候，mapDispatchToProps也会被调用.\n+ 传入一个object，其中这个object所对应的value必须是actionCreator，这样redux里面会自动帮我们调用bindActionCreator，所以上面又可以变成\n\n```bash\nconst mapDispatchToProps = {\n    ...action\n}\n```\n\n##### 参考地址\n[https://imweb.io/topic/5a426d32a192c3b460fce354](https://imweb.io/topic/5a426d32a192c3b460fce354)\n\n### antd \n#### CheckBox \n+ 描述： form.resetFields时，不能重置checkbox\n+ 解决办法：在getFieldDecorator(key, options)的options里添加{valuePropName: 'checked'}\n\n#### rangePicker\n+ 默认时间不显示\n+ 解决办法：用initialValue而不是defaultValue更不是defaultPickerValue\n\n#### 小常识\n被form.create()包裹的组件，当form控件的的值方式变化的时候，会触发自定义组件的rerender。","slug":"杂记-MingJingNote","published":1,"updated":"2019-09-17T02:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8v001ikwfyby5xydvv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>将项目里遇到的坑，或者说一些优秀的想法记下来</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>import(‘/src/nav.js’)是import的动态用法，返回值是一个promise，resolve的形如{ default: nav, __esModule: true }</p>\n<h3 id=\"asyncComponent\"><a href=\"#asyncComponent\" class=\"headerlink\" title=\"asyncComponent\"></a>asyncComponent</h3><p>对于加载页面时，并未立即显示的组件，可以采用异步组件的模式按需加载。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> loadComponent(getComponent)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> class AsyncComponent extend PureComponent&#123;</span><br><span class=\"line\">        static AsyComponent = null;</span><br><span class=\"line\">        state = &#123;</span><br><span class=\"line\">            AsyComponent : AsyncComponent.AsyComponent</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">componentDidMount</span></span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!this.state.AsyComponent)&#123;</span><br><span class=\"line\">                getComponent().<span class=\"keyword\">then</span>((&#123; default: Component &#125;) =&gt; &#123;</span><br><span class=\"line\">                    this.setState(&#123;</span><br><span class=\"line\">                        AsyComponent: Component</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">render</span></span>()&#123;</span><br><span class=\"line\">            const &#123; AsyComponent &#125; = this.state;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> (</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(AsyComponent)&#123;</span><br><span class=\"line\">                    &lt;AsyComponent/&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">return</span> &lt;Spin title=<span class=\"string\">'加载中....'</span>/&gt;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapDispatchToProps\"><a href=\"#mapDispatchToProps\" class=\"headerlink\" title=\"mapDispatchToProps\"></a>mapDispatchToProps</h3><ul>\n<li>mapDispatchToProps用于建立组件跟store.dispatch的映射关系</li>\n<li>可以是一个object，也可以传入函数</li>\n<li>如果mapDispatchToProps是一个函数，它可以传入dispatch,ownProps, 定义UI组件如何发出action，实际上就是要调用dispatch这个方法</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 假设actions是一个import进来的值为actionCreator的object */</span><br><span class=\"line\">action.increase = <span class=\"keyword\">function</span> (info) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">type</span>:<span class=\"string\">'INCREASE'</span>，</span><br><span class=\"line\">        info</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">    increase: (...args) =&gt; dispatch(actions.increase(...args)),</span><br><span class=\"line\">    decrease: (...args) =&gt; dispatch(actions.decrease(...args))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用actions.increase()只能得到一个 action对象{type:’INCREASE’} ，要触发这个 action必须在store 上调用 dispatch 方法。 diapatch正是 mapDispatchToProps的第一个参数。但是，为了不让 组件感知到 dispatch 的存在，需要将increase 和 decrease 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 dispatch ）。</p>\n<h4 id=\"bindActionCreator\"><a href=\"#bindActionCreator\" class=\"headerlink\" title=\"bindActionCreator\"></a>bindActionCreator</h4><p>bindActionCreator可以将action包装成可以被调用的函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;bindActionCreators&#125; from <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapDispatchToProps = &#123;</span><br><span class=\"line\">&#125; = (dispatch, ownProps) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> bindActionCreators(&#123;</span><br><span class=\"line\">    increase: action.increase,</span><br><span class=\"line\">    decrease: action.decrease</span><br><span class=\"line\">  &#125;, dispatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 返回跟上面一样的object */</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   increase: (...args) =&gt; dispatch(action.increase(...args)),</span><br><span class=\"line\">   decrease: (...args) =&gt; dispatch(action.decrease(...args)),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果mapDispatchToProps是一个函数, 并且传入ownProps, 当组件获取新的props的时候，mapDispatchToProps也会被调用.</li>\n<li>传入一个object，其中这个object所对应的value必须是actionCreator，这样redux里面会自动帮我们调用bindActionCreator，所以上面又可以变成</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mapDispatchToProps = &#123;</span><br><span class=\"line\">    ...action</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h5><p><a href=\"https://imweb.io/topic/5a426d32a192c3b460fce354\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/5a426d32a192c3b460fce354</a></p>\n<h3 id=\"antd\"><a href=\"#antd\" class=\"headerlink\" title=\"antd\"></a>antd</h3><h4 id=\"CheckBox\"><a href=\"#CheckBox\" class=\"headerlink\" title=\"CheckBox\"></a>CheckBox</h4><ul>\n<li>描述： form.resetFields时，不能重置checkbox</li>\n<li>解决办法：在getFieldDecorator(key, options)的options里添加{valuePropName: ‘checked’}</li>\n</ul>\n<h4 id=\"rangePicker\"><a href=\"#rangePicker\" class=\"headerlink\" title=\"rangePicker\"></a>rangePicker</h4><ul>\n<li>默认时间不显示</li>\n<li>解决办法：用initialValue而不是defaultValue更不是defaultPickerValue</li>\n</ul>\n<h4 id=\"小常识\"><a href=\"#小常识\" class=\"headerlink\" title=\"小常识\"></a>小常识</h4><p>被form.create()包裹的组件，当form控件的的值方式变化的时候，会触发自定义组件的rerender。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>将项目里遇到的坑，或者说一些优秀的想法记下来</p>\n</blockquote>","more":"<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>import(‘/src/nav.js’)是import的动态用法，返回值是一个promise，resolve的形如{ default: nav, __esModule: true }</p>\n<h3 id=\"asyncComponent\"><a href=\"#asyncComponent\" class=\"headerlink\" title=\"asyncComponent\"></a>asyncComponent</h3><p>对于加载页面时，并未立即显示的组件，可以采用异步组件的模式按需加载。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> loadComponent(getComponent)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> class AsyncComponent extend PureComponent&#123;</span><br><span class=\"line\">        static AsyComponent = null;</span><br><span class=\"line\">        state = &#123;</span><br><span class=\"line\">            AsyComponent : AsyncComponent.AsyComponent</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">componentDidMount</span></span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!this.state.AsyComponent)&#123;</span><br><span class=\"line\">                getComponent().<span class=\"keyword\">then</span>((&#123; default: Component &#125;) =&gt; &#123;</span><br><span class=\"line\">                    this.setState(&#123;</span><br><span class=\"line\">                        AsyComponent: Component</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">render</span></span>()&#123;</span><br><span class=\"line\">            const &#123; AsyComponent &#125; = this.state;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> (</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(AsyComponent)&#123;</span><br><span class=\"line\">                    &lt;AsyComponent/&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">return</span> &lt;Spin title=<span class=\"string\">'加载中....'</span>/&gt;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapDispatchToProps\"><a href=\"#mapDispatchToProps\" class=\"headerlink\" title=\"mapDispatchToProps\"></a>mapDispatchToProps</h3><ul>\n<li>mapDispatchToProps用于建立组件跟store.dispatch的映射关系</li>\n<li>可以是一个object，也可以传入函数</li>\n<li>如果mapDispatchToProps是一个函数，它可以传入dispatch,ownProps, 定义UI组件如何发出action，实际上就是要调用dispatch这个方法</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 假设actions是一个import进来的值为actionCreator的object */</span><br><span class=\"line\">action.increase = <span class=\"keyword\">function</span> (info) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">type</span>:<span class=\"string\">'INCREASE'</span>，</span><br><span class=\"line\">        info</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">    increase: (...args) =&gt; dispatch(actions.increase(...args)),</span><br><span class=\"line\">    decrease: (...args) =&gt; dispatch(actions.decrease(...args))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用actions.increase()只能得到一个 action对象{type:’INCREASE’} ，要触发这个 action必须在store 上调用 dispatch 方法。 diapatch正是 mapDispatchToProps的第一个参数。但是，为了不让 组件感知到 dispatch 的存在，需要将increase 和 decrease 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 dispatch ）。</p>\n<h4 id=\"bindActionCreator\"><a href=\"#bindActionCreator\" class=\"headerlink\" title=\"bindActionCreator\"></a>bindActionCreator</h4><p>bindActionCreator可以将action包装成可以被调用的函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;bindActionCreators&#125; from <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapDispatchToProps = &#123;</span><br><span class=\"line\">&#125; = (dispatch, ownProps) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> bindActionCreators(&#123;</span><br><span class=\"line\">    increase: action.increase,</span><br><span class=\"line\">    decrease: action.decrease</span><br><span class=\"line\">  &#125;, dispatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 返回跟上面一样的object */</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   increase: (...args) =&gt; dispatch(action.increase(...args)),</span><br><span class=\"line\">   decrease: (...args) =&gt; dispatch(action.decrease(...args)),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果mapDispatchToProps是一个函数, 并且传入ownProps, 当组件获取新的props的时候，mapDispatchToProps也会被调用.</li>\n<li>传入一个object，其中这个object所对应的value必须是actionCreator，这样redux里面会自动帮我们调用bindActionCreator，所以上面又可以变成</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mapDispatchToProps = &#123;</span><br><span class=\"line\">    ...action</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h5><p><a href=\"https://imweb.io/topic/5a426d32a192c3b460fce354\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/5a426d32a192c3b460fce354</a></p>\n<h3 id=\"antd\"><a href=\"#antd\" class=\"headerlink\" title=\"antd\"></a>antd</h3><h4 id=\"CheckBox\"><a href=\"#CheckBox\" class=\"headerlink\" title=\"CheckBox\"></a>CheckBox</h4><ul>\n<li>描述： form.resetFields时，不能重置checkbox</li>\n<li>解决办法：在getFieldDecorator(key, options)的options里添加{valuePropName: ‘checked’}</li>\n</ul>\n<h4 id=\"rangePicker\"><a href=\"#rangePicker\" class=\"headerlink\" title=\"rangePicker\"></a>rangePicker</h4><ul>\n<li>默认时间不显示</li>\n<li>解决办法：用initialValue而不是defaultValue更不是defaultPickerValue</li>\n</ul>\n<h4 id=\"小常识\"><a href=\"#小常识\" class=\"headerlink\" title=\"小常识\"></a>小常识</h4><p>被form.create()包裹的组件，当form控件的的值方式变化的时候，会触发自定义组件的rerender。</p>"},{"title":"git杂记","date":"2018-12-07T08:33:09.000Z","_content":"\n不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。\n<!--more-->\n\n### git的三个区域\n\n+ 工作区，就是在编辑器里看到的那些代码\n+ 缓存区，通过git add将指定文件添加到此区域\n+ 版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。\n\n### commitID\n形如 1953***6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  --oneline\n\n### 一些常用的命令\n#### git status (gst)\n当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。\n#### git branch  \n查看本地分支已经存在的分支，当前分支带*。\n+ -r 查看远程分支\n+ dev 加分支名，创建分支dev\n+ -d dev 删除分支dev\n\n#### git checkout\n+ dev 切换到dev分支上，然后更新工作目录。\n\n+ -b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。\n\n+ commitID file\n  查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。\n\n+ commitID\n  更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。\n\n+ -b dev origin/dev\n\t将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。\n\n+ -track origin/dev\n    创建本地分支并关联\n#### git stash\n如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。\n\n### git pull\n将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）\n\n### git  revert\n\nRevert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。\n\n### git  reset\n这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br>\n如果你加上--hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。\n\n|命令      |作用域 |               常用场景           |\n|------|--|----|\n|git reset|提交层面|\t在私有分支上舍弃一些没有提交的更改|\n|git reset|\t|文件层面|\t将文件从缓存区中移除|\n|git checkout|\t提交层面|\t切换分支或查看旧版本|\n|git checkout|\t文件层面|\t舍弃工作目录中的更改|\n|git revert     |\t提交层面|\t在公共分支上回滚更改|\n\n\n+ [git好文](https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md)\n\n+ [一个有意思的学习git的网站](https://learngitbranching.js.org)\n\n","source":"_posts/杂记-git杂记.md","raw":"---\ntitle: git杂记\ndate: 2018-12-07 16:33:09\ntags: 杂记\n---\n\n不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。\n<!--more-->\n\n### git的三个区域\n\n+ 工作区，就是在编辑器里看到的那些代码\n+ 缓存区，通过git add将指定文件添加到此区域\n+ 版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。\n\n### commitID\n形如 1953***6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  --oneline\n\n### 一些常用的命令\n#### git status (gst)\n当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。\n#### git branch  \n查看本地分支已经存在的分支，当前分支带*。\n+ -r 查看远程分支\n+ dev 加分支名，创建分支dev\n+ -d dev 删除分支dev\n\n#### git checkout\n+ dev 切换到dev分支上，然后更新工作目录。\n\n+ -b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。\n\n+ commitID file\n  查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。\n\n+ commitID\n  更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。\n\n+ -b dev origin/dev\n\t将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。\n\n+ -track origin/dev\n    创建本地分支并关联\n#### git stash\n如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。\n\n### git pull\n将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）\n\n### git  revert\n\nRevert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。\n\n### git  reset\n这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br>\n如果你加上--hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。\n\n|命令      |作用域 |               常用场景           |\n|------|--|----|\n|git reset|提交层面|\t在私有分支上舍弃一些没有提交的更改|\n|git reset|\t|文件层面|\t将文件从缓存区中移除|\n|git checkout|\t提交层面|\t切换分支或查看旧版本|\n|git checkout|\t文件层面|\t舍弃工作目录中的更改|\n|git revert     |\t提交层面|\t在公共分支上回滚更改|\n\n\n+ [git好文](https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md)\n\n+ [一个有意思的学习git的网站](https://learngitbranching.js.org)\n\n","slug":"杂记-git杂记","published":1,"updated":"2019-09-17T02:39:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8x001kkwfyg36486jf","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。<br><a id=\"more\"></a></p>\n<h3 id=\"git的三个区域\"><a href=\"#git的三个区域\" class=\"headerlink\" title=\"git的三个区域\"></a>git的三个区域</h3><ul>\n<li>工作区，就是在编辑器里看到的那些代码</li>\n<li>缓存区，通过git add将指定文件添加到此区域</li>\n<li>版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。</li>\n</ul>\n<h3 id=\"commitID\"><a href=\"#commitID\" class=\"headerlink\" title=\"commitID\"></a>commitID</h3><p>形如 1953***6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  –oneline</p>\n<h3 id=\"一些常用的命令\"><a href=\"#一些常用的命令\" class=\"headerlink\" title=\"一些常用的命令\"></a>一些常用的命令</h3><h4 id=\"git-status-gst\"><a href=\"#git-status-gst\" class=\"headerlink\" title=\"git status (gst)\"></a>git status (gst)</h4><p>当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。</p>\n<h4 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h4><p>查看本地分支已经存在的分支，当前分支带*。</p>\n<ul>\n<li>-r 查看远程分支</li>\n<li>dev 加分支名，创建分支dev</li>\n<li>-d dev 删除分支dev</li>\n</ul>\n<h4 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h4><ul>\n<li><p>dev 切换到dev分支上，然后更新工作目录。</p>\n</li>\n<li><p>-b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。</p>\n</li>\n<li><p>commitID file<br>查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。</p>\n</li>\n<li><p>commitID<br>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。</p>\n</li>\n<li><p>-b dev origin/dev<br>  将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。</p>\n</li>\n<li><p>-track origin/dev<br>  创建本地分支并关联</p>\n<h4 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h4><p>如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。</p>\n</li>\n</ul>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><p>将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）</p>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git  revert\"></a>git  revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git  reset\"></a>git  reset</h3><p>这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br><br>如果你加上–hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用域</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git reset</td>\n<td>提交层面</td>\n<td>在私有分支上舍弃一些没有提交的更改</td>\n</tr>\n<tr>\n<td>git reset</td>\n<td></td>\n<td>文件层面</td>\n<td>将文件从缓存区中移除</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>提交层面</td>\n<td>切换分支或查看旧版本</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>文件层面</td>\n<td>舍弃工作目录中的更改</td>\n</tr>\n<tr>\n<td>git revert</td>\n<td>提交层面</td>\n<td>在公共分支上回滚更改</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><a href=\"https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md\" target=\"_blank\" rel=\"noopener\">git好文</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org\" target=\"_blank\" rel=\"noopener\">一个有意思的学习git的网站</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。<br>","more":"</p>\n<h3 id=\"git的三个区域\"><a href=\"#git的三个区域\" class=\"headerlink\" title=\"git的三个区域\"></a>git的三个区域</h3><ul>\n<li>工作区，就是在编辑器里看到的那些代码</li>\n<li>缓存区，通过git add将指定文件添加到此区域</li>\n<li>版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。</li>\n</ul>\n<h3 id=\"commitID\"><a href=\"#commitID\" class=\"headerlink\" title=\"commitID\"></a>commitID</h3><p>形如 1953***6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  –oneline</p>\n<h3 id=\"一些常用的命令\"><a href=\"#一些常用的命令\" class=\"headerlink\" title=\"一些常用的命令\"></a>一些常用的命令</h3><h4 id=\"git-status-gst\"><a href=\"#git-status-gst\" class=\"headerlink\" title=\"git status (gst)\"></a>git status (gst)</h4><p>当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。</p>\n<h4 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h4><p>查看本地分支已经存在的分支，当前分支带*。</p>\n<ul>\n<li>-r 查看远程分支</li>\n<li>dev 加分支名，创建分支dev</li>\n<li>-d dev 删除分支dev</li>\n</ul>\n<h4 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h4><ul>\n<li><p>dev 切换到dev分支上，然后更新工作目录。</p>\n</li>\n<li><p>-b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。</p>\n</li>\n<li><p>commitID file<br>查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。</p>\n</li>\n<li><p>commitID<br>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。</p>\n</li>\n<li><p>-b dev origin/dev<br>  将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。</p>\n</li>\n<li><p>-track origin/dev<br>  创建本地分支并关联</p>\n<h4 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h4><p>如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。</p>\n</li>\n</ul>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><p>将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）</p>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git  revert\"></a>git  revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git  reset\"></a>git  reset</h3><p>这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br><br>如果你加上–hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用域</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git reset</td>\n<td>提交层面</td>\n<td>在私有分支上舍弃一些没有提交的更改</td>\n</tr>\n<tr>\n<td>git reset</td>\n<td></td>\n<td>文件层面</td>\n<td>将文件从缓存区中移除</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>提交层面</td>\n<td>切换分支或查看旧版本</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>文件层面</td>\n<td>舍弃工作目录中的更改</td>\n</tr>\n<tr>\n<td>git revert</td>\n<td>提交层面</td>\n<td>在公共分支上回滚更改</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><a href=\"https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md\" target=\"_blank\" rel=\"noopener\">git好文</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org\" target=\"_blank\" rel=\"noopener\">一个有意思的学习git的网站</a></p>\n</li>\n</ul>"},{"title":"Quic","date":"2019-08-07T08:27:47.000Z","_content":">Google家是真的DIAO啊，掌控了http的发展啊。\n\n### Quic简述\nQuic 全称 quick udp internet connection，“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。\n\n### 为啥需要Quic\n为毛需要Quic，因为http2.0有一些硬伤难以解决，啥硬伤呢？就是TCP。<br>\n经过几十年的经验累积，网络工程师对怎么优化网络访问，降低延迟也有了新的认知，于是就想着更新 TCP 协议，但是 TCP 的更新非常困难，因为网络协议栈的实现本来就依赖系统内核更新，而不管是终端设备，中间设备的系统更新都极其缓慢，一个更新迭代可能需要5-15年的时间去普及，对于现在的互联网发展来说太慢了。\n\n所以 TCP 的硬伤总结一下就是：TCP的更新优化需要依赖系统内核更新。\n\n\n#### 基础环境的不match\n##### 中间设备的僵化\n目前，我们很多中间设备，比如防火墙、NAT网关等出现了一些默认的动作。\n\n比如防火墙只允许通过80和443，不放通其他端口。NAT 网关在转换网络地址时重写传输层的头部，有可能导致双方无法使用新的传输格式。整流器和中间代理有时候出于安全的需要，会删除一些它们不认识的选项字段。\nTCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。\n\n而这些干扰，也导致很多在 TCP 协议上的优化变得小心谨慎，步履维艰。\n\n##### 依赖于操作系统的实现导致协议僵化\nTCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。\n\n现在移动终端更加流行，但是移动端部分用户的操作系统升级依然可能滞后数年时间。PC 端的系统升级滞后得更加严重，windows xp 现在还有大量用户在使用，尽管它已经存在快 20 年。\n\n服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。\n\n这也就意味着即使 TCP 有比较好的特性更新，也很难快速推广。比如 TCP Fast Open。它虽然 2013 年就被提出了，但是 Windows 很多系统版本依然不支持它。\n#### 连接建立快\n现在，网络建立在TCP之上，因为它作为传输协议的可靠性。要启动TCP连接，将执行3次握手。这意味着每个起始连接的额外往返（网络数据包来回发送）会增加任何新连接的显着延迟。另外，如果还需要TLS创建安全加密的https连接，则需要发送更多的网络数据包。\n\n当客户端首次发起QUIC连接时，客户端想服务器发送一个client hello消息，服务器回复一个server reject消息。该消息中有包括server config，类似于TLS1.3中的key_share交换。这需要产生1-RTT. 事实上，QUIC加密协议的作者也明确指出当前的QUIC加密协议是「注定要死掉的」(destined to die), 未来将会被TLS1.3代替。只是在QUIC提出来的时候，TLS1.3还没出生😂，这只是一个临时的加密方案。\n\n当客户端获取到server config以后，就可以直接计算出密钥，发送应用数据了，可以认为是0-RTT。因此，QUIC握手除去首次连接需要产生1-RTT，理论上，后续握手都是0-RTT的。假设1-RTT=100ms, QUIC建立安全连接连接的握手开销为0ms, 功能上等价于TCP+TLS, 但是握手开销比建立普通的TCP连接延迟都低。\n#### 更高效的拥塞控制\n\n目前的 QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。\n\n比如单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。\n\n> 具体改进可以参考[这篇文章](https://zhuanlan.zhihu.com/p/32553477)\n\nQUIC 拥塞控制算法主要重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的。\n\n#### 可插拔\n\n什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：\n\n1. 应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。\n2. 即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。\n3. 应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。\nSTGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。\n#### 前向纠错\n\nQUIC的一个很好的功能是FEC或前向纠错。发送的每个数据包还包括其他数据包的足够数据，以便可以重建丢失的数据包而无需重新传输。\n\n这实际上是网络级别的RAID 5。\n\n因此，需要进行权衡：每个UDP数据包包含的负载超出了严格必要的数量，因为它可以解决丢失数据包的可能性，这种数据包可以更容易地以这种方式重新创建。\n\n当前比率似乎约为10个数据包。因此，对于每发送10个UDP数据包，有足够的数据来重建丢失的数据包。如果你愿意，可以节省10％的开销。\n\n将前向纠错视为可以发送的“每UDP数据包数据”的牺牲，但增益不必重新发送丢失的数据包，这将花费更长的时间（收件人必须确认丢失的数据包，请求它再次等待回应）。\n#### 会话恢复和并行下载\n\n在TCP中，需要四个参数建立连接，源IP、源端口和目的IP、目的端口。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。\n使用QUIC，因为它现在使用UDP，所以没有四元组。\n\nQUIC为称为Connection UUID的唯一连接实现了自己的标识符。从WiFi到LTE仍然可以保持连接UUID，因此无需重新协商连接或TLS。之前的连接仍然有效。\n\n这与Mosh Shell的工作方式相同，通过UDP保持SSH连接，以获得更好的漫游和移动体验。\n\n这也打开了使用多个来源获取内容的大门。如果可以通过WiFi 和蜂窝连接共享连接UUID ，理论上可以使用两种媒体来下载内容。用户可以使用拥有的每个可用界面并行地有效地流式传输或下载内容。\n\n虽然仍然是理论上的，但UDP允许这种创新。\n\n参考连接[https://zhuanlan.zhihu.com/p/32553477](https://zhuanlan.zhihu.com/p/32553477)","source":"_posts/网络-Quic.md","raw":"---\ntitle: Quic\ndate: 2019-08-07 16:27:47\ntags: 学习\ncategories:\n---\n>Google家是真的DIAO啊，掌控了http的发展啊。\n\n### Quic简述\nQuic 全称 quick udp internet connection，“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。\n\n### 为啥需要Quic\n为毛需要Quic，因为http2.0有一些硬伤难以解决，啥硬伤呢？就是TCP。<br>\n经过几十年的经验累积，网络工程师对怎么优化网络访问，降低延迟也有了新的认知，于是就想着更新 TCP 协议，但是 TCP 的更新非常困难，因为网络协议栈的实现本来就依赖系统内核更新，而不管是终端设备，中间设备的系统更新都极其缓慢，一个更新迭代可能需要5-15年的时间去普及，对于现在的互联网发展来说太慢了。\n\n所以 TCP 的硬伤总结一下就是：TCP的更新优化需要依赖系统内核更新。\n\n\n#### 基础环境的不match\n##### 中间设备的僵化\n目前，我们很多中间设备，比如防火墙、NAT网关等出现了一些默认的动作。\n\n比如防火墙只允许通过80和443，不放通其他端口。NAT 网关在转换网络地址时重写传输层的头部，有可能导致双方无法使用新的传输格式。整流器和中间代理有时候出于安全的需要，会删除一些它们不认识的选项字段。\nTCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。\n\n而这些干扰，也导致很多在 TCP 协议上的优化变得小心谨慎，步履维艰。\n\n##### 依赖于操作系统的实现导致协议僵化\nTCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。\n\n现在移动终端更加流行，但是移动端部分用户的操作系统升级依然可能滞后数年时间。PC 端的系统升级滞后得更加严重，windows xp 现在还有大量用户在使用，尽管它已经存在快 20 年。\n\n服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。\n\n这也就意味着即使 TCP 有比较好的特性更新，也很难快速推广。比如 TCP Fast Open。它虽然 2013 年就被提出了，但是 Windows 很多系统版本依然不支持它。\n#### 连接建立快\n现在，网络建立在TCP之上，因为它作为传输协议的可靠性。要启动TCP连接，将执行3次握手。这意味着每个起始连接的额外往返（网络数据包来回发送）会增加任何新连接的显着延迟。另外，如果还需要TLS创建安全加密的https连接，则需要发送更多的网络数据包。\n\n当客户端首次发起QUIC连接时，客户端想服务器发送一个client hello消息，服务器回复一个server reject消息。该消息中有包括server config，类似于TLS1.3中的key_share交换。这需要产生1-RTT. 事实上，QUIC加密协议的作者也明确指出当前的QUIC加密协议是「注定要死掉的」(destined to die), 未来将会被TLS1.3代替。只是在QUIC提出来的时候，TLS1.3还没出生😂，这只是一个临时的加密方案。\n\n当客户端获取到server config以后，就可以直接计算出密钥，发送应用数据了，可以认为是0-RTT。因此，QUIC握手除去首次连接需要产生1-RTT，理论上，后续握手都是0-RTT的。假设1-RTT=100ms, QUIC建立安全连接连接的握手开销为0ms, 功能上等价于TCP+TLS, 但是握手开销比建立普通的TCP连接延迟都低。\n#### 更高效的拥塞控制\n\n目前的 QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。\n\n比如单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。\n\n> 具体改进可以参考[这篇文章](https://zhuanlan.zhihu.com/p/32553477)\n\nQUIC 拥塞控制算法主要重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的。\n\n#### 可插拔\n\n什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：\n\n1. 应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。\n2. 即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。\n3. 应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。\nSTGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。\n#### 前向纠错\n\nQUIC的一个很好的功能是FEC或前向纠错。发送的每个数据包还包括其他数据包的足够数据，以便可以重建丢失的数据包而无需重新传输。\n\n这实际上是网络级别的RAID 5。\n\n因此，需要进行权衡：每个UDP数据包包含的负载超出了严格必要的数量，因为它可以解决丢失数据包的可能性，这种数据包可以更容易地以这种方式重新创建。\n\n当前比率似乎约为10个数据包。因此，对于每发送10个UDP数据包，有足够的数据来重建丢失的数据包。如果你愿意，可以节省10％的开销。\n\n将前向纠错视为可以发送的“每UDP数据包数据”的牺牲，但增益不必重新发送丢失的数据包，这将花费更长的时间（收件人必须确认丢失的数据包，请求它再次等待回应）。\n#### 会话恢复和并行下载\n\n在TCP中，需要四个参数建立连接，源IP、源端口和目的IP、目的端口。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。\n使用QUIC，因为它现在使用UDP，所以没有四元组。\n\nQUIC为称为Connection UUID的唯一连接实现了自己的标识符。从WiFi到LTE仍然可以保持连接UUID，因此无需重新协商连接或TLS。之前的连接仍然有效。\n\n这与Mosh Shell的工作方式相同，通过UDP保持SSH连接，以获得更好的漫游和移动体验。\n\n这也打开了使用多个来源获取内容的大门。如果可以通过WiFi 和蜂窝连接共享连接UUID ，理论上可以使用两种媒体来下载内容。用户可以使用拥有的每个可用界面并行地有效地流式传输或下载内容。\n\n虽然仍然是理论上的，但UDP允许这种创新。\n\n参考连接[https://zhuanlan.zhihu.com/p/32553477](https://zhuanlan.zhihu.com/p/32553477)","slug":"网络-Quic","published":1,"updated":"2019-09-17T02:41:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rv8y001nkwfyaomroyk5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>Google家是真的DIAO啊，掌控了http的发展啊。</p>\n</blockquote>\n<h3 id=\"Quic简述\"><a href=\"#Quic简述\" class=\"headerlink\" title=\"Quic简述\"></a>Quic简述</h3><p>Quic 全称 quick udp internet connection，“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。</p>\n<h3 id=\"为啥需要Quic\"><a href=\"#为啥需要Quic\" class=\"headerlink\" title=\"为啥需要Quic\"></a>为啥需要Quic</h3><p>为毛需要Quic，因为http2.0有一些硬伤难以解决，啥硬伤呢？就是TCP。<br><br>经过几十年的经验累积，网络工程师对怎么优化网络访问，降低延迟也有了新的认知，于是就想着更新 TCP 协议，但是 TCP 的更新非常困难，因为网络协议栈的实现本来就依赖系统内核更新，而不管是终端设备，中间设备的系统更新都极其缓慢，一个更新迭代可能需要5-15年的时间去普及，对于现在的互联网发展来说太慢了。</p>\n<p>所以 TCP 的硬伤总结一下就是：TCP的更新优化需要依赖系统内核更新。</p>\n<h4 id=\"基础环境的不match\"><a href=\"#基础环境的不match\" class=\"headerlink\" title=\"基础环境的不match\"></a>基础环境的不match</h4><h5 id=\"中间设备的僵化\"><a href=\"#中间设备的僵化\" class=\"headerlink\" title=\"中间设备的僵化\"></a>中间设备的僵化</h5><p>目前，我们很多中间设备，比如防火墙、NAT网关等出现了一些默认的动作。</p>\n<p>比如防火墙只允许通过80和443，不放通其他端口。NAT 网关在转换网络地址时重写传输层的头部，有可能导致双方无法使用新的传输格式。整流器和中间代理有时候出于安全的需要，会删除一些它们不认识的选项字段。<br>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p>\n<p>而这些干扰，也导致很多在 TCP 协议上的优化变得小心谨慎，步履维艰。</p>\n<h5 id=\"依赖于操作系统的实现导致协议僵化\"><a href=\"#依赖于操作系统的实现导致协议僵化\" class=\"headerlink\" title=\"依赖于操作系统的实现导致协议僵化\"></a>依赖于操作系统的实现导致协议僵化</h5><p>TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。</p>\n<p>现在移动终端更加流行，但是移动端部分用户的操作系统升级依然可能滞后数年时间。PC 端的系统升级滞后得更加严重，windows xp 现在还有大量用户在使用，尽管它已经存在快 20 年。</p>\n<p>服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。</p>\n<p>这也就意味着即使 TCP 有比较好的特性更新，也很难快速推广。比如 TCP Fast Open。它虽然 2013 年就被提出了，但是 Windows 很多系统版本依然不支持它。</p>\n<h4 id=\"连接建立快\"><a href=\"#连接建立快\" class=\"headerlink\" title=\"连接建立快\"></a>连接建立快</h4><p>现在，网络建立在TCP之上，因为它作为传输协议的可靠性。要启动TCP连接，将执行3次握手。这意味着每个起始连接的额外往返（网络数据包来回发送）会增加任何新连接的显着延迟。另外，如果还需要TLS创建安全加密的https连接，则需要发送更多的网络数据包。</p>\n<p>当客户端首次发起QUIC连接时，客户端想服务器发送一个client hello消息，服务器回复一个server reject消息。该消息中有包括server config，类似于TLS1.3中的key_share交换。这需要产生1-RTT. 事实上，QUIC加密协议的作者也明确指出当前的QUIC加密协议是「注定要死掉的」(destined to die), 未来将会被TLS1.3代替。只是在QUIC提出来的时候，TLS1.3还没出生😂，这只是一个临时的加密方案。</p>\n<p>当客户端获取到server config以后，就可以直接计算出密钥，发送应用数据了，可以认为是0-RTT。因此，QUIC握手除去首次连接需要产生1-RTT，理论上，后续握手都是0-RTT的。假设1-RTT=100ms, QUIC建立安全连接连接的握手开销为0ms, 功能上等价于TCP+TLS, 但是握手开销比建立普通的TCP连接延迟都低。</p>\n<h4 id=\"更高效的拥塞控制\"><a href=\"#更高效的拥塞控制\" class=\"headerlink\" title=\"更高效的拥塞控制\"></a>更高效的拥塞控制</h4><p>目前的 QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。</p>\n<p>比如单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。</p>\n<blockquote>\n<p>具体改进可以参考<a href=\"https://zhuanlan.zhihu.com/p/32553477\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n</blockquote>\n<p>QUIC 拥塞控制算法主要重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的。</p>\n<h4 id=\"可插拔\"><a href=\"#可插拔\" class=\"headerlink\" title=\"可插拔\"></a>可插拔</h4><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：</p>\n<ol>\n<li>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</li>\n<li>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</li>\n<li>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。<br>STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。<h4 id=\"前向纠错\"><a href=\"#前向纠错\" class=\"headerlink\" title=\"前向纠错\"></a>前向纠错</h4></li>\n</ol>\n<p>QUIC的一个很好的功能是FEC或前向纠错。发送的每个数据包还包括其他数据包的足够数据，以便可以重建丢失的数据包而无需重新传输。</p>\n<p>这实际上是网络级别的RAID 5。</p>\n<p>因此，需要进行权衡：每个UDP数据包包含的负载超出了严格必要的数量，因为它可以解决丢失数据包的可能性，这种数据包可以更容易地以这种方式重新创建。</p>\n<p>当前比率似乎约为10个数据包。因此，对于每发送10个UDP数据包，有足够的数据来重建丢失的数据包。如果你愿意，可以节省10％的开销。</p>\n<p>将前向纠错视为可以发送的“每UDP数据包数据”的牺牲，但增益不必重新发送丢失的数据包，这将花费更长的时间（收件人必须确认丢失的数据包，请求它再次等待回应）。</p>\n<h4 id=\"会话恢复和并行下载\"><a href=\"#会话恢复和并行下载\" class=\"headerlink\" title=\"会话恢复和并行下载\"></a>会话恢复和并行下载</h4><p>在TCP中，需要四个参数建立连接，源IP、源端口和目的IP、目的端口。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。<br>使用QUIC，因为它现在使用UDP，所以没有四元组。</p>\n<p>QUIC为称为Connection UUID的唯一连接实现了自己的标识符。从WiFi到LTE仍然可以保持连接UUID，因此无需重新协商连接或TLS。之前的连接仍然有效。</p>\n<p>这与Mosh Shell的工作方式相同，通过UDP保持SSH连接，以获得更好的漫游和移动体验。</p>\n<p>这也打开了使用多个来源获取内容的大门。如果可以通过WiFi 和蜂窝连接共享连接UUID ，理论上可以使用两种媒体来下载内容。用户可以使用拥有的每个可用界面并行地有效地流式传输或下载内容。</p>\n<p>虽然仍然是理论上的，但UDP允许这种创新。</p>\n<p>参考连接<a href=\"https://zhuanlan.zhihu.com/p/32553477\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/32553477</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Google家是真的DIAO啊，掌控了http的发展啊。</p>\n</blockquote>\n<h3 id=\"Quic简述\"><a href=\"#Quic简述\" class=\"headerlink\" title=\"Quic简述\"></a>Quic简述</h3><p>Quic 全称 quick udp internet connection，“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。</p>\n<h3 id=\"为啥需要Quic\"><a href=\"#为啥需要Quic\" class=\"headerlink\" title=\"为啥需要Quic\"></a>为啥需要Quic</h3><p>为毛需要Quic，因为http2.0有一些硬伤难以解决，啥硬伤呢？就是TCP。<br><br>经过几十年的经验累积，网络工程师对怎么优化网络访问，降低延迟也有了新的认知，于是就想着更新 TCP 协议，但是 TCP 的更新非常困难，因为网络协议栈的实现本来就依赖系统内核更新，而不管是终端设备，中间设备的系统更新都极其缓慢，一个更新迭代可能需要5-15年的时间去普及，对于现在的互联网发展来说太慢了。</p>\n<p>所以 TCP 的硬伤总结一下就是：TCP的更新优化需要依赖系统内核更新。</p>\n<h4 id=\"基础环境的不match\"><a href=\"#基础环境的不match\" class=\"headerlink\" title=\"基础环境的不match\"></a>基础环境的不match</h4><h5 id=\"中间设备的僵化\"><a href=\"#中间设备的僵化\" class=\"headerlink\" title=\"中间设备的僵化\"></a>中间设备的僵化</h5><p>目前，我们很多中间设备，比如防火墙、NAT网关等出现了一些默认的动作。</p>\n<p>比如防火墙只允许通过80和443，不放通其他端口。NAT 网关在转换网络地址时重写传输层的头部，有可能导致双方无法使用新的传输格式。整流器和中间代理有时候出于安全的需要，会删除一些它们不认识的选项字段。<br>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p>\n<p>而这些干扰，也导致很多在 TCP 协议上的优化变得小心谨慎，步履维艰。</p>\n<h5 id=\"依赖于操作系统的实现导致协议僵化\"><a href=\"#依赖于操作系统的实现导致协议僵化\" class=\"headerlink\" title=\"依赖于操作系统的实现导致协议僵化\"></a>依赖于操作系统的实现导致协议僵化</h5><p>TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。</p>\n<p>现在移动终端更加流行，但是移动端部分用户的操作系统升级依然可能滞后数年时间。PC 端的系统升级滞后得更加严重，windows xp 现在还有大量用户在使用，尽管它已经存在快 20 年。</p>\n<p>服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。</p>\n<p>这也就意味着即使 TCP 有比较好的特性更新，也很难快速推广。比如 TCP Fast Open。它虽然 2013 年就被提出了，但是 Windows 很多系统版本依然不支持它。</p>\n<h4 id=\"连接建立快\"><a href=\"#连接建立快\" class=\"headerlink\" title=\"连接建立快\"></a>连接建立快</h4><p>现在，网络建立在TCP之上，因为它作为传输协议的可靠性。要启动TCP连接，将执行3次握手。这意味着每个起始连接的额外往返（网络数据包来回发送）会增加任何新连接的显着延迟。另外，如果还需要TLS创建安全加密的https连接，则需要发送更多的网络数据包。</p>\n<p>当客户端首次发起QUIC连接时，客户端想服务器发送一个client hello消息，服务器回复一个server reject消息。该消息中有包括server config，类似于TLS1.3中的key_share交换。这需要产生1-RTT. 事实上，QUIC加密协议的作者也明确指出当前的QUIC加密协议是「注定要死掉的」(destined to die), 未来将会被TLS1.3代替。只是在QUIC提出来的时候，TLS1.3还没出生😂，这只是一个临时的加密方案。</p>\n<p>当客户端获取到server config以后，就可以直接计算出密钥，发送应用数据了，可以认为是0-RTT。因此，QUIC握手除去首次连接需要产生1-RTT，理论上，后续握手都是0-RTT的。假设1-RTT=100ms, QUIC建立安全连接连接的握手开销为0ms, 功能上等价于TCP+TLS, 但是握手开销比建立普通的TCP连接延迟都低。</p>\n<h4 id=\"更高效的拥塞控制\"><a href=\"#更高效的拥塞控制\" class=\"headerlink\" title=\"更高效的拥塞控制\"></a>更高效的拥塞控制</h4><p>目前的 QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。</p>\n<p>比如单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。</p>\n<blockquote>\n<p>具体改进可以参考<a href=\"https://zhuanlan.zhihu.com/p/32553477\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n</blockquote>\n<p>QUIC 拥塞控制算法主要重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的。</p>\n<h4 id=\"可插拔\"><a href=\"#可插拔\" class=\"headerlink\" title=\"可插拔\"></a>可插拔</h4><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：</p>\n<ol>\n<li>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</li>\n<li>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</li>\n<li>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。<br>STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。<h4 id=\"前向纠错\"><a href=\"#前向纠错\" class=\"headerlink\" title=\"前向纠错\"></a>前向纠错</h4></li>\n</ol>\n<p>QUIC的一个很好的功能是FEC或前向纠错。发送的每个数据包还包括其他数据包的足够数据，以便可以重建丢失的数据包而无需重新传输。</p>\n<p>这实际上是网络级别的RAID 5。</p>\n<p>因此，需要进行权衡：每个UDP数据包包含的负载超出了严格必要的数量，因为它可以解决丢失数据包的可能性，这种数据包可以更容易地以这种方式重新创建。</p>\n<p>当前比率似乎约为10个数据包。因此，对于每发送10个UDP数据包，有足够的数据来重建丢失的数据包。如果你愿意，可以节省10％的开销。</p>\n<p>将前向纠错视为可以发送的“每UDP数据包数据”的牺牲，但增益不必重新发送丢失的数据包，这将花费更长的时间（收件人必须确认丢失的数据包，请求它再次等待回应）。</p>\n<h4 id=\"会话恢复和并行下载\"><a href=\"#会话恢复和并行下载\" class=\"headerlink\" title=\"会话恢复和并行下载\"></a>会话恢复和并行下载</h4><p>在TCP中，需要四个参数建立连接，源IP、源端口和目的IP、目的端口。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。<br>使用QUIC，因为它现在使用UDP，所以没有四元组。</p>\n<p>QUIC为称为Connection UUID的唯一连接实现了自己的标识符。从WiFi到LTE仍然可以保持连接UUID，因此无需重新协商连接或TLS。之前的连接仍然有效。</p>\n<p>这与Mosh Shell的工作方式相同，通过UDP保持SSH连接，以获得更好的漫游和移动体验。</p>\n<p>这也打开了使用多个来源获取内容的大门。如果可以通过WiFi 和蜂窝连接共享连接UUID ，理论上可以使用两种媒体来下载内容。用户可以使用拥有的每个可用界面并行地有效地流式传输或下载内容。</p>\n<p>虽然仍然是理论上的，但UDP允许这种创新。</p>\n<p>参考连接<a href=\"https://zhuanlan.zhihu.com/p/32553477\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/32553477</a></p>\n"},{"title":"渲染","date":"2019-09-17T02:36:53.000Z","_content":">本文是对浏览器工作原理与实践《我加书名号了》中渲染篇的总结，包括但不限于。\n<!--more-->\n\n先说一下浏览器，目前的浏览器都是多进程架构的。以chrome为例，它包括1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。\n其中：\n+ <strong>浏览器进程</strong>。主要负责界面显示、用户交互、自进程管理，同时提供存储等功能。\n+ <strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript转换成用户可以与之交互的页面，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n+ <strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的。\n+ <strong>GPU进程</strong>。用来绘制UI界面。\n+ <strong>插件进程</strong>。主要负责插件的运行，因插件已崩溃，所以需要通过插件进程来隔离。\n\n以前了解浏览器的渲染，我学到的是这样好的。\n![浏览器渲染过程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png)\n\n但是各种细节不是很清楚，这次做个总结。\n\n## DOM树生成\n+ 转换Bytes：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符\n\n+ Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\n\n+ Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则\n\n+ DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样\n\n## 样式计算\n\n样式计算分为以下三步\n\n### 将CSS转换为浏览器能够理解的结构\n\n来源：\n\n+ 通过link引用的外部CSS文件\n+ style标签引入的\n+ DOM的style属性内嵌的\n纯文本的CSS样式，浏览器是无法理解的，必须转换成StyleSheet\n\n### 转换样式表中的属性值，使其标准化\n\ncss的某些属性值，渲染引擎是不容易理解的，比如em，red， bold，这些会被转化成px，rgb以及700的形式。\n\n### 计算DOM树中每个节点的具体样式\n\n主要是通过继承和层叠来实线。\n\n+ 一个子元素的的样式可以从父元素继承而来，比如font-weight、font-family的font系列，text-align、line-height、color等文本系列，visibility以及cursor等。\n\n+ css有个优先级策略，比如!important>行内>id>class>Tag>*，统一等级的下面的会覆盖上面的。\n\n浏览器还有默认的userAgent。\n\n通过这两种方式累计计算Dom的样式。\n\n## 布局\n\n布局是计算出元素的可见位置，分为创建布局树和布局计算两步。\n\n### 创建布局树\n\n+ 遍历DOM树中的可见节点，并将节点加到布局树中\n\n+ 忽略不可见的元素，比如head标签里面的元素，display为none的元素。\n\n### 布局计算\n\n布局是一个递归的过程，这是因为一个节点的大小通常需要先计算他的自节点的位置、大小等信息。\n\n计算布局的主要过程是的RenderObject的layout函数来完成的，步骤大致如下：\n\n\n+ 通过检查位数组中的相应标记位、子元素是否需要计算布局来确定。\n\n+ 确定网页的宽度和垂直方向上的外边距，这是因为网页通常是在垂直方向上滚动，而水平方向上不需要滚动。？？？？\n\n+ 接着函数会便利其每一个子元素，以此计算他们的布局。如果元素定义了自身的狂傲，那么webkit按照定义的宽高来确定元素的大小，而对于像文本节点的內联元素则需要结合其字号大小及文字的多少等来确定其对应的狂傲，除非页面定义了页面元素的狂傲，一般来说页面元素的宽高是在布局的时候通过相关计算的出来的。如果有子元素，则递归这一过程。\n\n+ 最后，节点根据计算他的子女们的大小计算出自己的高度，整个过程结束。\n\n## 分层\n\n渲染引擎为特定节点创建新的层的条件（满足两点任意一点就行）\n\n+ 拥有层叠上下文，例如\n    + 根元素 (HTML),\n    + z-index 值不为 \"auto\"的 绝对/相对定位元素，\n    + 固定（fixed）/ 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）\n    + z-index值不为 \"auto\"的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex，\n    + z-index值不为“auto”的grid子项，即：父元素display：grid\n    + opacity 属性值小于 1 的元素（参考 the specification for opacity），\n    + mix-blend-mode 属性值不为 \"normal\"的元素，\n    + transform属性值不为“none”的元素 \n    + filter值不为“none”的元素，\n    + perspective值不为“none”的元素，\n    + clip-path值不为“none”的元素\n    + mask / mask-image / mask-border不为“none”的元素\n    + isolation 属性被设置为 \"isolate\"的元素\n    + 在 will-change 中指定了任意CSS属性（参考 这篇文章）\n    + -webkit-overflow-scrolling 属性被设置 \"touch\"的元素\n    + contain属性值为“layout”，“paint”，或者综合值比如“strict”，“content”\n\n\n+ 需要裁剪的地方\n\n## 图层绘制\n\n渲染引擎会把一个图层拆分成很多小的绘制指令，然后这些指令按照顺序组成一个待绘制列表。包含绘制的形状、绘制、样式等。\n\n## 栅格化（raster）操作\n\n在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。\n\n<p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512</p>\n\n<strong>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。\n\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n\n![](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)\n\n## 合成和显示\n\n<p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>","source":"_posts/浏览器-渲染.md","raw":"---\ntitle: 渲染\ndate: 2019-09-17 10:36:53\ntags: 浏览器\ncategories: 学习\n---\n>本文是对浏览器工作原理与实践《我加书名号了》中渲染篇的总结，包括但不限于。\n<!--more-->\n\n先说一下浏览器，目前的浏览器都是多进程架构的。以chrome为例，它包括1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。\n其中：\n+ <strong>浏览器进程</strong>。主要负责界面显示、用户交互、自进程管理，同时提供存储等功能。\n+ <strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript转换成用户可以与之交互的页面，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n+ <strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的。\n+ <strong>GPU进程</strong>。用来绘制UI界面。\n+ <strong>插件进程</strong>。主要负责插件的运行，因插件已崩溃，所以需要通过插件进程来隔离。\n\n以前了解浏览器的渲染，我学到的是这样好的。\n![浏览器渲染过程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png)\n\n但是各种细节不是很清楚，这次做个总结。\n\n## DOM树生成\n+ 转换Bytes：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符\n\n+ Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\n\n+ Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则\n\n+ DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样\n\n## 样式计算\n\n样式计算分为以下三步\n\n### 将CSS转换为浏览器能够理解的结构\n\n来源：\n\n+ 通过link引用的外部CSS文件\n+ style标签引入的\n+ DOM的style属性内嵌的\n纯文本的CSS样式，浏览器是无法理解的，必须转换成StyleSheet\n\n### 转换样式表中的属性值，使其标准化\n\ncss的某些属性值，渲染引擎是不容易理解的，比如em，red， bold，这些会被转化成px，rgb以及700的形式。\n\n### 计算DOM树中每个节点的具体样式\n\n主要是通过继承和层叠来实线。\n\n+ 一个子元素的的样式可以从父元素继承而来，比如font-weight、font-family的font系列，text-align、line-height、color等文本系列，visibility以及cursor等。\n\n+ css有个优先级策略，比如!important>行内>id>class>Tag>*，统一等级的下面的会覆盖上面的。\n\n浏览器还有默认的userAgent。\n\n通过这两种方式累计计算Dom的样式。\n\n## 布局\n\n布局是计算出元素的可见位置，分为创建布局树和布局计算两步。\n\n### 创建布局树\n\n+ 遍历DOM树中的可见节点，并将节点加到布局树中\n\n+ 忽略不可见的元素，比如head标签里面的元素，display为none的元素。\n\n### 布局计算\n\n布局是一个递归的过程，这是因为一个节点的大小通常需要先计算他的自节点的位置、大小等信息。\n\n计算布局的主要过程是的RenderObject的layout函数来完成的，步骤大致如下：\n\n\n+ 通过检查位数组中的相应标记位、子元素是否需要计算布局来确定。\n\n+ 确定网页的宽度和垂直方向上的外边距，这是因为网页通常是在垂直方向上滚动，而水平方向上不需要滚动。？？？？\n\n+ 接着函数会便利其每一个子元素，以此计算他们的布局。如果元素定义了自身的狂傲，那么webkit按照定义的宽高来确定元素的大小，而对于像文本节点的內联元素则需要结合其字号大小及文字的多少等来确定其对应的狂傲，除非页面定义了页面元素的狂傲，一般来说页面元素的宽高是在布局的时候通过相关计算的出来的。如果有子元素，则递归这一过程。\n\n+ 最后，节点根据计算他的子女们的大小计算出自己的高度，整个过程结束。\n\n## 分层\n\n渲染引擎为特定节点创建新的层的条件（满足两点任意一点就行）\n\n+ 拥有层叠上下文，例如\n    + 根元素 (HTML),\n    + z-index 值不为 \"auto\"的 绝对/相对定位元素，\n    + 固定（fixed）/ 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）\n    + z-index值不为 \"auto\"的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex，\n    + z-index值不为“auto”的grid子项，即：父元素display：grid\n    + opacity 属性值小于 1 的元素（参考 the specification for opacity），\n    + mix-blend-mode 属性值不为 \"normal\"的元素，\n    + transform属性值不为“none”的元素 \n    + filter值不为“none”的元素，\n    + perspective值不为“none”的元素，\n    + clip-path值不为“none”的元素\n    + mask / mask-image / mask-border不为“none”的元素\n    + isolation 属性被设置为 \"isolate\"的元素\n    + 在 will-change 中指定了任意CSS属性（参考 这篇文章）\n    + -webkit-overflow-scrolling 属性被设置 \"touch\"的元素\n    + contain属性值为“layout”，“paint”，或者综合值比如“strict”，“content”\n\n\n+ 需要裁剪的地方\n\n## 图层绘制\n\n渲染引擎会把一个图层拆分成很多小的绘制指令，然后这些指令按照顺序组成一个待绘制列表。包含绘制的形状、绘制、样式等。\n\n## 栅格化（raster）操作\n\n在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。\n\n<p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512</p>\n\n<strong>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。\n\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n\n![](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)\n\n## 合成和显示\n\n<p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>","slug":"浏览器-渲染","published":1,"updated":"2019-10-03T16:18:11.000Z","_id":"ck0n9rv90001qkwfyns911maf","comments":1,"layout":"post","photos":[],"link":"","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>本文是对浏览器工作原理与实践《我加书名号了》中渲染篇的总结，包括但不限于。<br><a id=\"more\"></a></p>\n</blockquote>\n<p>先说一下浏览器，目前的浏览器都是多进程架构的。以chrome为例，它包括1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。<br>其中：</p>\n<ul>\n<li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、自进程管理，同时提供存储等功能。</li>\n<li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript转换成用户可以与之交互的页面，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>\n<li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的。</li>\n<li><strong>GPU进程</strong>。用来绘制UI界面。</li>\n<li><strong>插件进程</strong>。主要负责插件的运行，因插件已崩溃，所以需要通过插件进程来隔离。</li>\n</ul>\n<p>以前了解浏览器的渲染，我学到的是这样好的。<br><img src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png\" alt=\"浏览器渲染过程\"></p>\n<p>但是各种细节不是很清楚，这次做个总结。</p>\n<h2 id=\"DOM树生成\"><a href=\"#DOM树生成\" class=\"headerlink\" title=\"DOM树生成\"></a>DOM树生成</h2><ul>\n<li><p>转换Bytes：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</p>\n</li>\n<li><p>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</p>\n</li>\n<li><p>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</p>\n</li>\n<li><p>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</p>\n</li>\n</ul>\n<h2 id=\"样式计算\"><a href=\"#样式计算\" class=\"headerlink\" title=\"样式计算\"></a>样式计算</h2><p>样式计算分为以下三步</p>\n<h3 id=\"将CSS转换为浏览器能够理解的结构\"><a href=\"#将CSS转换为浏览器能够理解的结构\" class=\"headerlink\" title=\"将CSS转换为浏览器能够理解的结构\"></a>将CSS转换为浏览器能够理解的结构</h3><p>来源：</p>\n<ul>\n<li>通过link引用的外部CSS文件</li>\n<li>style标签引入的</li>\n<li>DOM的style属性内嵌的<br>纯文本的CSS样式，浏览器是无法理解的，必须转换成StyleSheet</li>\n</ul>\n<h3 id=\"转换样式表中的属性值，使其标准化\"><a href=\"#转换样式表中的属性值，使其标准化\" class=\"headerlink\" title=\"转换样式表中的属性值，使其标准化\"></a>转换样式表中的属性值，使其标准化</h3><p>css的某些属性值，渲染引擎是不容易理解的，比如em，red， bold，这些会被转化成px，rgb以及700的形式。</p>\n<h3 id=\"计算DOM树中每个节点的具体样式\"><a href=\"#计算DOM树中每个节点的具体样式\" class=\"headerlink\" title=\"计算DOM树中每个节点的具体样式\"></a>计算DOM树中每个节点的具体样式</h3><p>主要是通过继承和层叠来实线。</p>\n<ul>\n<li><p>一个子元素的的样式可以从父元素继承而来，比如font-weight、font-family的font系列，text-align、line-height、color等文本系列，visibility以及cursor等。</p>\n</li>\n<li><p>css有个优先级策略，比如!important&gt;行内&gt;id&gt;class&gt;Tag&gt;*，统一等级的下面的会覆盖上面的。</p>\n</li>\n</ul>\n<p>浏览器还有默认的userAgent。</p>\n<p>通过这两种方式累计计算Dom的样式。</p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>布局是计算出元素的可见位置，分为创建布局树和布局计算两步。</p>\n<h3 id=\"创建布局树\"><a href=\"#创建布局树\" class=\"headerlink\" title=\"创建布局树\"></a>创建布局树</h3><ul>\n<li><p>遍历DOM树中的可见节点，并将节点加到布局树中</p>\n</li>\n<li><p>忽略不可见的元素，比如head标签里面的元素，display为none的元素。</p>\n</li>\n</ul>\n<h3 id=\"布局计算\"><a href=\"#布局计算\" class=\"headerlink\" title=\"布局计算\"></a>布局计算</h3><p>布局是一个递归的过程，这是因为一个节点的大小通常需要先计算他的自节点的位置、大小等信息。</p>\n<p>计算布局的主要过程是的RenderObject的layout函数来完成的，步骤大致如下：</p>\n<ul>\n<li><p>通过检查位数组中的相应标记位、子元素是否需要计算布局来确定。</p>\n</li>\n<li><p>确定网页的宽度和垂直方向上的外边距，这是因为网页通常是在垂直方向上滚动，而水平方向上不需要滚动。？？？？</p>\n</li>\n<li><p>接着函数会便利其每一个子元素，以此计算他们的布局。如果元素定义了自身的狂傲，那么webkit按照定义的宽高来确定元素的大小，而对于像文本节点的內联元素则需要结合其字号大小及文字的多少等来确定其对应的狂傲，除非页面定义了页面元素的狂傲，一般来说页面元素的宽高是在布局的时候通过相关计算的出来的。如果有子元素，则递归这一过程。</p>\n</li>\n<li><p>最后，节点根据计算他的子女们的大小计算出自己的高度，整个过程结束。</p>\n</li>\n</ul>\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>渲染引擎为特定节点创建新的层的条件（满足两点任意一点就行）</p>\n<ul>\n<li>拥有层叠上下文，例如<ul>\n<li>根元素 (HTML),</li>\n<li>z-index 值不为 “auto”的 绝对/相对定位元素，</li>\n<li>固定（fixed）/ 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）</li>\n<li>z-index值不为 “auto”的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex，</li>\n<li>z-index值不为“auto”的grid子项，即：父元素display：grid</li>\n<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>\n<li>mix-blend-mode 属性值不为 “normal”的元素，</li>\n<li>transform属性值不为“none”的元素 </li>\n<li>filter值不为“none”的元素，</li>\n<li>perspective值不为“none”的元素，</li>\n<li>clip-path值不为“none”的元素</li>\n<li>mask / mask-image / mask-border不为“none”的元素</li>\n<li>isolation 属性被设置为 “isolate”的元素</li>\n<li>在 will-change 中指定了任意CSS属性（参考 这篇文章）</li>\n<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>\n<li>contain属性值为“layout”，“paint”，或者综合值比如“strict”，“content”</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>需要裁剪的地方</li>\n</ul>\n<h2 id=\"图层绘制\"><a href=\"#图层绘制\" class=\"headerlink\" title=\"图层绘制\"></a>图层绘制</h2><p>渲染引擎会把一个图层拆分成很多小的绘制指令，然后这些指令按照顺序组成一个待绘制列表。包含绘制的形状、绘制、样式等。</p>\n<h2 id=\"栅格化（raster）操作\"><a href=\"#栅格化（raster）操作\" class=\"headerlink\" title=\"栅格化（raster）操作\"></a>栅格化（raster）操作</h2><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>\n<p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512</p>\n\n<p><strong>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。</p>\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n\n<p><img src=\"https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png\" alt></p>\n<h2 id=\"合成和显示\"><a href=\"#合成和显示\" class=\"headerlink\" title=\"合成和显示\"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文是对浏览器工作原理与实践《我加书名号了》中渲染篇的总结，包括但不限于。<br>","more":"</p>\n</blockquote>\n<p>先说一下浏览器，目前的浏览器都是多进程架构的。以chrome为例，它包括1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。<br>其中：</p>\n<ul>\n<li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、自进程管理，同时提供存储等功能。</li>\n<li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript转换成用户可以与之交互的页面，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>\n<li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的。</li>\n<li><strong>GPU进程</strong>。用来绘制UI界面。</li>\n<li><strong>插件进程</strong>。主要负责插件的运行，因插件已崩溃，所以需要通过插件进程来隔离。</li>\n</ul>\n<p>以前了解浏览器的渲染，我学到的是这样好的。<br><img src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png\" alt=\"浏览器渲染过程\"></p>\n<p>但是各种细节不是很清楚，这次做个总结。</p>\n<h2 id=\"DOM树生成\"><a href=\"#DOM树生成\" class=\"headerlink\" title=\"DOM树生成\"></a>DOM树生成</h2><ul>\n<li><p>转换Bytes：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</p>\n</li>\n<li><p>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</p>\n</li>\n<li><p>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</p>\n</li>\n<li><p>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</p>\n</li>\n</ul>\n<h2 id=\"样式计算\"><a href=\"#样式计算\" class=\"headerlink\" title=\"样式计算\"></a>样式计算</h2><p>样式计算分为以下三步</p>\n<h3 id=\"将CSS转换为浏览器能够理解的结构\"><a href=\"#将CSS转换为浏览器能够理解的结构\" class=\"headerlink\" title=\"将CSS转换为浏览器能够理解的结构\"></a>将CSS转换为浏览器能够理解的结构</h3><p>来源：</p>\n<ul>\n<li>通过link引用的外部CSS文件</li>\n<li>style标签引入的</li>\n<li>DOM的style属性内嵌的<br>纯文本的CSS样式，浏览器是无法理解的，必须转换成StyleSheet</li>\n</ul>\n<h3 id=\"转换样式表中的属性值，使其标准化\"><a href=\"#转换样式表中的属性值，使其标准化\" class=\"headerlink\" title=\"转换样式表中的属性值，使其标准化\"></a>转换样式表中的属性值，使其标准化</h3><p>css的某些属性值，渲染引擎是不容易理解的，比如em，red， bold，这些会被转化成px，rgb以及700的形式。</p>\n<h3 id=\"计算DOM树中每个节点的具体样式\"><a href=\"#计算DOM树中每个节点的具体样式\" class=\"headerlink\" title=\"计算DOM树中每个节点的具体样式\"></a>计算DOM树中每个节点的具体样式</h3><p>主要是通过继承和层叠来实线。</p>\n<ul>\n<li><p>一个子元素的的样式可以从父元素继承而来，比如font-weight、font-family的font系列，text-align、line-height、color等文本系列，visibility以及cursor等。</p>\n</li>\n<li><p>css有个优先级策略，比如!important&gt;行内&gt;id&gt;class&gt;Tag&gt;*，统一等级的下面的会覆盖上面的。</p>\n</li>\n</ul>\n<p>浏览器还有默认的userAgent。</p>\n<p>通过这两种方式累计计算Dom的样式。</p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>布局是计算出元素的可见位置，分为创建布局树和布局计算两步。</p>\n<h3 id=\"创建布局树\"><a href=\"#创建布局树\" class=\"headerlink\" title=\"创建布局树\"></a>创建布局树</h3><ul>\n<li><p>遍历DOM树中的可见节点，并将节点加到布局树中</p>\n</li>\n<li><p>忽略不可见的元素，比如head标签里面的元素，display为none的元素。</p>\n</li>\n</ul>\n<h3 id=\"布局计算\"><a href=\"#布局计算\" class=\"headerlink\" title=\"布局计算\"></a>布局计算</h3><p>布局是一个递归的过程，这是因为一个节点的大小通常需要先计算他的自节点的位置、大小等信息。</p>\n<p>计算布局的主要过程是的RenderObject的layout函数来完成的，步骤大致如下：</p>\n<ul>\n<li><p>通过检查位数组中的相应标记位、子元素是否需要计算布局来确定。</p>\n</li>\n<li><p>确定网页的宽度和垂直方向上的外边距，这是因为网页通常是在垂直方向上滚动，而水平方向上不需要滚动。？？？？</p>\n</li>\n<li><p>接着函数会便利其每一个子元素，以此计算他们的布局。如果元素定义了自身的狂傲，那么webkit按照定义的宽高来确定元素的大小，而对于像文本节点的內联元素则需要结合其字号大小及文字的多少等来确定其对应的狂傲，除非页面定义了页面元素的狂傲，一般来说页面元素的宽高是在布局的时候通过相关计算的出来的。如果有子元素，则递归这一过程。</p>\n</li>\n<li><p>最后，节点根据计算他的子女们的大小计算出自己的高度，整个过程结束。</p>\n</li>\n</ul>\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>渲染引擎为特定节点创建新的层的条件（满足两点任意一点就行）</p>\n<ul>\n<li>拥有层叠上下文，例如<ul>\n<li>根元素 (HTML),</li>\n<li>z-index 值不为 “auto”的 绝对/相对定位元素，</li>\n<li>固定（fixed）/ 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）</li>\n<li>z-index值不为 “auto”的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex，</li>\n<li>z-index值不为“auto”的grid子项，即：父元素display：grid</li>\n<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>\n<li>mix-blend-mode 属性值不为 “normal”的元素，</li>\n<li>transform属性值不为“none”的元素 </li>\n<li>filter值不为“none”的元素，</li>\n<li>perspective值不为“none”的元素，</li>\n<li>clip-path值不为“none”的元素</li>\n<li>mask / mask-image / mask-border不为“none”的元素</li>\n<li>isolation 属性被设置为 “isolate”的元素</li>\n<li>在 will-change 中指定了任意CSS属性（参考 这篇文章）</li>\n<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>\n<li>contain属性值为“layout”，“paint”，或者综合值比如“strict”，“content”</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>需要裁剪的地方</li>\n</ul>\n<h2 id=\"图层绘制\"><a href=\"#图层绘制\" class=\"headerlink\" title=\"图层绘制\"></a>图层绘制</h2><p>渲染引擎会把一个图层拆分成很多小的绘制指令，然后这些指令按照顺序组成一个待绘制列表。包含绘制的形状、绘制、样式等。</p>\n<h2 id=\"栅格化（raster）操作\"><a href=\"#栅格化（raster）操作\" class=\"headerlink\" title=\"栅格化（raster）操作\"></a>栅格化（raster）操作</h2><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>\n<p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512</p>\n\n<p><strong>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。</p>\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n\n<p><img src=\"https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png\" alt></p>\n<h2 id=\"合成和显示\"><a href=\"#合成和显示\" class=\"headerlink\" title=\"合成和显示\"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>"},{"title":"axioshhh","date":"2018-04-09T16:51:31.000Z","_content":"\n> 这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。\n\n<!--more-->\n\n这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br>\n\n说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br>\n\n今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png)\nexm????为啥传来的值在key上，\n是我的body-parser用的不对吗？之前也是这么用的啊\n```bash\nlet bodyParser = require(\"body-parser\");\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n```\n好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。\n\n### axios简介\n\naxios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。\n通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。\n值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。\n\n### axios配置\n般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type='application/x-www-form-urlencoded;charset=utf-8'数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）\n\n```bash\naxios.defaults.headers.common['Content-Type'] = 'application/json'\naxios.defaults.baseURL = _apiHost\n```\n\n### axios使用方法\n\n基本使用方法\nGET请求\n```bash\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n\n\nPOST请求\n```bash\n axios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n同时执行多个\n```bash\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n\n```\n\n可以直接通过config来完成请求\naxios(config)\n```bash\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n```\n详情请点击[这里](https://www.kancloud.cn/yunye/axios/234845)\n### 请求配置\n```bash\n\n{\n  // `url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // `method` 是创建请求时使用的方法\n  method: 'get', // 默认是 get\n\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // `data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n  // `withCredentials` 表示跨域请求时是否需要携带cookie\n  withCredentials: false, // 默认的\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // 默认的\n\n  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称\n  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的\n\n  // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // 默认的\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // 默认的\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: : {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n\n### 响应结构\n```bash\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n  // `config` 是为请求提供的配置信息\n  config: {}\n}\n```\n\n### 请求\n\n后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？\n原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。\n之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。\n\n#### 简单请求\n","source":"_posts/js-axioshhh.md","raw":"---\ntitle: axioshhh\ndate: 2018-04-10 00:51:31\ntags: javascript\ncategories: 学习\n---\n\n> 这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。\n\n<!--more-->\n\n这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br>\n\n说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br>\n\n今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png)\nexm????为啥传来的值在key上，\n是我的body-parser用的不对吗？之前也是这么用的啊\n```bash\nlet bodyParser = require(\"body-parser\");\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n```\n好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。\n\n### axios简介\n\naxios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。\n通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。\n值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。\n\n### axios配置\n般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type='application/x-www-form-urlencoded;charset=utf-8'数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）\n\n```bash\naxios.defaults.headers.common['Content-Type'] = 'application/json'\naxios.defaults.baseURL = _apiHost\n```\n\n### axios使用方法\n\n基本使用方法\nGET请求\n```bash\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n\n\nPOST请求\n```bash\n axios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n同时执行多个\n```bash\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n\n```\n\n可以直接通过config来完成请求\naxios(config)\n```bash\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n```\n详情请点击[这里](https://www.kancloud.cn/yunye/axios/234845)\n### 请求配置\n```bash\n\n{\n  // `url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // `method` 是创建请求时使用的方法\n  method: 'get', // 默认是 get\n\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // `data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n  // `withCredentials` 表示跨域请求时是否需要携带cookie\n  withCredentials: false, // 默认的\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // 默认的\n\n  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称\n  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的\n\n  // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // 默认的\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // 默认的\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: : {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n\n### 响应结构\n```bash\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n  // `config` 是为请求提供的配置信息\n  config: {}\n}\n```\n\n### 请求\n\n后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？\n原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。\n之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。\n\n#### 简单请求\n","slug":"js-axioshhh","published":1,"updated":"2019-09-17T02:39:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw8y002ckwfyuqa0m4h7","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br></p>\n<p>说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br></p>\n<p>今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png\" alt><br>exm????为啥传来的值在key上，<br>是我的body-parser用的不对吗？之前也是这么用的啊<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> bodyParser = require(<span class=\"string\">\"body-parser\"</span>);</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: <span class=\"literal\">true</span> &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。</p>\n<h3 id=\"axios简介\"><a href=\"#axios简介\" class=\"headerlink\" title=\"axios简介\"></a>axios简介</h3><p>axios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。<br>通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。<br>值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。</p>\n<h3 id=\"axios配置\"><a href=\"#axios配置\" class=\"headerlink\" title=\"axios配置\"></a>axios配置</h3><p>般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type=’application/x-www-form-urlencoded;charset=utf-8’数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'application/json'</span></span><br><span class=\"line\">axios.defaults.baseURL = _apiHost</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios使用方法\"><a href=\"#axios使用方法\" class=\"headerlink\" title=\"axios使用方法\"></a>axios使用方法</h3><p>基本使用方法<br>GET请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make a request <span class=\"keyword\">for</span> a user with a given ID</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Optionally the request above could also be <span class=\"keyword\">done</span> as</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>POST请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">   firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">   lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">   console.log(response);</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">   console.log(error);</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>同时执行多个<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserAccount</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserPermissions</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> (acct, perms) &#123;</span><br><span class=\"line\">    // Both requests are now complete</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>可以直接通过config来完成请求<br>axios(config)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">  url: <span class=\"string\">'/user/12345'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>详情请点击<a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"请求配置\"><a href=\"#请求配置\" class=\"headerlink\" title=\"请求配置\"></a>请求配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // `url` 是用于请求的服务器 URL</span><br><span class=\"line\">  url: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `method` 是创建请求时使用的方法</span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>, // 默认是 get</span><br><span class=\"line\"></span><br><span class=\"line\">  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span><br><span class=\"line\">  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span><br><span class=\"line\">  baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformRequest` 允许在向服务器发送前，修改请求数据</span><br><span class=\"line\">  // 只能用在 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span> 和 <span class=\"string\">'PATCH'</span> 这几个请求方法</span><br><span class=\"line\">  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span><br><span class=\"line\">  transformRequest: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformResponse` 在传递给 <span class=\"keyword\">then</span>/catch 前，允许修改响应数据</span><br><span class=\"line\">  transformResponse: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 是即将被发送的自定义请求头</span><br><span class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>: <span class=\"string\">'XMLHttpRequest'</span>&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `params` 是即将与请求一起发送的 URL 参数</span><br><span class=\"line\">  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: 12345</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `paramsSerializer` 是一个负责 `params` 序列化的函数</span><br><span class=\"line\">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class=\"line\">  paramsSerializer: <span class=\"keyword\">function</span>(params) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Qs.stringify(params, &#123;arrayFormat: <span class=\"string\">'brackets'</span>&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `data` 是作为请求主体被发送的数据</span><br><span class=\"line\">  // 只适用于这些请求方法 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span>, 和 <span class=\"string\">'PATCH'</span></span><br><span class=\"line\">  // 在没有设置 `transformRequest` 时，必须是以下类型之一：</span><br><span class=\"line\">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class=\"line\">  // - 浏览器专属：FormData, File, Blob</span><br><span class=\"line\">  // - Node 专属： Stream</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span><br><span class=\"line\">  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `withCredentials` 表示跨域请求时是否需要携带cookie</span><br><span class=\"line\">  withCredentials: <span class=\"literal\">false</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `adapter` 允许自定义处理请求，以使测试更轻松</span><br><span class=\"line\">  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](<span class=\"comment\">#response-api)).</span></span><br><span class=\"line\">  adapter: <span class=\"keyword\">function</span> (config) &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span><br><span class=\"line\">  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: <span class=\"string\">'janedoe'</span>,</span><br><span class=\"line\">    password: <span class=\"string\">'s00pers3cret'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `responseType` 表示服务器响应的数据类型，可以是 <span class=\"string\">'arraybuffer'</span>, <span class=\"string\">'blob'</span>, <span class=\"string\">'document'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'text'</span>, <span class=\"string\">'stream'</span></span><br><span class=\"line\">  responseType: <span class=\"string\">'json'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span><br><span class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span><br><span class=\"line\">  xsrfHeaderName: <span class=\"string\">'X-XSRF-TOKEN'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onUploadProgress` 允许为上传处理进度事件</span><br><span class=\"line\">  onUploadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onDownloadProgress` 允许为下载处理进度事件</span><br><span class=\"line\">  onDownloadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxContentLength` 定义允许的响应内容的最大尺寸</span><br><span class=\"line\">  maxContentLength: 2000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `<span class=\"literal\">true</span>` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span><br><span class=\"line\">  validateStatus: <span class=\"keyword\">function</span> (status) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span><br><span class=\"line\">  // 如果设置为0，将不会 follow 任何重定向</span><br><span class=\"line\">  maxRedirects: 5, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span><br><span class=\"line\">  // `keepAlive` 默认没有启用</span><br><span class=\"line\">  httpAgent: new http.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\">  httpsAgent: new https.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // <span class=\"string\">'proxy'</span> 定义代理服务器的主机名称和端口</span><br><span class=\"line\">  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class=\"line\">  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">    port: 9000,</span><br><span class=\"line\">    auth: : &#123;</span><br><span class=\"line\">      username: <span class=\"string\">'mikeymike'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'rapunz3l'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `cancelToken` 指定用于取消请求的 cancel token</span><br><span class=\"line\">  // （查看后面的 Cancellation 这节了解更多）</span><br><span class=\"line\">  cancelToken: new CancelToken(<span class=\"keyword\">function</span> (cancel) &#123;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"响应结构\"><a href=\"#响应结构\" class=\"headerlink\" title=\"响应结构\"></a>响应结构</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `data` 由服务器提供的响应</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class=\"line\">  status: 200,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 服务器响应的头</span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `config` 是为请求提供的配置信息</span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？<br>原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。<br>之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4>","site":{"data":{}},"excerpt":"<blockquote>\n<p>这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。</p>\n</blockquote>","more":"<p>这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br></p>\n<p>说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br></p>\n<p>今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png\" alt><br>exm????为啥传来的值在key上，<br>是我的body-parser用的不对吗？之前也是这么用的啊<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> bodyParser = require(<span class=\"string\">\"body-parser\"</span>);</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: <span class=\"literal\">true</span> &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。</p>\n<h3 id=\"axios简介\"><a href=\"#axios简介\" class=\"headerlink\" title=\"axios简介\"></a>axios简介</h3><p>axios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。<br>通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。<br>值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。</p>\n<h3 id=\"axios配置\"><a href=\"#axios配置\" class=\"headerlink\" title=\"axios配置\"></a>axios配置</h3><p>般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type=’application/x-www-form-urlencoded;charset=utf-8’数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'application/json'</span></span><br><span class=\"line\">axios.defaults.baseURL = _apiHost</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios使用方法\"><a href=\"#axios使用方法\" class=\"headerlink\" title=\"axios使用方法\"></a>axios使用方法</h3><p>基本使用方法<br>GET请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make a request <span class=\"keyword\">for</span> a user with a given ID</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Optionally the request above could also be <span class=\"keyword\">done</span> as</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>POST请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">   firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">   lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">   console.log(response);</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">   console.log(error);</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>同时执行多个<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserAccount</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserPermissions</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> (acct, perms) &#123;</span><br><span class=\"line\">    // Both requests are now complete</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>可以直接通过config来完成请求<br>axios(config)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">  url: <span class=\"string\">'/user/12345'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>详情请点击<a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"请求配置\"><a href=\"#请求配置\" class=\"headerlink\" title=\"请求配置\"></a>请求配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // `url` 是用于请求的服务器 URL</span><br><span class=\"line\">  url: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `method` 是创建请求时使用的方法</span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>, // 默认是 get</span><br><span class=\"line\"></span><br><span class=\"line\">  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span><br><span class=\"line\">  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span><br><span class=\"line\">  baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformRequest` 允许在向服务器发送前，修改请求数据</span><br><span class=\"line\">  // 只能用在 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span> 和 <span class=\"string\">'PATCH'</span> 这几个请求方法</span><br><span class=\"line\">  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span><br><span class=\"line\">  transformRequest: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformResponse` 在传递给 <span class=\"keyword\">then</span>/catch 前，允许修改响应数据</span><br><span class=\"line\">  transformResponse: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 是即将被发送的自定义请求头</span><br><span class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>: <span class=\"string\">'XMLHttpRequest'</span>&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `params` 是即将与请求一起发送的 URL 参数</span><br><span class=\"line\">  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: 12345</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `paramsSerializer` 是一个负责 `params` 序列化的函数</span><br><span class=\"line\">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class=\"line\">  paramsSerializer: <span class=\"keyword\">function</span>(params) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Qs.stringify(params, &#123;arrayFormat: <span class=\"string\">'brackets'</span>&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `data` 是作为请求主体被发送的数据</span><br><span class=\"line\">  // 只适用于这些请求方法 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span>, 和 <span class=\"string\">'PATCH'</span></span><br><span class=\"line\">  // 在没有设置 `transformRequest` 时，必须是以下类型之一：</span><br><span class=\"line\">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class=\"line\">  // - 浏览器专属：FormData, File, Blob</span><br><span class=\"line\">  // - Node 专属： Stream</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span><br><span class=\"line\">  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `withCredentials` 表示跨域请求时是否需要携带cookie</span><br><span class=\"line\">  withCredentials: <span class=\"literal\">false</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `adapter` 允许自定义处理请求，以使测试更轻松</span><br><span class=\"line\">  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](<span class=\"comment\">#response-api)).</span></span><br><span class=\"line\">  adapter: <span class=\"keyword\">function</span> (config) &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span><br><span class=\"line\">  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: <span class=\"string\">'janedoe'</span>,</span><br><span class=\"line\">    password: <span class=\"string\">'s00pers3cret'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `responseType` 表示服务器响应的数据类型，可以是 <span class=\"string\">'arraybuffer'</span>, <span class=\"string\">'blob'</span>, <span class=\"string\">'document'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'text'</span>, <span class=\"string\">'stream'</span></span><br><span class=\"line\">  responseType: <span class=\"string\">'json'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span><br><span class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span><br><span class=\"line\">  xsrfHeaderName: <span class=\"string\">'X-XSRF-TOKEN'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onUploadProgress` 允许为上传处理进度事件</span><br><span class=\"line\">  onUploadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onDownloadProgress` 允许为下载处理进度事件</span><br><span class=\"line\">  onDownloadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxContentLength` 定义允许的响应内容的最大尺寸</span><br><span class=\"line\">  maxContentLength: 2000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `<span class=\"literal\">true</span>` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span><br><span class=\"line\">  validateStatus: <span class=\"keyword\">function</span> (status) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span><br><span class=\"line\">  // 如果设置为0，将不会 follow 任何重定向</span><br><span class=\"line\">  maxRedirects: 5, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span><br><span class=\"line\">  // `keepAlive` 默认没有启用</span><br><span class=\"line\">  httpAgent: new http.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\">  httpsAgent: new https.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // <span class=\"string\">'proxy'</span> 定义代理服务器的主机名称和端口</span><br><span class=\"line\">  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class=\"line\">  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">    port: 9000,</span><br><span class=\"line\">    auth: : &#123;</span><br><span class=\"line\">      username: <span class=\"string\">'mikeymike'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'rapunz3l'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `cancelToken` 指定用于取消请求的 cancel token</span><br><span class=\"line\">  // （查看后面的 Cancellation 这节了解更多）</span><br><span class=\"line\">  cancelToken: new CancelToken(<span class=\"keyword\">function</span> (cancel) &#123;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"响应结构\"><a href=\"#响应结构\" class=\"headerlink\" title=\"响应结构\"></a>响应结构</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `data` 由服务器提供的响应</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class=\"line\">  status: 200,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 服务器响应的头</span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `config` 是为请求提供的配置信息</span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？<br>原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。<br>之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4>"},{"title":"sort","date":"2018-07-25T03:33:49.000Z","_content":"先来张图片\n<img  src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\" />\n<!--more-->\n### 冒泡排序\n#### 算法描述\n\n+ <1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n+ <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n+ <3>.针对所有的元素重复以上的步骤，除了最后一个；\n+ <4>.重复步骤1~3，直到排序完成。\n\n#### 代码实现\n设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\n```bash\nfunction bubbleSort(arr) {\n    var i = arr.length-1;  //初始时,最后位置保持不变\n    while ( i> 0) {\n        var pos= 0; //每趟开始时,无记录交换\n        for (var j= 0; j< i; j++)\n            if (arr[j]> arr[j+1]) {\n                pos= j; //记录交换的位置\n                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;\n            }\n        i= pos; //为下一趟排序作准备\n     }\n     console.timeEnd('改进后冒泡排序耗时');\n     return arr;\n}\n```\n\n### 选择排序\n#### 算法描述\n\n+ <1>.初始状态：无序区为R[1..n]，有序区为空；\n+ <2>.第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n+ <3>.n-1趟结束，数组有序化了。\n\n#### 代码实现\n\n```bash\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}\n```\n### 插入排序\n#### 算法描述\n\n+ <1>.从第一个元素开始，该元素可以认为已经被排序；\n+ <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；\n+ <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；\n+ <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n+ <5>.将新元素插入到该位置后；\n+ <6>.重复步骤2~5。\n\n#### 代码描述\n```bash\nfunction insertionSort(array) {\n    for (var i = 1; i < array.length; i++) {\n            var key = array[i];\n            var j = i - 1;\n            while (j >= 0 && array[j] > key) {\n                array[j + 1] = array[j];\n                j--;\n            }\n            array[j + 1] = key;\n        }\n        return array;\n}\n```\n#### 算法分析\n+ 最佳情况：输入数组按升序排列。T(n) = O(n)\n+ 最坏情况：输入数组按降序排列。T(n) = O(n2)\n+ 平均情况：T(n) = O(n2)\n\n### 希尔排序\n#### 算法描述\n\n+ <1>. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n+ <2>.按增量序列个数k，对序列进行k 趟排序；\n+ <3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 代码实现\n```bash\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    console.time('希尔排序耗时:');\n    while(gap < len/5) {          //动态定义间隔序列\n        gap =gap*5+1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap/5)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    console.timeEnd('希尔排序耗时:');\n    return arr;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlog2 n)\n+ 最坏情况：T(n) = O(nlog2 n)\n+ 平均情况：T(n) =O(nlog n)\n\n### 归并排序\n#### 算法描述\n\n+ <1>把长度为n的输入序列分成两个长度为n/2的子序列；\n+ <2>对这两个子序列分别采用归并排序；\n+ <3>将两个排序好的子序列合并成一个最终的排序序列。\n\n#### 代码实现\n```bash\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    console.time('归并排序耗时');\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    console.timeEnd('归并排序耗时');\n    return result;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(n)\n+ 最坏情况：T(n) = O(nlog n)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 快速排序\n#### 算法描述\n\n+ <1>从数列中挑出一个元素，称为 \"基准\"（pivot）；\n+ <2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n+ <3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n#### 代码实现\n```bash\nvar arr = [12,3,23,5,17,9,15,46];\n\nfunction quickSort(arr,left, right){\n  var i,j,t,temp;\n  if(left>right){\n    return;\n  }\n  i = left;\n  j = right;\n  temp = arr[left];\n\n  while(i!==j){\n    while(temp<=arr[j]&&i<j){\n      j--;\n    }\n    while(temp>=arr[i]&&i<j){\n      i++\n    }\n    if(i<j){\n      [arr[j], arr[i]] = [arr[i], arr[j]];\n    }\n  }\n  arr[left] = arr[i];\n  arr[i] = temp;\n  quickSort(arr,left,i-1);\n  quickSort(arr,i+1,right);\n}\nquickSort(arr,0, arr.length-1);\nconsole.log(arr);\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(n2)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 堆排序\n#### 算法描述\n\n+ <1>将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；\n+ <2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]；\n+ <3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n#### 代码实现\n```bash\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(nlogn)\n+ 平均情况：T(n) =O(nlogn)\n","source":"_posts/js-sort.md","raw":"---\ntitle: sort\ndate: 2018-07-25 11:33:49\ntags: 算法\ncategories: 学习\n---\n先来张图片\n<img  src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\" />\n<!--more-->\n### 冒泡排序\n#### 算法描述\n\n+ <1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n+ <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n+ <3>.针对所有的元素重复以上的步骤，除了最后一个；\n+ <4>.重复步骤1~3，直到排序完成。\n\n#### 代码实现\n设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\n```bash\nfunction bubbleSort(arr) {\n    var i = arr.length-1;  //初始时,最后位置保持不变\n    while ( i> 0) {\n        var pos= 0; //每趟开始时,无记录交换\n        for (var j= 0; j< i; j++)\n            if (arr[j]> arr[j+1]) {\n                pos= j; //记录交换的位置\n                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;\n            }\n        i= pos; //为下一趟排序作准备\n     }\n     console.timeEnd('改进后冒泡排序耗时');\n     return arr;\n}\n```\n\n### 选择排序\n#### 算法描述\n\n+ <1>.初始状态：无序区为R[1..n]，有序区为空；\n+ <2>.第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n+ <3>.n-1趟结束，数组有序化了。\n\n#### 代码实现\n\n```bash\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}\n```\n### 插入排序\n#### 算法描述\n\n+ <1>.从第一个元素开始，该元素可以认为已经被排序；\n+ <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；\n+ <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；\n+ <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n+ <5>.将新元素插入到该位置后；\n+ <6>.重复步骤2~5。\n\n#### 代码描述\n```bash\nfunction insertionSort(array) {\n    for (var i = 1; i < array.length; i++) {\n            var key = array[i];\n            var j = i - 1;\n            while (j >= 0 && array[j] > key) {\n                array[j + 1] = array[j];\n                j--;\n            }\n            array[j + 1] = key;\n        }\n        return array;\n}\n```\n#### 算法分析\n+ 最佳情况：输入数组按升序排列。T(n) = O(n)\n+ 最坏情况：输入数组按降序排列。T(n) = O(n2)\n+ 平均情况：T(n) = O(n2)\n\n### 希尔排序\n#### 算法描述\n\n+ <1>. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n+ <2>.按增量序列个数k，对序列进行k 趟排序；\n+ <3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 代码实现\n```bash\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    console.time('希尔排序耗时:');\n    while(gap < len/5) {          //动态定义间隔序列\n        gap =gap*5+1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap/5)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    console.timeEnd('希尔排序耗时:');\n    return arr;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlog2 n)\n+ 最坏情况：T(n) = O(nlog2 n)\n+ 平均情况：T(n) =O(nlog n)\n\n### 归并排序\n#### 算法描述\n\n+ <1>把长度为n的输入序列分成两个长度为n/2的子序列；\n+ <2>对这两个子序列分别采用归并排序；\n+ <3>将两个排序好的子序列合并成一个最终的排序序列。\n\n#### 代码实现\n```bash\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    console.time('归并排序耗时');\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    console.timeEnd('归并排序耗时');\n    return result;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(n)\n+ 最坏情况：T(n) = O(nlog n)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 快速排序\n#### 算法描述\n\n+ <1>从数列中挑出一个元素，称为 \"基准\"（pivot）；\n+ <2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n+ <3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n#### 代码实现\n```bash\nvar arr = [12,3,23,5,17,9,15,46];\n\nfunction quickSort(arr,left, right){\n  var i,j,t,temp;\n  if(left>right){\n    return;\n  }\n  i = left;\n  j = right;\n  temp = arr[left];\n\n  while(i!==j){\n    while(temp<=arr[j]&&i<j){\n      j--;\n    }\n    while(temp>=arr[i]&&i<j){\n      i++\n    }\n    if(i<j){\n      [arr[j], arr[i]] = [arr[i], arr[j]];\n    }\n  }\n  arr[left] = arr[i];\n  arr[i] = temp;\n  quickSort(arr,left,i-1);\n  quickSort(arr,i+1,right);\n}\nquickSort(arr,0, arr.length-1);\nconsole.log(arr);\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(n2)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 堆排序\n#### 算法描述\n\n+ <1>将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；\n+ <2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]；\n+ <3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n#### 代码实现\n```bash\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(nlogn)\n+ 平均情况：T(n) =O(nlogn)\n","slug":"js-sort","published":1,"updated":"2019-09-17T02:42:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw8z002dkwfyfwfuz72v","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>先来张图片<br><img src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\"><br><a id=\"more\"></a></p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>\n<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>\n<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>\n<li><4>.重复步骤1~3，直到排序完成。</4></li>\n</ul>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> bubbleSort(arr) &#123;</span><br><span class=\"line\">    var i = arr.length-1;  //初始时,最后位置保持不变</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( i&gt; 0) &#123;</span><br><span class=\"line\">        var pos= 0; //每趟开始时,无记录交换</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j= 0; j&lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+1]) &#123;</span><br><span class=\"line\">                pos= j; //记录交换的位置</span><br><span class=\"line\">                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        i= pos; //为下一趟排序作准备</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     console.timeEnd(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">     <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><h4 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>\n<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>\n<li><3>.n-1趟结束，数组有序化了。</3></li>\n</ul>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> selectionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var minIndex, temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class=\"line\">                minIndex = j;                 //将最小数的索引保存</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><h4 id=\"算法描述-2\"><a href=\"#算法描述-2\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>\n<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>\n<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>\n<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>\n<li><5>.将新元素插入到该位置后；</5></li>\n<li><6>.重复步骤2~5。</6></li>\n</ul>\n<h4 id=\"代码描述\"><a href=\"#代码描述\" class=\"headerlink\" title=\"代码描述\"></a>代码描述</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> insertionSort(array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            var key = array[i];</span><br><span class=\"line\">            var j = i - 1;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">                array[j + 1] = array[j];</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[j + 1] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>\n<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h4 id=\"算法描述-3\"><a href=\"#算法描述-3\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>\n<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>\n<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>\n</ul>\n<h4 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> shellSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length,</span><br><span class=\"line\">        temp,</span><br><span class=\"line\">        gap = 1;</span><br><span class=\"line\">    console.time(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(gap &lt; len/5) &#123;          //动态定义间隔序列</span><br><span class=\"line\">        gap =gap*5+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class=\"line\">                arr[j+gap] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j+gap] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlog2 n)</li>\n<li>最坏情况：T(n) = O(nlog2 n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><h4 id=\"算法描述-4\"><a href=\"#算法描述-4\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>\n<li><2>对这两个子序列分别采用归并排序；</2></li>\n<li><3>将两个排序好的子序列合并成一个最终的排序序列。</3></li>\n</ul>\n<h4 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len &lt; 2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var middle = Math.floor(len / 2),</span><br><span class=\"line\">        left = arr.slice(0, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> merge(left, right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\">    console.time(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最坏情况：T(n) = O(nlog n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h4 id=\"算法描述-5\"><a href=\"#算法描述-5\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>\n<li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>\n<li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>\n</ul>\n<h4 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [12,3,23,5,17,9,15,46];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> quickSort(arr,left, right)&#123;</span><br><span class=\"line\">  var i,j,t,temp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(left&gt;right)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  i = left;</span><br><span class=\"line\">  j = right;</span><br><span class=\"line\">  temp = arr[left];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i!==j)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;j)&#123;</span><br><span class=\"line\">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr[left] = arr[i];</span><br><span class=\"line\">  arr[i] = temp;</span><br><span class=\"line\">  quickSort(arr,left,i-1);</span><br><span class=\"line\">  quickSort(arr,i+1,right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">quickSort(arr,0, arr.length-1);</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(n2)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><h4 id=\"算法描述-6\"><a href=\"#算法描述-6\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>\n<li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>\n<li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h4 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*方法说明：维护堆的性质</span><br><span class=\"line\">@param  arr 数组</span><br><span class=\"line\">@param  x   数组下标</span><br><span class=\"line\">@param  len 堆大小*/</span><br><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</3></li>\n</ul>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(nlogn)</li>\n<li>平均情况：T(n) =O(nlogn)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>先来张图片<br><img src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\"><br>","more":"</p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>\n<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>\n<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>\n<li><4>.重复步骤1~3，直到排序完成。</4></li>\n</ul>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> bubbleSort(arr) &#123;</span><br><span class=\"line\">    var i = arr.length-1;  //初始时,最后位置保持不变</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( i&gt; 0) &#123;</span><br><span class=\"line\">        var pos= 0; //每趟开始时,无记录交换</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j= 0; j&lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+1]) &#123;</span><br><span class=\"line\">                pos= j; //记录交换的位置</span><br><span class=\"line\">                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        i= pos; //为下一趟排序作准备</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     console.timeEnd(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">     <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><h4 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>\n<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>\n<li><3>.n-1趟结束，数组有序化了。</3></li>\n</ul>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> selectionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var minIndex, temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class=\"line\">                minIndex = j;                 //将最小数的索引保存</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><h4 id=\"算法描述-2\"><a href=\"#算法描述-2\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>\n<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>\n<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>\n<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>\n<li><5>.将新元素插入到该位置后；</5></li>\n<li><6>.重复步骤2~5。</6></li>\n</ul>\n<h4 id=\"代码描述\"><a href=\"#代码描述\" class=\"headerlink\" title=\"代码描述\"></a>代码描述</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> insertionSort(array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            var key = array[i];</span><br><span class=\"line\">            var j = i - 1;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">                array[j + 1] = array[j];</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[j + 1] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>\n<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h4 id=\"算法描述-3\"><a href=\"#算法描述-3\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>\n<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>\n<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>\n</ul>\n<h4 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> shellSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length,</span><br><span class=\"line\">        temp,</span><br><span class=\"line\">        gap = 1;</span><br><span class=\"line\">    console.time(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(gap &lt; len/5) &#123;          //动态定义间隔序列</span><br><span class=\"line\">        gap =gap*5+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class=\"line\">                arr[j+gap] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j+gap] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlog2 n)</li>\n<li>最坏情况：T(n) = O(nlog2 n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><h4 id=\"算法描述-4\"><a href=\"#算法描述-4\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>\n<li><2>对这两个子序列分别采用归并排序；</2></li>\n<li><3>将两个排序好的子序列合并成一个最终的排序序列。</3></li>\n</ul>\n<h4 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len &lt; 2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var middle = Math.floor(len / 2),</span><br><span class=\"line\">        left = arr.slice(0, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> merge(left, right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\">    console.time(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最坏情况：T(n) = O(nlog n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h4 id=\"算法描述-5\"><a href=\"#算法描述-5\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>\n<li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>\n<li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>\n</ul>\n<h4 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [12,3,23,5,17,9,15,46];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> quickSort(arr,left, right)&#123;</span><br><span class=\"line\">  var i,j,t,temp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(left&gt;right)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  i = left;</span><br><span class=\"line\">  j = right;</span><br><span class=\"line\">  temp = arr[left];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i!==j)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;j)&#123;</span><br><span class=\"line\">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr[left] = arr[i];</span><br><span class=\"line\">  arr[i] = temp;</span><br><span class=\"line\">  quickSort(arr,left,i-1);</span><br><span class=\"line\">  quickSort(arr,i+1,right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">quickSort(arr,0, arr.length-1);</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(n2)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><h4 id=\"算法描述-6\"><a href=\"#算法描述-6\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>\n<li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>\n<li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h4 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*方法说明：维护堆的性质</span><br><span class=\"line\">@param  arr 数组</span><br><span class=\"line\">@param  x   数组下标</span><br><span class=\"line\">@param  len 堆大小*/</span><br><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</3></li>\n</ul>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(nlogn)</li>\n<li>平均情况：T(n) =O(nlogn)</li>\n</ul>"},{"title":"koaMiddleWare","date":"2018-08-07T13:09:48.000Z","_content":"### js的异步解决方案\n在javascript里，异步的解决方案包括以下几种：\n\n+ 回调\n+ promise\n+ generator\n+ async\n优雅程度自上而下。\n<!--more-->\n\n### express koa1 koa2\n随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br>\n\nkoa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。\n<br>\n\n在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。\n个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br>\n\n### application.js\nkoa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：\n```bash\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst isGeneratorFunction = require('is-generator-function');\nconst debug = require('debug')('koa:application');\nconst onFinished = require('on-finished');\nconst response = require('./response');\nconst compose = require('koa-compose');\nconst isJSON = require('koa-is-json');\nconst context = require('./context');\nconst request = require('./request');\nconst statuses = require('statuses');\nconst Emitter = require('events');\nconst util = require('util');\nconst Stream = require('stream');\nconst http = require('http');\nconst only = require('only');\nconst convert = require('koa-convert');\nconst deprecate = require('depd')('koa');\n\n/**\n * Expose `Application` class.\n * Inherits from `Emitter.prototype`.\n */\n\n //继承Emitter  因此 koa的实例 this可以调用on\nmodule.exports = class Application extends Emitter {\n  /**\n   * Initialize a new `Application`.\n   *\n   * @api public\n   */\n\n  constructor() {\n    super();\n\n    this.proxy = false; //代理设置\n    this.middleware = [];\n    this.subdomainOffset = 2; //域名偏移\n    this.env = process.env.NODE_ENV || 'development';\n    this.context = Object.create(context);\n    this.request = Object.create(request);\n    this.response = Object.create(response);\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  /**\n   * Shorthand for:\n   *\n   *    http.createServer(app.callback()).listen(...)\n   *\n   * @param {Mixed} ...\n   * @return {Server}\n   * @api public\n   */\n\n  listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n\n  /**\n   * Return JSON representation.\n   * We only bother showing settings.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  toJSON() {\n    return only(this, [\n      'subdomainOffset',\n      'proxy',\n      'env'\n    ]);\n  }\n\n  /**\n   * Inspect implementation.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  inspect() {\n    return this.toJSON();\n  }\n\n  /**\n   * Use the given middleware `fn`.\n   *\n   * Old-style middleware will be converted.\n   *\n   * @param {Function} fn\n   * @return {Application} self\n   * @api public\n   */\n\n  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),\n  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.\n  use(fn) {\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n    if (isGeneratorFunction(fn)) {\n      deprecate('Support for generators will be removed in v3. ' +\n                'See the documentation for examples of how to convert old middleware ' +\n                'https://github.com/koajs/koa/blob/master/docs/migration.md');\n      fn = convert(fn);\n    }\n    debug('use %s', fn._name || fn.name || '-');\n    this.middleware.push(fn);\n    return this;\n  }\n\n  /**\n   * Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public\n   */\n\n  callback() {\n    //合并中间件\n    const fn = compose(this.middleware);\n\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  /**\n   * Handle request in callback.\n   *\n   * @api private\n   */\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  /**\n   * Initialize a new context.\n   *\n   * @api private\n   */\n\n   //创建cotext request reponse 与http模块的关系\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n\n  /**\n   * Default error handler.\n   *\n   * @param {Error} err\n   * @api private\n   */\n\n  onerror(err) {\n    if (!(err instanceof Error)) throw new TypeError(util.format('non-error thrown: %j', err));\n\n    if (404 == err.status || err.expose) return;\n    if (this.silent) return;\n\n    const msg = err.stack || err.toString();\n    console.error();\n    console.error(msg.replace(/^/gm, '  '));\n    console.error();\n  }\n};\n\n/**\n * Response helper.\n */\n\nfunction respond(ctx) {\n  // allow bypassing koa\n  if (false === ctx.respond) return;\n\n  const res = ctx.res;\n  if (!ctx.writable) return;\n\n  let body = ctx.body;\n  const code = ctx.status;\n\n  // ignore body\n  if (statuses.empty[code]) {\n    // strip headers\n    ctx.body = null;\n    return res.end();\n  }\n\n  if ('HEAD' == ctx.method) {\n    if (!res.headersSent && isJSON(body)) {\n      ctx.length = Buffer.byteLength(JSON.stringify(body));\n    }\n    return res.end();\n  }\n\n  // status body\n  if (null == body) {\n    body = ctx.message || String(code);\n    if (!res.headersSent) {\n      ctx.type = 'text';\n      ctx.length = Buffer.byteLength(body);\n    }\n    return res.end(body);\n  }\n\n  // responses\n  if (Buffer.isBuffer(body)) return res.end(body);\n  if ('string' == typeof body) return res.end(body);\n  if (body instanceof Stream) return body.pipe(res);\n\n  // body: json\n  body = JSON.stringify(body);\n  if (!res.headersSent) {\n    ctx.length = Buffer.byteLength(body);\n  }\n  res.end(body);\n}\n```\n其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。\n<br>\n当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br>\n最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。\n\n### compose.js\n\n```bash\nuse strict'\n\n/**\n * Expose compositor.\n */\n\nmodule.exports = compose\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\n\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1; //当前中间件的索引\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\ncompose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\" />\n其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。\n","source":"_posts/node-koaMiddle.md","raw":"---\ntitle: koaMiddleWare\ndate: 2018-08-07 21:09:48\ntags: koa\ncategories: 学习\n---\n### js的异步解决方案\n在javascript里，异步的解决方案包括以下几种：\n\n+ 回调\n+ promise\n+ generator\n+ async\n优雅程度自上而下。\n<!--more-->\n\n### express koa1 koa2\n随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br>\n\nkoa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。\n<br>\n\n在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。\n个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br>\n\n### application.js\nkoa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：\n```bash\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst isGeneratorFunction = require('is-generator-function');\nconst debug = require('debug')('koa:application');\nconst onFinished = require('on-finished');\nconst response = require('./response');\nconst compose = require('koa-compose');\nconst isJSON = require('koa-is-json');\nconst context = require('./context');\nconst request = require('./request');\nconst statuses = require('statuses');\nconst Emitter = require('events');\nconst util = require('util');\nconst Stream = require('stream');\nconst http = require('http');\nconst only = require('only');\nconst convert = require('koa-convert');\nconst deprecate = require('depd')('koa');\n\n/**\n * Expose `Application` class.\n * Inherits from `Emitter.prototype`.\n */\n\n //继承Emitter  因此 koa的实例 this可以调用on\nmodule.exports = class Application extends Emitter {\n  /**\n   * Initialize a new `Application`.\n   *\n   * @api public\n   */\n\n  constructor() {\n    super();\n\n    this.proxy = false; //代理设置\n    this.middleware = [];\n    this.subdomainOffset = 2; //域名偏移\n    this.env = process.env.NODE_ENV || 'development';\n    this.context = Object.create(context);\n    this.request = Object.create(request);\n    this.response = Object.create(response);\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  /**\n   * Shorthand for:\n   *\n   *    http.createServer(app.callback()).listen(...)\n   *\n   * @param {Mixed} ...\n   * @return {Server}\n   * @api public\n   */\n\n  listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n\n  /**\n   * Return JSON representation.\n   * We only bother showing settings.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  toJSON() {\n    return only(this, [\n      'subdomainOffset',\n      'proxy',\n      'env'\n    ]);\n  }\n\n  /**\n   * Inspect implementation.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  inspect() {\n    return this.toJSON();\n  }\n\n  /**\n   * Use the given middleware `fn`.\n   *\n   * Old-style middleware will be converted.\n   *\n   * @param {Function} fn\n   * @return {Application} self\n   * @api public\n   */\n\n  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),\n  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.\n  use(fn) {\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n    if (isGeneratorFunction(fn)) {\n      deprecate('Support for generators will be removed in v3. ' +\n                'See the documentation for examples of how to convert old middleware ' +\n                'https://github.com/koajs/koa/blob/master/docs/migration.md');\n      fn = convert(fn);\n    }\n    debug('use %s', fn._name || fn.name || '-');\n    this.middleware.push(fn);\n    return this;\n  }\n\n  /**\n   * Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public\n   */\n\n  callback() {\n    //合并中间件\n    const fn = compose(this.middleware);\n\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  /**\n   * Handle request in callback.\n   *\n   * @api private\n   */\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  /**\n   * Initialize a new context.\n   *\n   * @api private\n   */\n\n   //创建cotext request reponse 与http模块的关系\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n\n  /**\n   * Default error handler.\n   *\n   * @param {Error} err\n   * @api private\n   */\n\n  onerror(err) {\n    if (!(err instanceof Error)) throw new TypeError(util.format('non-error thrown: %j', err));\n\n    if (404 == err.status || err.expose) return;\n    if (this.silent) return;\n\n    const msg = err.stack || err.toString();\n    console.error();\n    console.error(msg.replace(/^/gm, '  '));\n    console.error();\n  }\n};\n\n/**\n * Response helper.\n */\n\nfunction respond(ctx) {\n  // allow bypassing koa\n  if (false === ctx.respond) return;\n\n  const res = ctx.res;\n  if (!ctx.writable) return;\n\n  let body = ctx.body;\n  const code = ctx.status;\n\n  // ignore body\n  if (statuses.empty[code]) {\n    // strip headers\n    ctx.body = null;\n    return res.end();\n  }\n\n  if ('HEAD' == ctx.method) {\n    if (!res.headersSent && isJSON(body)) {\n      ctx.length = Buffer.byteLength(JSON.stringify(body));\n    }\n    return res.end();\n  }\n\n  // status body\n  if (null == body) {\n    body = ctx.message || String(code);\n    if (!res.headersSent) {\n      ctx.type = 'text';\n      ctx.length = Buffer.byteLength(body);\n    }\n    return res.end(body);\n  }\n\n  // responses\n  if (Buffer.isBuffer(body)) return res.end(body);\n  if ('string' == typeof body) return res.end(body);\n  if (body instanceof Stream) return body.pipe(res);\n\n  // body: json\n  body = JSON.stringify(body);\n  if (!res.headersSent) {\n    ctx.length = Buffer.byteLength(body);\n  }\n  res.end(body);\n}\n```\n其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。\n<br>\n当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br>\n最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。\n\n### compose.js\n\n```bash\nuse strict'\n\n/**\n * Expose compositor.\n */\n\nmodule.exports = compose\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\n\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1; //当前中间件的索引\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\ncompose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\" />\n其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。\n","slug":"node-koaMiddle","published":1,"updated":"2019-09-17T02:41:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw93002fkwfygno4bufd","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"js的异步解决方案\"><a href=\"#js的异步解决方案\" class=\"headerlink\" title=\"js的异步解决方案\"></a>js的异步解决方案</h3><p>在javascript里，异步的解决方案包括以下几种：</p>\n<ul>\n<li>回调</li>\n<li>promise</li>\n<li>generator</li>\n<li>async<br>优雅程度自上而下。<a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"express-koa1-koa2\"><a href=\"#express-koa1-koa2\" class=\"headerlink\" title=\"express koa1 koa2\"></a>express koa1 koa2</h3><p>随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br></p>\n<p>koa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。<br><br></p>\n<p>在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。<br>个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br></p>\n<h3 id=\"application-js\"><a href=\"#application-js\" class=\"headerlink\" title=\"application.js\"></a>application.js</h3><p>koa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Module dependencies.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">const isGeneratorFunction = require(<span class=\"string\">'is-generator-function'</span>);</span><br><span class=\"line\">const debug = require(<span class=\"string\">'debug'</span>)(<span class=\"string\">'koa:application'</span>);</span><br><span class=\"line\">const onFinished = require(<span class=\"string\">'on-finished'</span>);</span><br><span class=\"line\">const response = require(<span class=\"string\">'./response'</span>);</span><br><span class=\"line\">const compose = require(<span class=\"string\">'koa-compose'</span>);</span><br><span class=\"line\">const isJSON = require(<span class=\"string\">'koa-is-json'</span>);</span><br><span class=\"line\">const context = require(<span class=\"string\">'./context'</span>);</span><br><span class=\"line\">const request = require(<span class=\"string\">'./request'</span>);</span><br><span class=\"line\">const statuses = require(<span class=\"string\">'statuses'</span>);</span><br><span class=\"line\">const Emitter = require(<span class=\"string\">'events'</span>);</span><br><span class=\"line\">const util = require(<span class=\"string\">'util'</span>);</span><br><span class=\"line\">const Stream = require(<span class=\"string\">'stream'</span>);</span><br><span class=\"line\">const http = require(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">const only = require(<span class=\"string\">'only'</span>);</span><br><span class=\"line\">const convert = require(<span class=\"string\">'koa-convert'</span>);</span><br><span class=\"line\">const deprecate = require(<span class=\"string\">'depd'</span>)(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Expose `Application` class.</span><br><span class=\"line\"> * Inherits from `Emitter.prototype`.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\"> //继承Emitter  因此 koa的实例 this可以调用on</span><br><span class=\"line\">module.exports = class Application extends Emitter &#123;</span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Initialize a new `Application`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span></span>() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\"></span><br><span class=\"line\">    this.proxy = <span class=\"literal\">false</span>; //代理设置</span><br><span class=\"line\">    this.middleware = [];</span><br><span class=\"line\">    this.subdomainOffset = 2; //域名偏移</span><br><span class=\"line\">    this.env = process.env.NODE_ENV || <span class=\"string\">'development'</span>;</span><br><span class=\"line\">    this.context = Object.create(context);</span><br><span class=\"line\">    this.request = Object.create(request);</span><br><span class=\"line\">    this.response = Object.create(response);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (util.inspect.custom) &#123;</span><br><span class=\"line\">      this[util.inspect.custom] = this.inspect;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Shorthand <span class=\"keyword\">for</span>:</span><br><span class=\"line\">   *</span><br><span class=\"line\">   *    http.createServer(app.callback()).listen(...)</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Mixed&#125; ...</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Server&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  listen(...args) &#123;</span><br><span class=\"line\">    debug(<span class=\"string\">'listen'</span>);</span><br><span class=\"line\">    const server = http.createServer(this.callback());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> server.listen(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return JSON representation.</span><br><span class=\"line\">   * We only bother showing settings.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toJSON</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> only(this, [</span><br><span class=\"line\">      <span class=\"string\">'subdomainOffset'</span>,</span><br><span class=\"line\">      <span class=\"string\">'proxy'</span>,</span><br><span class=\"line\">      <span class=\"string\">'env'</span></span><br><span class=\"line\">    ]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Inspect implementation.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inspect</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this.toJSON();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Use the given middleware `fn`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * Old-style middleware will be converted.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Function&#125; fn</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Application&#125; self</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),</span><br><span class=\"line\">  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof fn !== <span class=\"string\">'function'</span>) throw new TypeError(<span class=\"string\">'middleware must be a function!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class=\"line\">      deprecate(<span class=\"string\">'Support for generators will be removed in v3. '</span> +</span><br><span class=\"line\">                <span class=\"string\">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class=\"line\">                <span class=\"string\">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class=\"line\">      fn = convert(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debug(<span class=\"string\">'use %s'</span>, fn._name || fn.name || <span class=\"string\">'-'</span>);</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return a request handler callback</span><br><span class=\"line\">   * <span class=\"keyword\">for</span> node<span class=\"string\">'s native http server.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  callback() &#123;</span></span><br><span class=\"line\"><span class=\"string\">    //合并中间件</span></span><br><span class=\"line\"><span class=\"string\">    const fn = compose(this.middleware);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (!this.listenerCount('</span>error<span class=\"string\">')) this.on('</span>error<span class=\"string\">', this.onerror);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const handleRequest = (req, res) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">      const ctx = this.createContext(req, res);</span></span><br><span class=\"line\"><span class=\"string\">      return this.handleRequest(ctx, fn);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    return handleRequest;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Handle request in callback.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  handleRequest(ctx, fnMiddleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">    res.statusCode = 404;</span></span><br><span class=\"line\"><span class=\"string\">    const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class=\"line\"><span class=\"string\">    const handleResponse = () =&gt; respond(ctx);</span></span><br><span class=\"line\"><span class=\"string\">    onFinished(res, onerror);</span></span><br><span class=\"line\"><span class=\"string\">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Initialize a new context.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">   //创建cotext request reponse 与http模块的关系</span></span><br><span class=\"line\"><span class=\"string\">  createContext(req, res) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const context = Object.create(this.context);</span></span><br><span class=\"line\"><span class=\"string\">    const request = context.request = Object.create(this.request);</span></span><br><span class=\"line\"><span class=\"string\">    const response = context.response = Object.create(this.response);</span></span><br><span class=\"line\"><span class=\"string\">    context.app = request.app = response.app = this;</span></span><br><span class=\"line\"><span class=\"string\">    context.req = request.req = response.req = req;</span></span><br><span class=\"line\"><span class=\"string\">    context.res = request.res = response.res = res;</span></span><br><span class=\"line\"><span class=\"string\">    request.ctx = response.ctx = context;</span></span><br><span class=\"line\"><span class=\"string\">    request.response = response;</span></span><br><span class=\"line\"><span class=\"string\">    response.request = request;</span></span><br><span class=\"line\"><span class=\"string\">    context.originalUrl = request.originalUrl = req.url;</span></span><br><span class=\"line\"><span class=\"string\">    context.state = &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\">    return context;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Default error handler.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Error&#125; err</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  onerror(err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!(err instanceof Error)) throw new TypeError(util.format('</span>non-error thrown: %j<span class=\"string\">', err));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (404 == err.status || err.expose) return;</span></span><br><span class=\"line\"><span class=\"string\">    if (this.silent) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const msg = err.stack || err.toString();</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">    console.error(msg.replace(/^/gm, '</span>  <span class=\"string\">'));</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Response helper.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function respond(ctx) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  // allow bypassing koa</span></span><br><span class=\"line\"><span class=\"string\">  if (false === ctx.respond) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">  if (!ctx.writable) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  let body = ctx.body;</span></span><br><span class=\"line\"><span class=\"string\">  const code = ctx.status;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // ignore body</span></span><br><span class=\"line\"><span class=\"string\">  if (statuses.empty[code]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // strip headers</span></span><br><span class=\"line\"><span class=\"string\">    ctx.body = null;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>HEAD<span class=\"string\">' == ctx.method) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // status body</span></span><br><span class=\"line\"><span class=\"string\">  if (null == body) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    body = ctx.message || String(code);</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.type = '</span>text<span class=\"string\">';</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // responses</span></span><br><span class=\"line\"><span class=\"string\">  if (Buffer.isBuffer(body)) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>string<span class=\"string\">' == typeof body) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (body instanceof Stream) return body.pipe(res);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // body: json</span></span><br><span class=\"line\"><span class=\"string\">  body = JSON.stringify(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。<br><br><br>当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br><br>最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。</p>\n<h3 id=\"compose-js\"><a href=\"#compose-js\" class=\"headerlink\" title=\"compose.js\"></a>compose.js</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use strict<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Expose compositor.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">module.exports = compose</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Compose `middleware` returning</span></span><br><span class=\"line\"><span class=\"string\"> * a fully valid middleware comprised</span></span><br><span class=\"line\"><span class=\"string\"> * of all those which are passed.</span></span><br><span class=\"line\"><span class=\"string\"> *</span></span><br><span class=\"line\"><span class=\"string\"> * @param &#123;Array&#125; middleware</span></span><br><span class=\"line\"><span class=\"string\"> * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\"> * @api public</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function compose (middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  if (!Array.isArray(middleware)) throw new TypeError('</span>Middleware stack must be an array!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  for (const fn of middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (typeof fn !== '</span><span class=\"keyword\">function</span><span class=\"string\">') throw new TypeError('</span>Middleware must be composed of <span class=\"built_in\">functions</span>!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Object&#125; context</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Promise&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  return function (context, next) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // last called middleware #</span></span><br><span class=\"line\"><span class=\"string\">    let index = -1; //当前中间件的索引</span></span><br><span class=\"line\"><span class=\"string\">    return dispatch(0)</span></span><br><span class=\"line\"><span class=\"string\">    function dispatch (i) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      if (i &lt;= index) return Promise.reject(new Error('</span>next() called multiple <span class=\"built_in\">times</span><span class=\"string\">'))</span></span><br><span class=\"line\"><span class=\"string\">      index = i</span></span><br><span class=\"line\"><span class=\"string\">      let fn = middleware[i]</span></span><br><span class=\"line\"><span class=\"string\">      if (i === middleware.length) fn = next</span></span><br><span class=\"line\"><span class=\"string\">      if (!fn) return Promise.resolve()</span></span><br><span class=\"line\"><span class=\"string\">      try &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span></span><br><span class=\"line\"><span class=\"string\">      &#125; catch (err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.reject(err)</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>compose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\"><br>其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"js的异步解决方案\"><a href=\"#js的异步解决方案\" class=\"headerlink\" title=\"js的异步解决方案\"></a>js的异步解决方案</h3><p>在javascript里，异步的解决方案包括以下几种：</p>\n<ul>\n<li>回调</li>\n<li>promise</li>\n<li>generator</li>\n<li>async<br>优雅程度自上而下。","more":"</li>\n</ul>\n<h3 id=\"express-koa1-koa2\"><a href=\"#express-koa1-koa2\" class=\"headerlink\" title=\"express koa1 koa2\"></a>express koa1 koa2</h3><p>随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br></p>\n<p>koa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。<br><br></p>\n<p>在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。<br>个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br></p>\n<h3 id=\"application-js\"><a href=\"#application-js\" class=\"headerlink\" title=\"application.js\"></a>application.js</h3><p>koa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Module dependencies.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">const isGeneratorFunction = require(<span class=\"string\">'is-generator-function'</span>);</span><br><span class=\"line\">const debug = require(<span class=\"string\">'debug'</span>)(<span class=\"string\">'koa:application'</span>);</span><br><span class=\"line\">const onFinished = require(<span class=\"string\">'on-finished'</span>);</span><br><span class=\"line\">const response = require(<span class=\"string\">'./response'</span>);</span><br><span class=\"line\">const compose = require(<span class=\"string\">'koa-compose'</span>);</span><br><span class=\"line\">const isJSON = require(<span class=\"string\">'koa-is-json'</span>);</span><br><span class=\"line\">const context = require(<span class=\"string\">'./context'</span>);</span><br><span class=\"line\">const request = require(<span class=\"string\">'./request'</span>);</span><br><span class=\"line\">const statuses = require(<span class=\"string\">'statuses'</span>);</span><br><span class=\"line\">const Emitter = require(<span class=\"string\">'events'</span>);</span><br><span class=\"line\">const util = require(<span class=\"string\">'util'</span>);</span><br><span class=\"line\">const Stream = require(<span class=\"string\">'stream'</span>);</span><br><span class=\"line\">const http = require(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">const only = require(<span class=\"string\">'only'</span>);</span><br><span class=\"line\">const convert = require(<span class=\"string\">'koa-convert'</span>);</span><br><span class=\"line\">const deprecate = require(<span class=\"string\">'depd'</span>)(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Expose `Application` class.</span><br><span class=\"line\"> * Inherits from `Emitter.prototype`.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\"> //继承Emitter  因此 koa的实例 this可以调用on</span><br><span class=\"line\">module.exports = class Application extends Emitter &#123;</span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Initialize a new `Application`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span></span>() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\"></span><br><span class=\"line\">    this.proxy = <span class=\"literal\">false</span>; //代理设置</span><br><span class=\"line\">    this.middleware = [];</span><br><span class=\"line\">    this.subdomainOffset = 2; //域名偏移</span><br><span class=\"line\">    this.env = process.env.NODE_ENV || <span class=\"string\">'development'</span>;</span><br><span class=\"line\">    this.context = Object.create(context);</span><br><span class=\"line\">    this.request = Object.create(request);</span><br><span class=\"line\">    this.response = Object.create(response);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (util.inspect.custom) &#123;</span><br><span class=\"line\">      this[util.inspect.custom] = this.inspect;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Shorthand <span class=\"keyword\">for</span>:</span><br><span class=\"line\">   *</span><br><span class=\"line\">   *    http.createServer(app.callback()).listen(...)</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Mixed&#125; ...</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Server&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  listen(...args) &#123;</span><br><span class=\"line\">    debug(<span class=\"string\">'listen'</span>);</span><br><span class=\"line\">    const server = http.createServer(this.callback());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> server.listen(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return JSON representation.</span><br><span class=\"line\">   * We only bother showing settings.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toJSON</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> only(this, [</span><br><span class=\"line\">      <span class=\"string\">'subdomainOffset'</span>,</span><br><span class=\"line\">      <span class=\"string\">'proxy'</span>,</span><br><span class=\"line\">      <span class=\"string\">'env'</span></span><br><span class=\"line\">    ]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Inspect implementation.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inspect</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this.toJSON();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Use the given middleware `fn`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * Old-style middleware will be converted.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Function&#125; fn</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Application&#125; self</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),</span><br><span class=\"line\">  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof fn !== <span class=\"string\">'function'</span>) throw new TypeError(<span class=\"string\">'middleware must be a function!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class=\"line\">      deprecate(<span class=\"string\">'Support for generators will be removed in v3. '</span> +</span><br><span class=\"line\">                <span class=\"string\">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class=\"line\">                <span class=\"string\">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class=\"line\">      fn = convert(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debug(<span class=\"string\">'use %s'</span>, fn._name || fn.name || <span class=\"string\">'-'</span>);</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return a request handler callback</span><br><span class=\"line\">   * <span class=\"keyword\">for</span> node<span class=\"string\">'s native http server.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  callback() &#123;</span></span><br><span class=\"line\"><span class=\"string\">    //合并中间件</span></span><br><span class=\"line\"><span class=\"string\">    const fn = compose(this.middleware);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (!this.listenerCount('</span>error<span class=\"string\">')) this.on('</span>error<span class=\"string\">', this.onerror);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const handleRequest = (req, res) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">      const ctx = this.createContext(req, res);</span></span><br><span class=\"line\"><span class=\"string\">      return this.handleRequest(ctx, fn);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    return handleRequest;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Handle request in callback.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  handleRequest(ctx, fnMiddleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">    res.statusCode = 404;</span></span><br><span class=\"line\"><span class=\"string\">    const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class=\"line\"><span class=\"string\">    const handleResponse = () =&gt; respond(ctx);</span></span><br><span class=\"line\"><span class=\"string\">    onFinished(res, onerror);</span></span><br><span class=\"line\"><span class=\"string\">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Initialize a new context.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">   //创建cotext request reponse 与http模块的关系</span></span><br><span class=\"line\"><span class=\"string\">  createContext(req, res) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const context = Object.create(this.context);</span></span><br><span class=\"line\"><span class=\"string\">    const request = context.request = Object.create(this.request);</span></span><br><span class=\"line\"><span class=\"string\">    const response = context.response = Object.create(this.response);</span></span><br><span class=\"line\"><span class=\"string\">    context.app = request.app = response.app = this;</span></span><br><span class=\"line\"><span class=\"string\">    context.req = request.req = response.req = req;</span></span><br><span class=\"line\"><span class=\"string\">    context.res = request.res = response.res = res;</span></span><br><span class=\"line\"><span class=\"string\">    request.ctx = response.ctx = context;</span></span><br><span class=\"line\"><span class=\"string\">    request.response = response;</span></span><br><span class=\"line\"><span class=\"string\">    response.request = request;</span></span><br><span class=\"line\"><span class=\"string\">    context.originalUrl = request.originalUrl = req.url;</span></span><br><span class=\"line\"><span class=\"string\">    context.state = &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\">    return context;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Default error handler.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Error&#125; err</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  onerror(err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!(err instanceof Error)) throw new TypeError(util.format('</span>non-error thrown: %j<span class=\"string\">', err));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (404 == err.status || err.expose) return;</span></span><br><span class=\"line\"><span class=\"string\">    if (this.silent) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const msg = err.stack || err.toString();</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">    console.error(msg.replace(/^/gm, '</span>  <span class=\"string\">'));</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Response helper.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function respond(ctx) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  // allow bypassing koa</span></span><br><span class=\"line\"><span class=\"string\">  if (false === ctx.respond) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">  if (!ctx.writable) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  let body = ctx.body;</span></span><br><span class=\"line\"><span class=\"string\">  const code = ctx.status;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // ignore body</span></span><br><span class=\"line\"><span class=\"string\">  if (statuses.empty[code]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // strip headers</span></span><br><span class=\"line\"><span class=\"string\">    ctx.body = null;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>HEAD<span class=\"string\">' == ctx.method) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // status body</span></span><br><span class=\"line\"><span class=\"string\">  if (null == body) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    body = ctx.message || String(code);</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.type = '</span>text<span class=\"string\">';</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // responses</span></span><br><span class=\"line\"><span class=\"string\">  if (Buffer.isBuffer(body)) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>string<span class=\"string\">' == typeof body) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (body instanceof Stream) return body.pipe(res);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // body: json</span></span><br><span class=\"line\"><span class=\"string\">  body = JSON.stringify(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。<br><br><br>当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br><br>最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。</p>\n<h3 id=\"compose-js\"><a href=\"#compose-js\" class=\"headerlink\" title=\"compose.js\"></a>compose.js</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use strict<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Expose compositor.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">module.exports = compose</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Compose `middleware` returning</span></span><br><span class=\"line\"><span class=\"string\"> * a fully valid middleware comprised</span></span><br><span class=\"line\"><span class=\"string\"> * of all those which are passed.</span></span><br><span class=\"line\"><span class=\"string\"> *</span></span><br><span class=\"line\"><span class=\"string\"> * @param &#123;Array&#125; middleware</span></span><br><span class=\"line\"><span class=\"string\"> * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\"> * @api public</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function compose (middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  if (!Array.isArray(middleware)) throw new TypeError('</span>Middleware stack must be an array!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  for (const fn of middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (typeof fn !== '</span><span class=\"keyword\">function</span><span class=\"string\">') throw new TypeError('</span>Middleware must be composed of <span class=\"built_in\">functions</span>!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Object&#125; context</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Promise&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  return function (context, next) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // last called middleware #</span></span><br><span class=\"line\"><span class=\"string\">    let index = -1; //当前中间件的索引</span></span><br><span class=\"line\"><span class=\"string\">    return dispatch(0)</span></span><br><span class=\"line\"><span class=\"string\">    function dispatch (i) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      if (i &lt;= index) return Promise.reject(new Error('</span>next() called multiple <span class=\"built_in\">times</span><span class=\"string\">'))</span></span><br><span class=\"line\"><span class=\"string\">      index = i</span></span><br><span class=\"line\"><span class=\"string\">      let fn = middleware[i]</span></span><br><span class=\"line\"><span class=\"string\">      if (i === middleware.length) fn = next</span></span><br><span class=\"line\"><span class=\"string\">      if (!fn) return Promise.resolve()</span></span><br><span class=\"line\"><span class=\"string\">      try &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span></span><br><span class=\"line\"><span class=\"string\">      &#125; catch (err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.reject(err)</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>compose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\"><br>其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。</p>"},{"title":"JSX","date":"2018-04-05T04:25:14.000Z","_content":"\n>学了React有差不多俩星期了，做个总结。\n\n### 什么是JSX\n\nJSX=JavaScriptXml<br>\nJSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。\n\n<!--more-->\n\n### javascript表达式\n\n要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（\"\"）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。\n\n### 关于用法和注意事项\n\n官网有一篇深入JSX[点击这里](https://doc.react-china.org/docs/jsx-in-depth.html)\n\n###  组件是啥\n```bash\nconsole.log(<App/>)\n```\n如图所示：\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png)\n\nas  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。\n接下来\n```bash\nconsole.log(<ToDoList name={'todo'} onClick={()=>{console.log('ss')}}/>)<br>\n```\n\n在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png);\n可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。\n可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开[在线Babel编译器](https://babeljs.io/repl)，输入\n```bash\nfunction hello(){\n  return (<div>hello</div>)\n}\n```\n可以看到![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png)\nbabel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。\n那么这个函数是干嘛使得呢？o98k，接下来好好看看。\n\n### createElemnt\n首先把React源码的地址贴上，[REACT源码](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js)，有兴趣的小伙伴可以复制下来看看。\n在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。\n\n在源码的481行，可以找到这个函数，他有三个参数：\n+ type 标签名\n+ config 配置信息className，事件啥的，没有则为null\n+ children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是'hello'，有意思的时当里面的元素是嵌套了一层的话，比如\n```bash\nreturn (<div><p>sss</p></div>)\n```\n那么children对应的值就是React.createElement的返回结果。\n这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件\n\n\n```bash\nfunction TodoItem(){\n  reutn (<div className=\"foo\"  onClick={()=>{cconsole.log('sss')}} >\n           <p>sss</p>\n        </div>)\n}\n\n\n<TodoItem />\n```\n在右边可以看到如下代码\n```bash\n\"use strict\";\n\nfunction TodoItem() {\n  reutn(React.createElement(\n    \"div\",\n    { className: \"foo\", onClick: function onClick() {\n        cconsole.log('sss');\n      } },\n    React.createElement(\n      \"p\",\n      null,\n      \"sss\"\n    )\n  ));\n}\n\nReact.createElement(TodoItem, null);\n\n```\n\n可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。\n\ncreateElement源码：\n\n```bash\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName;\n\n  // 内置静态变量，作为参数传递给ReactElement方法\n\n  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n    //todo self 和 source 都是通过 props 传入的\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source\n        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n\n  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  //todo 把组件的默认属性值赋予组件的实例上\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n```\n\n看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。\n但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。\n\n### ReactElement\n先看参数\n+ type: 使用 React.createElement创建的 React 组件\n+ key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能\n+ ref: 这个 ReactElement 的 ref，真实DOM的引用\n+ props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)\n+ self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。\n+ source: 中包含了一些文件名称，行号等信息。\n+ owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。\nReactElement 这个函数只是将以上参数放入一个对象，并返回。\n源码如下：\n```bash\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    //作为ReactElement的标识，运用ES6的Symbol\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n\n    element._store = {};\n\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n```\n该方法在其他方法中也经常被调用，结果被return。\n\n### React.Component\n\n我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。\n```bash\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n```\n贴张图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png)\n","source":"_posts/react-JSX.md","raw":"---\ntitle: JSX\ndate: 2018-04-05 12:25:14\ntags: react\ncategories: 学习\n---\n\n>学了React有差不多俩星期了，做个总结。\n\n### 什么是JSX\n\nJSX=JavaScriptXml<br>\nJSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。\n\n<!--more-->\n\n### javascript表达式\n\n要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（\"\"）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。\n\n### 关于用法和注意事项\n\n官网有一篇深入JSX[点击这里](https://doc.react-china.org/docs/jsx-in-depth.html)\n\n###  组件是啥\n```bash\nconsole.log(<App/>)\n```\n如图所示：\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png)\n\nas  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。\n接下来\n```bash\nconsole.log(<ToDoList name={'todo'} onClick={()=>{console.log('ss')}}/>)<br>\n```\n\n在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png);\n可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。\n可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开[在线Babel编译器](https://babeljs.io/repl)，输入\n```bash\nfunction hello(){\n  return (<div>hello</div>)\n}\n```\n可以看到![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png)\nbabel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。\n那么这个函数是干嘛使得呢？o98k，接下来好好看看。\n\n### createElemnt\n首先把React源码的地址贴上，[REACT源码](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js)，有兴趣的小伙伴可以复制下来看看。\n在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。\n\n在源码的481行，可以找到这个函数，他有三个参数：\n+ type 标签名\n+ config 配置信息className，事件啥的，没有则为null\n+ children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是'hello'，有意思的时当里面的元素是嵌套了一层的话，比如\n```bash\nreturn (<div><p>sss</p></div>)\n```\n那么children对应的值就是React.createElement的返回结果。\n这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件\n\n\n```bash\nfunction TodoItem(){\n  reutn (<div className=\"foo\"  onClick={()=>{cconsole.log('sss')}} >\n           <p>sss</p>\n        </div>)\n}\n\n\n<TodoItem />\n```\n在右边可以看到如下代码\n```bash\n\"use strict\";\n\nfunction TodoItem() {\n  reutn(React.createElement(\n    \"div\",\n    { className: \"foo\", onClick: function onClick() {\n        cconsole.log('sss');\n      } },\n    React.createElement(\n      \"p\",\n      null,\n      \"sss\"\n    )\n  ));\n}\n\nReact.createElement(TodoItem, null);\n\n```\n\n可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。\n\ncreateElement源码：\n\n```bash\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName;\n\n  // 内置静态变量，作为参数传递给ReactElement方法\n\n  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n    //todo self 和 source 都是通过 props 传入的\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source\n        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n\n  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  //todo 把组件的默认属性值赋予组件的实例上\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n```\n\n看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。\n但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。\n\n### ReactElement\n先看参数\n+ type: 使用 React.createElement创建的 React 组件\n+ key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能\n+ ref: 这个 ReactElement 的 ref，真实DOM的引用\n+ props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)\n+ self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。\n+ source: 中包含了一些文件名称，行号等信息。\n+ owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。\nReactElement 这个函数只是将以上参数放入一个对象，并返回。\n源码如下：\n```bash\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    //作为ReactElement的标识，运用ES6的Symbol\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n\n    element._store = {};\n\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n```\n该方法在其他方法中也经常被调用，结果被return。\n\n### React.Component\n\n我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。\n```bash\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n```\n贴张图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png)\n","slug":"react-JSX","published":1,"updated":"2019-09-17T02:41:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw94002hkwfyk00qbzza","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>学了React有差不多俩星期了，做个总结。</p>\n</blockquote>\n<h3 id=\"什么是JSX\"><a href=\"#什么是JSX\" class=\"headerlink\" title=\"什么是JSX\"></a>什么是JSX</h3><p>JSX=JavaScriptXml<br><br>JSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。</p>\n<a id=\"more\"></a>\n<h3 id=\"javascript表达式\"><a href=\"#javascript表达式\" class=\"headerlink\" title=\"javascript表达式\"></a>javascript表达式</h3><p>要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（””）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。</p>\n<h3 id=\"关于用法和注意事项\"><a href=\"#关于用法和注意事项\" class=\"headerlink\" title=\"关于用法和注意事项\"></a>关于用法和注意事项</h3><p>官网有一篇深入JSX<a href=\"https://doc.react-china.org/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h3 id=\"组件是啥\"><a href=\"#组件是啥\" class=\"headerlink\" title=\"组件是啥\"></a>组件是啥</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;App/&gt;)</span><br></pre></td></tr></table></figure>\n<p>如图所示：<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png\" alt></p>\n<p>as  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。<br>接下来<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;ToDoList name=&#123;<span class=\"string\">'todo'</span>&#125; onClick=&#123;()=&gt;&#123;console.log(<span class=\"string\">'ss'</span>)&#125;&#125;/&gt;)&lt;br&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png\" alt>;<br>可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。<br>可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开<a href=\"https://babeljs.io/repl\" target=\"_blank\" rel=\"noopener\">在线Babel编译器</a>，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">hello</span></span>()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (&lt;div&gt;hello&lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png\" alt><br>babel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。<br>那么这个函数是干嘛使得呢？o98k，接下来好好看看。</p>\n<h3 id=\"createElemnt\"><a href=\"#createElemnt\" class=\"headerlink\" title=\"createElemnt\"></a>createElemnt</h3><p>首先把React源码的地址贴上，<a href=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js\" target=\"_blank\" rel=\"noopener\">REACT源码</a>，有兴趣的小伙伴可以复制下来看看。<br>在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。</p>\n<p>在源码的481行，可以找到这个函数，他有三个参数：</p>\n<ul>\n<li>type 标签名</li>\n<li>config 配置信息className，事件啥的，没有则为null</li>\n<li>children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是’hello’，有意思的时当里面的元素是嵌套了一层的话，比如<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">return</span> (&lt;div&gt;&lt;p&gt;sss&lt;/p&gt;&lt;/div&gt;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>那么children对应的值就是React.createElement的返回结果。<br>这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>()&#123;</span><br><span class=\"line\">  reutn (&lt;div className=<span class=\"string\">\"foo\"</span>  onClick=&#123;()=&gt;&#123;cconsole.log(<span class=\"string\">'sss'</span>)&#125;&#125; &gt;</span><br><span class=\"line\">           &lt;p&gt;sss&lt;/p&gt;</span><br><span class=\"line\">        &lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;TodoItem /&gt;</span><br></pre></td></tr></table></figure>\n<p>在右边可以看到如下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>() &#123;</span><br><span class=\"line\">  reutn(React.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    &#123; className: <span class=\"string\">\"foo\"</span>, onClick: <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">onClick</span></span>() &#123;</span><br><span class=\"line\">        cconsole.log(<span class=\"string\">'sss'</span>);</span><br><span class=\"line\">      &#125; &#125;,</span><br><span class=\"line\">    React.createElement(</span><br><span class=\"line\">      <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">      null,</span><br><span class=\"line\">      <span class=\"string\">\"sss\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  ));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">React.createElement(TodoItem, null);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。</p>\n<p>createElement源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Create and <span class=\"built_in\">return</span> a new ReactElement of the given <span class=\"built_in\">type</span>.</span><br><span class=\"line\"> * See https://reactjs.org/docs/react-api.html<span class=\"comment\">#createelement</span></span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> createElement(<span class=\"built_in\">type</span>, config, children) &#123;</span><br><span class=\"line\">  var propName;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 内置静态变量，作为参数传递给ReactElement方法</span><br><span class=\"line\"></span><br><span class=\"line\">  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性</span><br><span class=\"line\">  var props = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var key = null;</span><br><span class=\"line\">  var ref = null;</span><br><span class=\"line\">  var self = null;</span><br><span class=\"line\">  var <span class=\"built_in\">source</span> = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config != null) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"string\">''</span> + config.key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //todo self 和 <span class=\"built_in\">source</span> 都是通过 props 传入的</span><br><span class=\"line\">    self = config.__self === undefined ? null : config.__self;</span><br><span class=\"line\">    <span class=\"built_in\">source</span> = config.__source === undefined ? null : config.__source;</span><br><span class=\"line\">    // Remaining properties are added to a new props object</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> config) &#123;</span><br><span class=\"line\">        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class=\"line\">        props[propName] = config[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。</span><br><span class=\"line\">  var childrenLength = arguments.length - 2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childrenLength === 1) &#123;</span><br><span class=\"line\">    props.children = children;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenLength &gt; 1) &#123;</span><br><span class=\"line\">    var childArray = Array(childrenLength);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class=\"line\">      childArray[i] = arguments[i + 2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">        Object.freeze(childArray);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    props.children = childArray;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //todo 把组件的默认属性值赋予组件的实例上</span><br><span class=\"line\">  // Resolve default props</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">type</span> &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    var defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> defaultProps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (props[propName] === undefined) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key || ref) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (typeof props.$<span class=\"variable\">$typeof</span> === <span class=\"string\">'undefined'</span> || props.$<span class=\"variable\">$typeof</span> !== REACT_ELEMENT_TYPE) &#123;</span><br><span class=\"line\">        var displayName = typeof <span class=\"built_in\">type</span> === <span class=\"string\">'function'</span> ? type.displayName || type.name || <span class=\"string\">'Unknown'</span> : <span class=\"built_in\">type</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key) &#123;</span><br><span class=\"line\">          defineKeyPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ref) &#123;</span><br><span class=\"line\">          defineRefPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> ReactElement(<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, ReactCurrentOwner.current, props);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。<br>但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。</p>\n<h3 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h3><p>先看参数</p>\n<ul>\n<li>type: 使用 React.createElement创建的 React 组件</li>\n<li>key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能</li>\n<li>ref: 这个 ReactElement 的 ref，真实DOM的引用</li>\n<li>props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)</li>\n<li>self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。</li>\n<li>source: 中包含了一些文件名称，行号等信息。</li>\n<li>owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。<br>ReactElement 这个函数只是将以上参数放入一个对象，并返回。<br>源码如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Factory method to create a new React element. This no longer adheres to</span><br><span class=\"line\"> * the class pattern, so <span class=\"keyword\">do</span> not use new to call it. Also, no instanceof check</span><br><span class=\"line\"> * will work. Instead <span class=\"built_in\">test</span> $<span class=\"variable\">$typeof</span> field against Symbol.for(<span class=\"string\">'react.element'</span>) to check</span><br><span class=\"line\"> * <span class=\"keyword\">if</span> something is a React Element.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">type</span></span><br><span class=\"line\"> * @param &#123;*&#125; key</span><br><span class=\"line\"> * @param &#123;string|object&#125; ref</span><br><span class=\"line\"> * @param &#123;*&#125; self A *temporary* helper to detect places <span class=\"built_in\">where</span> `this` is</span><br><span class=\"line\"> * different from the `owner` when React.createElement is called, so that we</span><br><span class=\"line\"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span><br><span class=\"line\"> * <span class=\"built_in\">functions</span>, and as long as `this` and owner are the same, there will be no</span><br><span class=\"line\"> * change <span class=\"keyword\">in</span> behavior.</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">source</span> An annotation object (added by a transpiler or otherwise)</span><br><span class=\"line\"> * indicating filename, line number, and/or other information.</span><br><span class=\"line\"> * @param &#123;*&#125; owner</span><br><span class=\"line\"> * @param &#123;*&#125; props</span><br><span class=\"line\"> * @internal</span><br><span class=\"line\"> */</span><br><span class=\"line\">var ReactElement = <span class=\"keyword\">function</span> (<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, owner, props) &#123;</span><br><span class=\"line\">  var element = &#123;</span><br><span class=\"line\">    //作为ReactElement的标识，运用ES6的Symbol</span><br><span class=\"line\">    $<span class=\"variable\">$typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Built-in properties that belong on the element</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"built_in\">type</span>,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Record the component responsible <span class=\"keyword\">for</span> creating this element.</span><br><span class=\"line\">    _owner: owner</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    element._store = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Object.defineProperty(element._store, <span class=\"string\">'validated'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // self and <span class=\"built_in\">source</span> are DEV only properties.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_self'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: self</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // Two elements created <span class=\"keyword\">in</span> two different places should be considered</span><br><span class=\"line\">    // equal <span class=\"keyword\">for</span> testing purposes and therefore we hide it from enumeration.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_source'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: <span class=\"built_in\">source</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">      Object.freeze(element.props);</span><br><span class=\"line\">      Object.freeze(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> element;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该方法在其他方法中也经常被调用，结果被return。</p>\n<h3 id=\"React-Component\"><a href=\"#React-Component\" class=\"headerlink\" title=\"React.Component\"></a>React.Component</h3><p>我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Component(props, context, updater) &#123;</span><br><span class=\"line\">  this.props = props;</span><br><span class=\"line\">  this.context = context;</span><br><span class=\"line\">  this.refs = emptyObject;</span><br><span class=\"line\">  // We initialize the default updater but the real one gets injected by the</span><br><span class=\"line\">  // renderer.</span><br><span class=\"line\">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Component.prototype.setState = <span class=\"keyword\">function</span> (partialState, callback) &#123;</span><br><span class=\"line\">  !(typeof partialState === <span class=\"string\">'object'</span> || typeof partialState === <span class=\"string\">'function'</span> || partialState == null) ? invariant(<span class=\"literal\">false</span>, <span class=\"string\">'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'</span>) : void 0;</span><br><span class=\"line\">  this.updater.enqueueSetState(this, partialState, callback, <span class=\"string\">'setState'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Component.prototype.forceUpdate = <span class=\"keyword\">function</span> (callback) &#123;</span><br><span class=\"line\">  this.updater.enqueueForceUpdate(this, callback, <span class=\"string\">'forceUpdate'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>贴张图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png\" alt></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>学了React有差不多俩星期了，做个总结。</p>\n</blockquote>\n<h3 id=\"什么是JSX\"><a href=\"#什么是JSX\" class=\"headerlink\" title=\"什么是JSX\"></a>什么是JSX</h3><p>JSX=JavaScriptXml<br><br>JSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。</p>","more":"<h3 id=\"javascript表达式\"><a href=\"#javascript表达式\" class=\"headerlink\" title=\"javascript表达式\"></a>javascript表达式</h3><p>要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（””）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。</p>\n<h3 id=\"关于用法和注意事项\"><a href=\"#关于用法和注意事项\" class=\"headerlink\" title=\"关于用法和注意事项\"></a>关于用法和注意事项</h3><p>官网有一篇深入JSX<a href=\"https://doc.react-china.org/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h3 id=\"组件是啥\"><a href=\"#组件是啥\" class=\"headerlink\" title=\"组件是啥\"></a>组件是啥</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;App/&gt;)</span><br></pre></td></tr></table></figure>\n<p>如图所示：<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png\" alt></p>\n<p>as  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。<br>接下来<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;ToDoList name=&#123;<span class=\"string\">'todo'</span>&#125; onClick=&#123;()=&gt;&#123;console.log(<span class=\"string\">'ss'</span>)&#125;&#125;/&gt;)&lt;br&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png\" alt>;<br>可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。<br>可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开<a href=\"https://babeljs.io/repl\" target=\"_blank\" rel=\"noopener\">在线Babel编译器</a>，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">hello</span></span>()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (&lt;div&gt;hello&lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png\" alt><br>babel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。<br>那么这个函数是干嘛使得呢？o98k，接下来好好看看。</p>\n<h3 id=\"createElemnt\"><a href=\"#createElemnt\" class=\"headerlink\" title=\"createElemnt\"></a>createElemnt</h3><p>首先把React源码的地址贴上，<a href=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js\" target=\"_blank\" rel=\"noopener\">REACT源码</a>，有兴趣的小伙伴可以复制下来看看。<br>在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。</p>\n<p>在源码的481行，可以找到这个函数，他有三个参数：</p>\n<ul>\n<li>type 标签名</li>\n<li>config 配置信息className，事件啥的，没有则为null</li>\n<li>children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是’hello’，有意思的时当里面的元素是嵌套了一层的话，比如<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">return</span> (&lt;div&gt;&lt;p&gt;sss&lt;/p&gt;&lt;/div&gt;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>那么children对应的值就是React.createElement的返回结果。<br>这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>()&#123;</span><br><span class=\"line\">  reutn (&lt;div className=<span class=\"string\">\"foo\"</span>  onClick=&#123;()=&gt;&#123;cconsole.log(<span class=\"string\">'sss'</span>)&#125;&#125; &gt;</span><br><span class=\"line\">           &lt;p&gt;sss&lt;/p&gt;</span><br><span class=\"line\">        &lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;TodoItem /&gt;</span><br></pre></td></tr></table></figure>\n<p>在右边可以看到如下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>() &#123;</span><br><span class=\"line\">  reutn(React.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    &#123; className: <span class=\"string\">\"foo\"</span>, onClick: <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">onClick</span></span>() &#123;</span><br><span class=\"line\">        cconsole.log(<span class=\"string\">'sss'</span>);</span><br><span class=\"line\">      &#125; &#125;,</span><br><span class=\"line\">    React.createElement(</span><br><span class=\"line\">      <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">      null,</span><br><span class=\"line\">      <span class=\"string\">\"sss\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  ));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">React.createElement(TodoItem, null);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。</p>\n<p>createElement源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Create and <span class=\"built_in\">return</span> a new ReactElement of the given <span class=\"built_in\">type</span>.</span><br><span class=\"line\"> * See https://reactjs.org/docs/react-api.html<span class=\"comment\">#createelement</span></span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> createElement(<span class=\"built_in\">type</span>, config, children) &#123;</span><br><span class=\"line\">  var propName;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 内置静态变量，作为参数传递给ReactElement方法</span><br><span class=\"line\"></span><br><span class=\"line\">  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性</span><br><span class=\"line\">  var props = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var key = null;</span><br><span class=\"line\">  var ref = null;</span><br><span class=\"line\">  var self = null;</span><br><span class=\"line\">  var <span class=\"built_in\">source</span> = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config != null) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"string\">''</span> + config.key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //todo self 和 <span class=\"built_in\">source</span> 都是通过 props 传入的</span><br><span class=\"line\">    self = config.__self === undefined ? null : config.__self;</span><br><span class=\"line\">    <span class=\"built_in\">source</span> = config.__source === undefined ? null : config.__source;</span><br><span class=\"line\">    // Remaining properties are added to a new props object</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> config) &#123;</span><br><span class=\"line\">        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class=\"line\">        props[propName] = config[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。</span><br><span class=\"line\">  var childrenLength = arguments.length - 2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childrenLength === 1) &#123;</span><br><span class=\"line\">    props.children = children;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenLength &gt; 1) &#123;</span><br><span class=\"line\">    var childArray = Array(childrenLength);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class=\"line\">      childArray[i] = arguments[i + 2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">        Object.freeze(childArray);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    props.children = childArray;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //todo 把组件的默认属性值赋予组件的实例上</span><br><span class=\"line\">  // Resolve default props</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">type</span> &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    var defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> defaultProps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (props[propName] === undefined) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key || ref) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (typeof props.$<span class=\"variable\">$typeof</span> === <span class=\"string\">'undefined'</span> || props.$<span class=\"variable\">$typeof</span> !== REACT_ELEMENT_TYPE) &#123;</span><br><span class=\"line\">        var displayName = typeof <span class=\"built_in\">type</span> === <span class=\"string\">'function'</span> ? type.displayName || type.name || <span class=\"string\">'Unknown'</span> : <span class=\"built_in\">type</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key) &#123;</span><br><span class=\"line\">          defineKeyPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ref) &#123;</span><br><span class=\"line\">          defineRefPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> ReactElement(<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, ReactCurrentOwner.current, props);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。<br>但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。</p>\n<h3 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h3><p>先看参数</p>\n<ul>\n<li>type: 使用 React.createElement创建的 React 组件</li>\n<li>key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能</li>\n<li>ref: 这个 ReactElement 的 ref，真实DOM的引用</li>\n<li>props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)</li>\n<li>self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。</li>\n<li>source: 中包含了一些文件名称，行号等信息。</li>\n<li>owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。<br>ReactElement 这个函数只是将以上参数放入一个对象，并返回。<br>源码如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Factory method to create a new React element. This no longer adheres to</span><br><span class=\"line\"> * the class pattern, so <span class=\"keyword\">do</span> not use new to call it. Also, no instanceof check</span><br><span class=\"line\"> * will work. Instead <span class=\"built_in\">test</span> $<span class=\"variable\">$typeof</span> field against Symbol.for(<span class=\"string\">'react.element'</span>) to check</span><br><span class=\"line\"> * <span class=\"keyword\">if</span> something is a React Element.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">type</span></span><br><span class=\"line\"> * @param &#123;*&#125; key</span><br><span class=\"line\"> * @param &#123;string|object&#125; ref</span><br><span class=\"line\"> * @param &#123;*&#125; self A *temporary* helper to detect places <span class=\"built_in\">where</span> `this` is</span><br><span class=\"line\"> * different from the `owner` when React.createElement is called, so that we</span><br><span class=\"line\"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span><br><span class=\"line\"> * <span class=\"built_in\">functions</span>, and as long as `this` and owner are the same, there will be no</span><br><span class=\"line\"> * change <span class=\"keyword\">in</span> behavior.</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">source</span> An annotation object (added by a transpiler or otherwise)</span><br><span class=\"line\"> * indicating filename, line number, and/or other information.</span><br><span class=\"line\"> * @param &#123;*&#125; owner</span><br><span class=\"line\"> * @param &#123;*&#125; props</span><br><span class=\"line\"> * @internal</span><br><span class=\"line\"> */</span><br><span class=\"line\">var ReactElement = <span class=\"keyword\">function</span> (<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, owner, props) &#123;</span><br><span class=\"line\">  var element = &#123;</span><br><span class=\"line\">    //作为ReactElement的标识，运用ES6的Symbol</span><br><span class=\"line\">    $<span class=\"variable\">$typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Built-in properties that belong on the element</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"built_in\">type</span>,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Record the component responsible <span class=\"keyword\">for</span> creating this element.</span><br><span class=\"line\">    _owner: owner</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    element._store = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Object.defineProperty(element._store, <span class=\"string\">'validated'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // self and <span class=\"built_in\">source</span> are DEV only properties.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_self'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: self</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // Two elements created <span class=\"keyword\">in</span> two different places should be considered</span><br><span class=\"line\">    // equal <span class=\"keyword\">for</span> testing purposes and therefore we hide it from enumeration.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_source'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: <span class=\"built_in\">source</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">      Object.freeze(element.props);</span><br><span class=\"line\">      Object.freeze(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> element;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该方法在其他方法中也经常被调用，结果被return。</p>\n<h3 id=\"React-Component\"><a href=\"#React-Component\" class=\"headerlink\" title=\"React.Component\"></a>React.Component</h3><p>我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Component(props, context, updater) &#123;</span><br><span class=\"line\">  this.props = props;</span><br><span class=\"line\">  this.context = context;</span><br><span class=\"line\">  this.refs = emptyObject;</span><br><span class=\"line\">  // We initialize the default updater but the real one gets injected by the</span><br><span class=\"line\">  // renderer.</span><br><span class=\"line\">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Component.prototype.setState = <span class=\"keyword\">function</span> (partialState, callback) &#123;</span><br><span class=\"line\">  !(typeof partialState === <span class=\"string\">'object'</span> || typeof partialState === <span class=\"string\">'function'</span> || partialState == null) ? invariant(<span class=\"literal\">false</span>, <span class=\"string\">'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'</span>) : void 0;</span><br><span class=\"line\">  this.updater.enqueueSetState(this, partialState, callback, <span class=\"string\">'setState'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Component.prototype.forceUpdate = <span class=\"keyword\">function</span> (callback) &#123;</span><br><span class=\"line\">  this.updater.enqueueForceUpdate(this, callback, <span class=\"string\">'forceUpdate'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>贴张图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png\" alt></p>"},{"title":"ReactNativeComponent","date":"2018-06-01T03:53:02.000Z","_content":"\n>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。\n>初学了一些东西，做个总结。\n<!--more-->\n### AppRegistry\nAppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。\n要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。\nAppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。\n\n### StyleSheet\nStyleSheet提供了一种类似CSS样式表的抽象。\n创建一个样式表：\n```bash\nvar styles = StyleSheet.create({\n  container: {\n    borderRadius: 4,\n    borderWidth: 0.5,\n    borderColor: '#d6d7da',\n  },\n  title: {\n    fontSize: 19,\n    fontWeight: 'bold',\n  },\n  activeTitle: {\n    color: 'red',\n  },\n});\n```\n使用一个样式表：\n```bash\n<View style={styles.container}>\n  <Text style={[styles.title, this.props.isActive && styles.activeTitle]} />\n</View>\n```\n从代码质量角度：\n从render函数中移除具体的样式内容，可以使代码更清晰易懂。\n给样式命名也是对render函数中的原始组件的作用的一种标记。\n从性能角度：\n创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。\n它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。\n注意：create() 和 hairlineWidth\n这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：\n\n```bash\n{\n    borderBottomColor: '#bbb',\n    borderBottomWidth: StyleSheet.hairlineWidth\n }\n```\n\n这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。\n\n###  Text\n一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。\nAndroid内建的字体有:\n+ normal\n+ serif\n+ monospace <br>\n\n\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n你必须把你的文本节点放在\\<Text>组件内。你不能直接在\\<View>下放置一段文本。\n\n### Image\n#### 宽、高尺寸设置\n+ Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。\n+ 有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：\n```bash\npreciseImageStyle: {\n  width: actrualWidth / PixelRatio.get(),\n  height: actrualHeight / PixelRatio.get(),\n}\n```\n#### Image组件的常见属性\n+ onLayout(function) <br>\n当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.\n\n+ onLoad (function)  <br>\n当图片加载成功之后，回调该方法\n\n+ onLoadEnd (function)  <br>\n当图片加载失败回调该方法，该不会管图片加载成功还是失败\n+ onLoadStart (fcuntion)  <br>\n当图片开始加载的时候调用该方法\n+ resizeMode  <br>\n缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片\n+ source{uri:string}  <br>\n进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径\n它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:\n```bash\n <Image\n                style={{flex: 1}}\n                source={[\n                   {uri:'https://facebook.github.io/react/img/logo_small.png', width: 38, height: 38},\n                  {uri: 'https://facebook.github.io/react/img/logo_small_2x.png', width: 76, height: 76},\n                  {uri: 'https://facebook.github.io/react/img/logo_og.png', width: 400, height: 400}\n                        ]}\n                    />\n\n```\n###  View\n作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。\nView的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。\n\n#### accessible bool\n当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。\n\n如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。\n#### onResponderMove function\n当用户正在屏幕上移动手指时调用这个函数\n\n### Button\n一个简单的跨平台的按钮组件。可以进行一些简单的定制。\ndisabled bool\n设置为true时此按钮将不可点击\n\n title: PropTypes.string.isRequired,\nPlatform.OS === 'android' ? title.toUpperCase() : title;\n\n### FlatList\nFlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。\nFlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。\nFlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。\n\n### SectionList\n如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。\n\n### TouchableOpacity\n本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。\n此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景\n### TouchableHighlight\n<em>注意：TouchableHighlight只支持一个子节点\n如果你希望包含多个子组件，用一个View来包装它们。</em>\n### ScrollView\n一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。\nScrollView和ListView/FlatList应该如何选择？\nScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。\n#### horizontal bool\n当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。\n#### pagingEnabled bool\n当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。\n#### showsHorizontalScrollIndicator bool #\n当此属性为true的时候，显示一个水平方向的滚动条。\n### Dimensions\n本模块用于获取设备屏幕的宽高\n例子：var {height, width} = Dimensions.get('window');\n","source":"_posts/rn-ReactNativeComponent.md","raw":"---\ntitle: ReactNativeComponent\ndate: 2018-06-1 11:53:02\ntags: React Native\ncategories: 学习\n---\n\n>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。\n>初学了一些东西，做个总结。\n<!--more-->\n### AppRegistry\nAppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。\n要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。\nAppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。\n\n### StyleSheet\nStyleSheet提供了一种类似CSS样式表的抽象。\n创建一个样式表：\n```bash\nvar styles = StyleSheet.create({\n  container: {\n    borderRadius: 4,\n    borderWidth: 0.5,\n    borderColor: '#d6d7da',\n  },\n  title: {\n    fontSize: 19,\n    fontWeight: 'bold',\n  },\n  activeTitle: {\n    color: 'red',\n  },\n});\n```\n使用一个样式表：\n```bash\n<View style={styles.container}>\n  <Text style={[styles.title, this.props.isActive && styles.activeTitle]} />\n</View>\n```\n从代码质量角度：\n从render函数中移除具体的样式内容，可以使代码更清晰易懂。\n给样式命名也是对render函数中的原始组件的作用的一种标记。\n从性能角度：\n创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。\n它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。\n注意：create() 和 hairlineWidth\n这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：\n\n```bash\n{\n    borderBottomColor: '#bbb',\n    borderBottomWidth: StyleSheet.hairlineWidth\n }\n```\n\n这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。\n\n###  Text\n一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。\nAndroid内建的字体有:\n+ normal\n+ serif\n+ monospace <br>\n\n\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n你必须把你的文本节点放在\\<Text>组件内。你不能直接在\\<View>下放置一段文本。\n\n### Image\n#### 宽、高尺寸设置\n+ Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。\n+ 有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：\n```bash\npreciseImageStyle: {\n  width: actrualWidth / PixelRatio.get(),\n  height: actrualHeight / PixelRatio.get(),\n}\n```\n#### Image组件的常见属性\n+ onLayout(function) <br>\n当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.\n\n+ onLoad (function)  <br>\n当图片加载成功之后，回调该方法\n\n+ onLoadEnd (function)  <br>\n当图片加载失败回调该方法，该不会管图片加载成功还是失败\n+ onLoadStart (fcuntion)  <br>\n当图片开始加载的时候调用该方法\n+ resizeMode  <br>\n缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片\n+ source{uri:string}  <br>\n进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径\n它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:\n```bash\n <Image\n                style={{flex: 1}}\n                source={[\n                   {uri:'https://facebook.github.io/react/img/logo_small.png', width: 38, height: 38},\n                  {uri: 'https://facebook.github.io/react/img/logo_small_2x.png', width: 76, height: 76},\n                  {uri: 'https://facebook.github.io/react/img/logo_og.png', width: 400, height: 400}\n                        ]}\n                    />\n\n```\n###  View\n作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。\nView的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。\n\n#### accessible bool\n当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。\n\n如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。\n#### onResponderMove function\n当用户正在屏幕上移动手指时调用这个函数\n\n### Button\n一个简单的跨平台的按钮组件。可以进行一些简单的定制。\ndisabled bool\n设置为true时此按钮将不可点击\n\n title: PropTypes.string.isRequired,\nPlatform.OS === 'android' ? title.toUpperCase() : title;\n\n### FlatList\nFlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。\nFlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。\nFlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。\n\n### SectionList\n如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。\n\n### TouchableOpacity\n本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。\n此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景\n### TouchableHighlight\n<em>注意：TouchableHighlight只支持一个子节点\n如果你希望包含多个子组件，用一个View来包装它们。</em>\n### ScrollView\n一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。\nScrollView和ListView/FlatList应该如何选择？\nScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。\n#### horizontal bool\n当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。\n#### pagingEnabled bool\n当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。\n#### showsHorizontalScrollIndicator bool #\n当此属性为true的时候，显示一个水平方向的滚动条。\n### Dimensions\n本模块用于获取设备屏幕的宽高\n例子：var {height, width} = Dimensions.get('window');\n","slug":"rn-ReactNativeComponent","published":1,"updated":"2019-09-17T02:42:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw96002jkwfyp0wfmfwx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。<br>初学了一些东西，做个总结。<br><a id=\"more\"></a></p>\n</blockquote>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>AppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。<br>要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。<br>AppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。</p>\n<h3 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h3><p>StyleSheet提供了一种类似CSS样式表的抽象。<br>创建一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    borderRadius: 4,</span><br><span class=\"line\">    borderWidth: 0.5,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#d6d7da'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: 19,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  activeTitle: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>使用一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">  &lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p>\n<p>从代码质量角度：<br>从render函数中移除具体的样式内容，可以使代码更清晰易懂。<br>给样式命名也是对render函数中的原始组件的作用的一种标记。<br>从性能角度：<br>创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。<br>它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。<br>注意：create() 和 hairlineWidth<br>这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    borderBottomColor: <span class=\"string\">'#bbb'</span>,</span><br><span class=\"line\">    borderBottomWidth: StyleSheet.hairlineWidth</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。<br>Android内建的字体有:</p>\n<ul>\n<li>normal</li>\n<li>serif</li>\n<li>monospace <br></li>\n</ul>\n<p>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>你必须把你的文本节点放在\\<text>组件内。你不能直接在\\<view>下放置一段文本。</view></text></text></text></text></text></p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><h4 id=\"宽、高尺寸设置\"><a href=\"#宽、高尺寸设置\" class=\"headerlink\" title=\"宽、高尺寸设置\"></a>宽、高尺寸设置</h4><ul>\n<li>Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。</li>\n<li>有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preciseImageStyle: &#123;</span><br><span class=\"line\">  width: actrualWidth / PixelRatio.get(),</span><br><span class=\"line\">  height: actrualHeight / PixelRatio.get(),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Image组件的常见属性\"><a href=\"#Image组件的常见属性\" class=\"headerlink\" title=\"Image组件的常见属性\"></a>Image组件的常见属性</h4><ul>\n<li><p>onLayout(function) <br><br>当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.</p>\n</li>\n<li><p>onLoad (function)  <br><br>当图片加载成功之后，回调该方法</p>\n</li>\n<li><p>onLoadEnd (function)  <br><br>当图片加载失败回调该方法，该不会管图片加载成功还是失败</p>\n</li>\n<li>onLoadStart (fcuntion)  <br><br>当图片开始加载的时候调用该方法</li>\n<li>resizeMode  <br><br>缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片</li>\n<li>source{uri:string}  <br><br>进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径<br>它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Image</span><br><span class=\"line\">               style=&#123;&#123;flex: 1&#125;&#125;</span><br><span class=\"line\">               <span class=\"built_in\">source</span>=&#123;[</span><br><span class=\"line\">                  &#123;uri:<span class=\"string\">'https://facebook.github.io/react/img/logo_small.png'</span>, width: 38, height: 38&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_small_2x.png'</span>, width: 76, height: 76&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_og.png'</span>, width: 400, height: 400&#125;</span><br><span class=\"line\">                       ]&#125;</span><br><span class=\"line\">                   /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3><p>作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。<br>View的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。</div></p>\n<h4 id=\"accessible-bool\"><a href=\"#accessible-bool\" class=\"headerlink\" title=\"accessible bool\"></a>accessible bool</h4><p>当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。</p>\n<p>如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。</p>\n<h4 id=\"onResponderMove-function\"><a href=\"#onResponderMove-function\" class=\"headerlink\" title=\"onResponderMove function\"></a>onResponderMove function</h4><p>当用户正在屏幕上移动手指时调用这个函数</p>\n<h3 id=\"Button\"><a href=\"#Button\" class=\"headerlink\" title=\"Button\"></a>Button</h3><p>一个简单的跨平台的按钮组件。可以进行一些简单的定制。<br>disabled bool<br>设置为true时此按钮将不可点击</p>\n<p> title: PropTypes.string.isRequired,<br>Platform.OS === ‘android’ ? title.toUpperCase() : title;</p>\n<h3 id=\"FlatList\"><a href=\"#FlatList\" class=\"headerlink\" title=\"FlatList\"></a>FlatList</h3><p>FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。<br>FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。<br>FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p>\n<h3 id=\"SectionList\"><a href=\"#SectionList\" class=\"headerlink\" title=\"SectionList\"></a>SectionList</h3><p>如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。</p>\n<h3 id=\"TouchableOpacity\"><a href=\"#TouchableOpacity\" class=\"headerlink\" title=\"TouchableOpacity\"></a>TouchableOpacity</h3><p>本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。<br>此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景</p>\n<h3 id=\"TouchableHighlight\"><a href=\"#TouchableHighlight\" class=\"headerlink\" title=\"TouchableHighlight\"></a>TouchableHighlight</h3><p><em>注意：TouchableHighlight只支持一个子节点<br>如果你希望包含多个子组件，用一个View来包装它们。</em></p>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。<br>ScrollView和ListView/FlatList应该如何选择？<br>ScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。</p>\n<h4 id=\"horizontal-bool\"><a href=\"#horizontal-bool\" class=\"headerlink\" title=\"horizontal bool\"></a>horizontal bool</h4><p>当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</p>\n<h4 id=\"pagingEnabled-bool\"><a href=\"#pagingEnabled-bool\" class=\"headerlink\" title=\"pagingEnabled bool\"></a>pagingEnabled bool</h4><p>当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</p>\n<h4 id=\"showsHorizontalScrollIndicator-bool\"><a href=\"#showsHorizontalScrollIndicator-bool\" class=\"headerlink\" title=\"showsHorizontalScrollIndicator bool\"></a>showsHorizontalScrollIndicator bool</h4><p>当此属性为true的时候，显示一个水平方向的滚动条。</p>\n<h3 id=\"Dimensions\"><a href=\"#Dimensions\" class=\"headerlink\" title=\"Dimensions\"></a>Dimensions</h3><p>本模块用于获取设备屏幕的宽高<br>例子：var {height, width} = Dimensions.get(‘window’);</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。<br>初学了一些东西，做个总结。<br>","more":"</p>\n</blockquote>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>AppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。<br>要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。<br>AppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。</p>\n<h3 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h3><p>StyleSheet提供了一种类似CSS样式表的抽象。<br>创建一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    borderRadius: 4,</span><br><span class=\"line\">    borderWidth: 0.5,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#d6d7da'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: 19,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  activeTitle: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>使用一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">  &lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p>\n<p>从代码质量角度：<br>从render函数中移除具体的样式内容，可以使代码更清晰易懂。<br>给样式命名也是对render函数中的原始组件的作用的一种标记。<br>从性能角度：<br>创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。<br>它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。<br>注意：create() 和 hairlineWidth<br>这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    borderBottomColor: <span class=\"string\">'#bbb'</span>,</span><br><span class=\"line\">    borderBottomWidth: StyleSheet.hairlineWidth</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。<br>Android内建的字体有:</p>\n<ul>\n<li>normal</li>\n<li>serif</li>\n<li>monospace <br></li>\n</ul>\n<p>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>你必须把你的文本节点放在\\<text>组件内。你不能直接在\\<view>下放置一段文本。</view></text></text></text></text></text></p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><h4 id=\"宽、高尺寸设置\"><a href=\"#宽、高尺寸设置\" class=\"headerlink\" title=\"宽、高尺寸设置\"></a>宽、高尺寸设置</h4><ul>\n<li>Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。</li>\n<li>有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preciseImageStyle: &#123;</span><br><span class=\"line\">  width: actrualWidth / PixelRatio.get(),</span><br><span class=\"line\">  height: actrualHeight / PixelRatio.get(),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Image组件的常见属性\"><a href=\"#Image组件的常见属性\" class=\"headerlink\" title=\"Image组件的常见属性\"></a>Image组件的常见属性</h4><ul>\n<li><p>onLayout(function) <br><br>当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.</p>\n</li>\n<li><p>onLoad (function)  <br><br>当图片加载成功之后，回调该方法</p>\n</li>\n<li><p>onLoadEnd (function)  <br><br>当图片加载失败回调该方法，该不会管图片加载成功还是失败</p>\n</li>\n<li>onLoadStart (fcuntion)  <br><br>当图片开始加载的时候调用该方法</li>\n<li>resizeMode  <br><br>缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片</li>\n<li>source{uri:string}  <br><br>进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径<br>它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Image</span><br><span class=\"line\">               style=&#123;&#123;flex: 1&#125;&#125;</span><br><span class=\"line\">               <span class=\"built_in\">source</span>=&#123;[</span><br><span class=\"line\">                  &#123;uri:<span class=\"string\">'https://facebook.github.io/react/img/logo_small.png'</span>, width: 38, height: 38&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_small_2x.png'</span>, width: 76, height: 76&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_og.png'</span>, width: 400, height: 400&#125;</span><br><span class=\"line\">                       ]&#125;</span><br><span class=\"line\">                   /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3><p>作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。<br>View的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。</div></p>\n<h4 id=\"accessible-bool\"><a href=\"#accessible-bool\" class=\"headerlink\" title=\"accessible bool\"></a>accessible bool</h4><p>当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。</p>\n<p>如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。</p>\n<h4 id=\"onResponderMove-function\"><a href=\"#onResponderMove-function\" class=\"headerlink\" title=\"onResponderMove function\"></a>onResponderMove function</h4><p>当用户正在屏幕上移动手指时调用这个函数</p>\n<h3 id=\"Button\"><a href=\"#Button\" class=\"headerlink\" title=\"Button\"></a>Button</h3><p>一个简单的跨平台的按钮组件。可以进行一些简单的定制。<br>disabled bool<br>设置为true时此按钮将不可点击</p>\n<p> title: PropTypes.string.isRequired,<br>Platform.OS === ‘android’ ? title.toUpperCase() : title;</p>\n<h3 id=\"FlatList\"><a href=\"#FlatList\" class=\"headerlink\" title=\"FlatList\"></a>FlatList</h3><p>FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。<br>FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。<br>FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p>\n<h3 id=\"SectionList\"><a href=\"#SectionList\" class=\"headerlink\" title=\"SectionList\"></a>SectionList</h3><p>如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。</p>\n<h3 id=\"TouchableOpacity\"><a href=\"#TouchableOpacity\" class=\"headerlink\" title=\"TouchableOpacity\"></a>TouchableOpacity</h3><p>本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。<br>此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景</p>\n<h3 id=\"TouchableHighlight\"><a href=\"#TouchableHighlight\" class=\"headerlink\" title=\"TouchableHighlight\"></a>TouchableHighlight</h3><p><em>注意：TouchableHighlight只支持一个子节点<br>如果你希望包含多个子组件，用一个View来包装它们。</em></p>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。<br>ScrollView和ListView/FlatList应该如何选择？<br>ScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。</p>\n<h4 id=\"horizontal-bool\"><a href=\"#horizontal-bool\" class=\"headerlink\" title=\"horizontal bool\"></a>horizontal bool</h4><p>当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</p>\n<h4 id=\"pagingEnabled-bool\"><a href=\"#pagingEnabled-bool\" class=\"headerlink\" title=\"pagingEnabled bool\"></a>pagingEnabled bool</h4><p>当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</p>\n<h4 id=\"showsHorizontalScrollIndicator-bool\"><a href=\"#showsHorizontalScrollIndicator-bool\" class=\"headerlink\" title=\"showsHorizontalScrollIndicator bool\"></a>showsHorizontalScrollIndicator bool</h4><p>当此属性为true的时候，显示一个水平方向的滚动条。</p>\n<h3 id=\"Dimensions\"><a href=\"#Dimensions\" class=\"headerlink\" title=\"Dimensions\"></a>Dimensions</h3><p>本模块用于获取设备屏幕的宽高<br>例子：var {height, width} = Dimensions.get(‘window’);</p>"},{"title":"从源码看vue的lifecycle","date":"2018-04-29T05:47:53.000Z","_content":"\n\n>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。\n\n<!--more-->\n\n话不多说，先来张图。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png)\n熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。\n知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。\n\n### 阅读技巧\n\n这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始\n```bash\n(function(window, undefined) {\n    var  jQuery = function(selector, context) {\n\n        return new jQuery.fn.init(selector, context, rootjQuery);\n    }\n\n\n    jQuery.fn = jQuery.prototype = {\n\n        init: function(selector, context, rootjQuery) {\n            // ...\n        }\n    }\n\n    jQuery.fn.init.prototype = jQuery.fn;\n\n})(window);\n\n```\n\n然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。\n\n而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png)\n而入口文件是 core/index.js\n\n### 正文开始\n\ncore/index.js源码如下\n\n```bash\n//Vue的核心方法\nimport Vue from './instance/index'\n//初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n//获取布尔值变量判断是不是SSR\nimport { isServerRendering } from 'core/util/env'\n// 初始化全局变量\ninitGlobalAPI(Vue)\n// 为Vue原型定义属性$isServer\nObject.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n})\n// 为Vue原型定义属性$ssrContext\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n    get () {\n        /* istanbul ignore next */\n        return this.$vnode && this.$vnode.ssrContext\n    }\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n\n```\n\nemmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  './instance/index',(凭直觉，这里应该有东西)\n<br>\n./instance/index\n```bash\n\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\n//为Vue的原型扩展_init方法\ninitMixin(Vue)\n\n//初始化$data $props $set $delete等\nstateMixin(Vue)\n\n//初始化$on $once $off $emit等函数\neventsMixin(Vue)\n\n//初始化_update $forceUpdate $destroy函数\nlifecycleMixin(Vue)\n\n//初始化 $nextTick _render函数\nrenderMixin(Vue)\n\nexport default Vue\n\n```\n当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看\n\n点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里\n\n```bash\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n```\n\ninitMixin就是再前文提到的./instance/index里被调用的。\n其实接下来才开始和那张图有关系。\n\n```bash\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n        // 如果是Vue的实例，则不需要被observe\n    vm._isVue = true\n        // 第一步： options参数的处理\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n        // 第二步： renderProxy\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n        // 第三步： vm的生命周期相关变量初始化\n    initLifecycle(vm)\n        // 第四步： vm的事件监听（v-on）初始化\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n        // 第六步：render & mount\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n```\n\n代码中做了注释，\n+ 第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。\n+ 第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。\n+ 第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。\n+ 第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数\n+ 第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。\n\n因此，至少在created时才能拿到data等里面的值。<br>\n\n当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。\n\n编译方式有两种：\n+ 编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。\n\n然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。\n+ 运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。\n（打把王者，回头再写，有点头疼）\nloading......................................................................................\n王者打完了，接着写\n\n## beforeMount\n解释一下图中在created和beforeMount之间的部分。\n第一个分支：\n如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。\n<br>\n\n第二个分支：\n1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数\n2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高\n3.如果1,2条件都不具备，则报错\n\n接着就调用beforeMount生命周期钩子\n<br>\ncore/instance/lifecycle.js\n```bash\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n\n```\n","source":"_posts/vue-lifecycle.md","raw":"---\ntitle: 从源码看vue的lifecycle\ndate: 2018-04-29 13:47:53\ntags: vue\ncategories: 学习\n---\n\n\n>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。\n\n<!--more-->\n\n话不多说，先来张图。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png)\n熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。\n知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。\n\n### 阅读技巧\n\n这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始\n```bash\n(function(window, undefined) {\n    var  jQuery = function(selector, context) {\n\n        return new jQuery.fn.init(selector, context, rootjQuery);\n    }\n\n\n    jQuery.fn = jQuery.prototype = {\n\n        init: function(selector, context, rootjQuery) {\n            // ...\n        }\n    }\n\n    jQuery.fn.init.prototype = jQuery.fn;\n\n})(window);\n\n```\n\n然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。\n\n而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png)\n而入口文件是 core/index.js\n\n### 正文开始\n\ncore/index.js源码如下\n\n```bash\n//Vue的核心方法\nimport Vue from './instance/index'\n//初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n//获取布尔值变量判断是不是SSR\nimport { isServerRendering } from 'core/util/env'\n// 初始化全局变量\ninitGlobalAPI(Vue)\n// 为Vue原型定义属性$isServer\nObject.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n})\n// 为Vue原型定义属性$ssrContext\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n    get () {\n        /* istanbul ignore next */\n        return this.$vnode && this.$vnode.ssrContext\n    }\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n\n```\n\nemmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  './instance/index',(凭直觉，这里应该有东西)\n<br>\n./instance/index\n```bash\n\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\n//为Vue的原型扩展_init方法\ninitMixin(Vue)\n\n//初始化$data $props $set $delete等\nstateMixin(Vue)\n\n//初始化$on $once $off $emit等函数\neventsMixin(Vue)\n\n//初始化_update $forceUpdate $destroy函数\nlifecycleMixin(Vue)\n\n//初始化 $nextTick _render函数\nrenderMixin(Vue)\n\nexport default Vue\n\n```\n当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看\n\n点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里\n\n```bash\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n```\n\ninitMixin就是再前文提到的./instance/index里被调用的。\n其实接下来才开始和那张图有关系。\n\n```bash\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n        // 如果是Vue的实例，则不需要被observe\n    vm._isVue = true\n        // 第一步： options参数的处理\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n        // 第二步： renderProxy\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n        // 第三步： vm的生命周期相关变量初始化\n    initLifecycle(vm)\n        // 第四步： vm的事件监听（v-on）初始化\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n        // 第六步：render & mount\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n```\n\n代码中做了注释，\n+ 第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。\n+ 第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。\n+ 第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。\n+ 第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数\n+ 第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。\n\n因此，至少在created时才能拿到data等里面的值。<br>\n\n当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。\n\n编译方式有两种：\n+ 编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。\n\n然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。\n+ 运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。\n（打把王者，回头再写，有点头疼）\nloading......................................................................................\n王者打完了，接着写\n\n## beforeMount\n解释一下图中在created和beforeMount之间的部分。\n第一个分支：\n如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。\n<br>\n\n第二个分支：\n1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数\n2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高\n3.如果1,2条件都不具备，则报错\n\n接着就调用beforeMount生命周期钩子\n<br>\ncore/instance/lifecycle.js\n```bash\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n\n```\n","slug":"vue-lifecycle","published":1,"updated":"2019-09-17T02:43:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw98002mkwfy5yllydfy","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>话不多说，先来张图。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png\" alt><br>熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。<br>知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。</p>\n<h3 id=\"阅读技巧\"><a href=\"#阅读技巧\" class=\"headerlink\" title=\"阅读技巧\"></a>阅读技巧</h3><p>这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(window, undefined) &#123;</span><br><span class=\"line\">    var  jQuery = <span class=\"keyword\">function</span>(selector, context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">return</span> new jQuery.fn.init(selector, context, rootjQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        init: <span class=\"keyword\">function</span>(selector, context, rootjQuery) &#123;</span><br><span class=\"line\">            // ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(window);</span><br></pre></td></tr></table></figure></p>\n<p>然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。</p>\n<p>而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png\" alt><br>而入口文件是 core/index.js</p>\n<h3 id=\"正文开始\"><a href=\"#正文开始\" class=\"headerlink\" title=\"正文开始\"></a>正文开始</h3><p>core/index.js源码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Vue的核心方法</span><br><span class=\"line\">import Vue from <span class=\"string\">'./instance/index'</span></span><br><span class=\"line\">//初始化全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from <span class=\"string\">'./global-api/index'</span></span><br><span class=\"line\">//获取布尔值变量判断是不是SSR</span><br><span class=\"line\">import &#123; isServerRendering &#125; from <span class=\"string\">'core/util/env'</span></span><br><span class=\"line\">// 初始化全局变量</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$isServer</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$isServer'</span>, &#123;</span><br><span class=\"line\">    get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$ssrContext</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$ssrContext'</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span></span> () &#123;</span><br><span class=\"line\">        /* istanbul ignore next */</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this.<span class=\"variable\">$vnode</span> &amp;&amp; this.<span class=\"variable\">$vnode</span>.ssrContext</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = <span class=\"string\">'__VERSION__'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure>\n<p>emmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  ‘./instance/index’,(凭直觉，这里应该有东西)<br><br><br>./instance/index<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import &#123; initMixin &#125; from <span class=\"string\">'./init'</span></span><br><span class=\"line\">import &#123; stateMixin &#125; from <span class=\"string\">'./state'</span></span><br><span class=\"line\">import &#123; renderMixin &#125; from <span class=\"string\">'./render'</span></span><br><span class=\"line\">import &#123; eventsMixin &#125; from <span class=\"string\">'./events'</span></span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from <span class=\"string\">'./lifecycle'</span></span><br><span class=\"line\">import &#123; warn &#125; from <span class=\"string\">'../util/index'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> Vue (options) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//为Vue的原型扩展_init方法</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$data</span> <span class=\"variable\">$props</span> <span class=\"variable\">$set</span> <span class=\"variable\">$delete</span>等</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$on</span> <span class=\"variable\">$once</span> <span class=\"variable\">$off</span> <span class=\"variable\">$emit</span>等函数</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化_update <span class=\"variable\">$forceUpdate</span> <span class=\"variable\">$destroy</span>函数</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化 <span class=\"variable\">$nextTick</span> _render函数</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure></p>\n<p>当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看</p>\n<p>点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br></pre></td></tr></table></figure>\n<p>initMixin就是再前文提到的./instance/index里被调用的。<br>其实接下来才开始和那张图有关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // a uid</span><br><span class=\"line\">    vm._uid = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">let</span> startTag, endTag</span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = `vue-perf-start:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      endTag = `vue-perf-end:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果是Vue的实例，则不需要被observe</span><br><span class=\"line\">    vm._isVue = <span class=\"literal\">true</span></span><br><span class=\"line\">        // 第一步： options参数的处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class=\"line\">      // optimize internal component instantiation</span><br><span class=\"line\">      // since dynamic options merging is pretty slow, and none of the</span><br><span class=\"line\">      // internal component options needs special treatment.</span><br><span class=\"line\">      initInternalComponent(vm, options)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$options</span> = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第二步： renderProxy</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">        // 第三步： vm的生命周期相关变量初始化</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">        // 第四步： vm的事件监听（v-on）初始化</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm._name = formatComponentName(vm, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;vm._name&#125;</span> init`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第六步：render &amp; mount</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"variable\">$options</span>.el) &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$mount</span>(vm.<span class=\"variable\">$options</span>.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>代码中做了注释，</p>\n<ul>\n<li>第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。</li>\n<li>第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。</li>\n<li>第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。</li>\n<li>第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数</li>\n<li>第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。</li>\n</ul>\n<p>因此，至少在created时才能拿到data等里面的值。<br></p>\n<p>当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。</p>\n<p>编译方式有两种：</p>\n<ul>\n<li>编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。</li>\n</ul>\n<p>然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。</p>\n<ul>\n<li>运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。<br>（打把王者，回头再写，有点头疼）<br>loading…………………………………………………………………………..<br>王者打完了，接着写</li>\n</ul>\n<h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><p>解释一下图中在created和beforeMount之间的部分。<br>第一个分支：<br>如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。<br><br></p>\n<p>第二个分支：<br>1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数<br>2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高<br>3.如果1,2条件都不具备，则报错</p>\n<p>接着就调用beforeMount生命周期钩子<br><br><br>core/instance/lifecycle.js<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> mountComponent (</span><br><span class=\"line\">  vm: Component,</span><br><span class=\"line\">  el: ?Element,</span><br><span class=\"line\">  hydrating?: boolean</span><br><span class=\"line\">): Component &#123;</span><br><span class=\"line\">  vm.<span class=\"variable\">$el</span> = el</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!vm.<span class=\"variable\">$options</span>.render) &#123;</span><br><span class=\"line\">    vm.<span class=\"variable\">$options</span>.render = createEmptyVNode</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((vm.<span class=\"variable\">$options</span>.template &amp;&amp; vm.<span class=\"variable\">$options</span>.template.charAt(0) !== <span class=\"string\">'#'</span>) ||</span><br><span class=\"line\">        vm.<span class=\"variable\">$options</span>.el || el) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class=\"line\">          <span class=\"string\">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class=\"line\">          <span class=\"string\">'render functions, or use the compiler-included build.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callHook(vm, <span class=\"string\">'beforeMount'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">let</span> updateComponent</span><br><span class=\"line\">  /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      const name = vm._name</span><br><span class=\"line\">      const id = vm._uid</span><br><span class=\"line\">      const startTag = `vue-perf-start:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\">      const endTag = `vue-perf-end:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      const vnode = vm._render()</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> render`, startTag, endTag)</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      vm._update(vnode, hydrating)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> patch`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      vm._update(vm._render(), hydrating)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // we <span class=\"built_in\">set</span> this to vm._watcher inside the watcher<span class=\"string\">'s constructor</span></span><br><span class=\"line\"><span class=\"string\">  // since the watcher'</span>s initial patch may call <span class=\"variable\">$forceUpdate</span> (e.g. inside child</span><br><span class=\"line\">  // component<span class=\"string\">'s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class=\"line\"><span class=\"string\">  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span></span><br><span class=\"line\"><span class=\"string\">  hydrating = false</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // manually mounted instance, call mounted on self</span></span><br><span class=\"line\"><span class=\"string\">  // mounted is called for render-created child components in its inserted hook</span></span><br><span class=\"line\"><span class=\"string\">  if (vm.$vnode == null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    vm._isMounted = true</span></span><br><span class=\"line\"><span class=\"string\">    callHook(vm, '</span>mounted<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  return vm</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。</p>\n</blockquote>","more":"<p>话不多说，先来张图。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png\" alt><br>熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。<br>知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。</p>\n<h3 id=\"阅读技巧\"><a href=\"#阅读技巧\" class=\"headerlink\" title=\"阅读技巧\"></a>阅读技巧</h3><p>这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(window, undefined) &#123;</span><br><span class=\"line\">    var  jQuery = <span class=\"keyword\">function</span>(selector, context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">return</span> new jQuery.fn.init(selector, context, rootjQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        init: <span class=\"keyword\">function</span>(selector, context, rootjQuery) &#123;</span><br><span class=\"line\">            // ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(window);</span><br></pre></td></tr></table></figure></p>\n<p>然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。</p>\n<p>而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png\" alt><br>而入口文件是 core/index.js</p>\n<h3 id=\"正文开始\"><a href=\"#正文开始\" class=\"headerlink\" title=\"正文开始\"></a>正文开始</h3><p>core/index.js源码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Vue的核心方法</span><br><span class=\"line\">import Vue from <span class=\"string\">'./instance/index'</span></span><br><span class=\"line\">//初始化全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from <span class=\"string\">'./global-api/index'</span></span><br><span class=\"line\">//获取布尔值变量判断是不是SSR</span><br><span class=\"line\">import &#123; isServerRendering &#125; from <span class=\"string\">'core/util/env'</span></span><br><span class=\"line\">// 初始化全局变量</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$isServer</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$isServer'</span>, &#123;</span><br><span class=\"line\">    get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$ssrContext</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$ssrContext'</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span></span> () &#123;</span><br><span class=\"line\">        /* istanbul ignore next */</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this.<span class=\"variable\">$vnode</span> &amp;&amp; this.<span class=\"variable\">$vnode</span>.ssrContext</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = <span class=\"string\">'__VERSION__'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure>\n<p>emmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  ‘./instance/index’,(凭直觉，这里应该有东西)<br><br><br>./instance/index<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import &#123; initMixin &#125; from <span class=\"string\">'./init'</span></span><br><span class=\"line\">import &#123; stateMixin &#125; from <span class=\"string\">'./state'</span></span><br><span class=\"line\">import &#123; renderMixin &#125; from <span class=\"string\">'./render'</span></span><br><span class=\"line\">import &#123; eventsMixin &#125; from <span class=\"string\">'./events'</span></span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from <span class=\"string\">'./lifecycle'</span></span><br><span class=\"line\">import &#123; warn &#125; from <span class=\"string\">'../util/index'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> Vue (options) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//为Vue的原型扩展_init方法</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$data</span> <span class=\"variable\">$props</span> <span class=\"variable\">$set</span> <span class=\"variable\">$delete</span>等</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$on</span> <span class=\"variable\">$once</span> <span class=\"variable\">$off</span> <span class=\"variable\">$emit</span>等函数</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化_update <span class=\"variable\">$forceUpdate</span> <span class=\"variable\">$destroy</span>函数</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化 <span class=\"variable\">$nextTick</span> _render函数</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure></p>\n<p>当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看</p>\n<p>点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br></pre></td></tr></table></figure>\n<p>initMixin就是再前文提到的./instance/index里被调用的。<br>其实接下来才开始和那张图有关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // a uid</span><br><span class=\"line\">    vm._uid = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">let</span> startTag, endTag</span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = `vue-perf-start:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      endTag = `vue-perf-end:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果是Vue的实例，则不需要被observe</span><br><span class=\"line\">    vm._isVue = <span class=\"literal\">true</span></span><br><span class=\"line\">        // 第一步： options参数的处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class=\"line\">      // optimize internal component instantiation</span><br><span class=\"line\">      // since dynamic options merging is pretty slow, and none of the</span><br><span class=\"line\">      // internal component options needs special treatment.</span><br><span class=\"line\">      initInternalComponent(vm, options)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$options</span> = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第二步： renderProxy</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">        // 第三步： vm的生命周期相关变量初始化</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">        // 第四步： vm的事件监听（v-on）初始化</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm._name = formatComponentName(vm, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;vm._name&#125;</span> init`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第六步：render &amp; mount</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"variable\">$options</span>.el) &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$mount</span>(vm.<span class=\"variable\">$options</span>.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>代码中做了注释，</p>\n<ul>\n<li>第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。</li>\n<li>第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。</li>\n<li>第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。</li>\n<li>第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数</li>\n<li>第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。</li>\n</ul>\n<p>因此，至少在created时才能拿到data等里面的值。<br></p>\n<p>当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。</p>\n<p>编译方式有两种：</p>\n<ul>\n<li>编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。</li>\n</ul>\n<p>然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。</p>\n<ul>\n<li>运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。<br>（打把王者，回头再写，有点头疼）<br>loading…………………………………………………………………………..<br>王者打完了，接着写</li>\n</ul>\n<h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><p>解释一下图中在created和beforeMount之间的部分。<br>第一个分支：<br>如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。<br><br></p>\n<p>第二个分支：<br>1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数<br>2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高<br>3.如果1,2条件都不具备，则报错</p>\n<p>接着就调用beforeMount生命周期钩子<br><br><br>core/instance/lifecycle.js<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> mountComponent (</span><br><span class=\"line\">  vm: Component,</span><br><span class=\"line\">  el: ?Element,</span><br><span class=\"line\">  hydrating?: boolean</span><br><span class=\"line\">): Component &#123;</span><br><span class=\"line\">  vm.<span class=\"variable\">$el</span> = el</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!vm.<span class=\"variable\">$options</span>.render) &#123;</span><br><span class=\"line\">    vm.<span class=\"variable\">$options</span>.render = createEmptyVNode</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((vm.<span class=\"variable\">$options</span>.template &amp;&amp; vm.<span class=\"variable\">$options</span>.template.charAt(0) !== <span class=\"string\">'#'</span>) ||</span><br><span class=\"line\">        vm.<span class=\"variable\">$options</span>.el || el) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class=\"line\">          <span class=\"string\">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class=\"line\">          <span class=\"string\">'render functions, or use the compiler-included build.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callHook(vm, <span class=\"string\">'beforeMount'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">let</span> updateComponent</span><br><span class=\"line\">  /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      const name = vm._name</span><br><span class=\"line\">      const id = vm._uid</span><br><span class=\"line\">      const startTag = `vue-perf-start:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\">      const endTag = `vue-perf-end:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      const vnode = vm._render()</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> render`, startTag, endTag)</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      vm._update(vnode, hydrating)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> patch`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      vm._update(vm._render(), hydrating)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // we <span class=\"built_in\">set</span> this to vm._watcher inside the watcher<span class=\"string\">'s constructor</span></span><br><span class=\"line\"><span class=\"string\">  // since the watcher'</span>s initial patch may call <span class=\"variable\">$forceUpdate</span> (e.g. inside child</span><br><span class=\"line\">  // component<span class=\"string\">'s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class=\"line\"><span class=\"string\">  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span></span><br><span class=\"line\"><span class=\"string\">  hydrating = false</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // manually mounted instance, call mounted on self</span></span><br><span class=\"line\"><span class=\"string\">  // mounted is called for render-created child components in its inserted hook</span></span><br><span class=\"line\"><span class=\"string\">  if (vm.$vnode == null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    vm._isMounted = true</span></span><br><span class=\"line\"><span class=\"string\">    callHook(vm, '</span>mounted<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  return vm</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>"},{"title":"vue的diff","date":"2019-01-17T09:41:09.000Z","_content":"\n> 昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。\n\n<!-- more -->\n## 关键源码\n\n### updateChildren\n\nvue关于diff模块源码地址：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\n\n其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。\n\n规则很简单，循环体内：\n\n+ 首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）\n+  oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。\n+  oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd--，oldEnd--，否则进入下一步。\n+  oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd--，oldStart++，否则进入下一步。\n+  oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd--，newStart++，否则进入下一步。\n\n+ 如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。\n\n```bash\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh)\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n       /*\n          生成一个key与旧VNode的key对应的哈希表，形如{oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:\n          3}，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引\n        */\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            oldCh[idxInOld] = undefined\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n\n------------\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  let i, key\n  const map = {}\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  }\n  return map\n}\n```\n\n### patchVnode\n\n代码在这：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js   第501行。\n其实这个函数就是在两个节点值得diff的情况下，去更新差异。\n规则如下：\n\n1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。\n\n2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。\n\n3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。\n\n4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。\n\n5.当新老节点都无子节点的时候，只是文本的替换。\n\n### sameVnode\n\n代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。\n\n```bash\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n```\n\n\n\n## 开始BB\n\n首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：\n\n+ 两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。\n\n+ 一个map，是一个用来建立oldVnode的key和索引的映射关系，形如\n\n``` bash\n{\n    oldKey0: 0,\n    oldKey1: 1,\n    oldKey2: 2,\n    oldKey3: 3,\n}\n```\n\n### 举个🌰\n\n原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。\n\n![1](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg)\n\n#### 第1步\n\n在满足oldStart<= oldEnd && newStart <= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg)\n\n#### 第2步\n\n接着发现newB和oldB也是值得比较的就重复上述的步骤\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg)\n\n#### 第3步\n\n\nC和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg)\n\n#### 第4步\n\n这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg)\n\n#### 第5步\n\n这个时候oldEnd>oldStart不满足oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx，这个时候\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg)\n\noldStart > oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来\n\nnewStart > newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：\n\n> 1. js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。\n> 2. JS 代码调用 DOM API 必须经过 *挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎*，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。\n> 3. 若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。\n> 4. 若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，**重新计算布局**、**重新绘制图像**会引起更大的性能消耗。\n\n所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰\n\n### 再举个🌰\n\n#### 第1步\n原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。\n\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg)\n#### 第2步\n目前真实的dom和oldNodeList是一样，以后***移动节点是在真实的dom上移动的***。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，\n根据文章一开始介绍的规则，将oldStart移动到***oldEnd***所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针\n\nmove的代码如下\n\n```bash\n\ncanMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n\n\n\n```\nnodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在[这个位置](https://github.com/vuejs/vue/tree/2.6/src/platforms) 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。\n\n如图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg)\n#### 第3步\n\nok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg)\n\n#### 第4步\n\n最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg)\n\n\n### 再再举个例子\n#### 第1步\n\n原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg)\n\n#### 第2步\n\n于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后***将newStart对应的真实dom移动到oldStart的前面***，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg)\n#### 第3步\n至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，***将oldEnd对应的真实dom移动到oldStart的前面***，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg)\n\n#### 第4步\n接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。\n","source":"_posts/vue-vue的diff.md","raw":"---\ntitle: vue的diff\ndate: 2019-01-17 17:41:09\ntags: vue\n---\n\n> 昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。\n\n<!-- more -->\n## 关键源码\n\n### updateChildren\n\nvue关于diff模块源码地址：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\n\n其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。\n\n规则很简单，循环体内：\n\n+ 首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）\n+  oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。\n+  oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd--，oldEnd--，否则进入下一步。\n+  oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd--，oldStart++，否则进入下一步。\n+  oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd--，newStart++，否则进入下一步。\n\n+ 如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。\n\n```bash\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh)\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n       /*\n          生成一个key与旧VNode的key对应的哈希表，形如{oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:\n          3}，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引\n        */\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            oldCh[idxInOld] = undefined\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n\n------------\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  let i, key\n  const map = {}\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  }\n  return map\n}\n```\n\n### patchVnode\n\n代码在这：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js   第501行。\n其实这个函数就是在两个节点值得diff的情况下，去更新差异。\n规则如下：\n\n1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。\n\n2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。\n\n3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。\n\n4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。\n\n5.当新老节点都无子节点的时候，只是文本的替换。\n\n### sameVnode\n\n代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。\n\n```bash\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n```\n\n\n\n## 开始BB\n\n首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：\n\n+ 两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。\n\n+ 一个map，是一个用来建立oldVnode的key和索引的映射关系，形如\n\n``` bash\n{\n    oldKey0: 0,\n    oldKey1: 1,\n    oldKey2: 2,\n    oldKey3: 3,\n}\n```\n\n### 举个🌰\n\n原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。\n\n![1](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg)\n\n#### 第1步\n\n在满足oldStart<= oldEnd && newStart <= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg)\n\n#### 第2步\n\n接着发现newB和oldB也是值得比较的就重复上述的步骤\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg)\n\n#### 第3步\n\n\nC和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg)\n\n#### 第4步\n\n这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg)\n\n#### 第5步\n\n这个时候oldEnd>oldStart不满足oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx，这个时候\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg)\n\noldStart > oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来\n\nnewStart > newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：\n\n> 1. js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。\n> 2. JS 代码调用 DOM API 必须经过 *挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎*，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。\n> 3. 若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。\n> 4. 若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，**重新计算布局**、**重新绘制图像**会引起更大的性能消耗。\n\n所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰\n\n### 再举个🌰\n\n#### 第1步\n原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。\n\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg)\n#### 第2步\n目前真实的dom和oldNodeList是一样，以后***移动节点是在真实的dom上移动的***。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，\n根据文章一开始介绍的规则，将oldStart移动到***oldEnd***所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针\n\nmove的代码如下\n\n```bash\n\ncanMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n\n\n\n```\nnodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在[这个位置](https://github.com/vuejs/vue/tree/2.6/src/platforms) 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。\n\n如图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg)\n#### 第3步\n\nok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg)\n\n#### 第4步\n\n最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg)\n\n\n### 再再举个例子\n#### 第1步\n\n原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg)\n\n#### 第2步\n\n于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后***将newStart对应的真实dom移动到oldStart的前面***，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg)\n#### 第3步\n至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，***将oldEnd对应的真实dom移动到oldStart的前面***，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg)\n\n#### 第4步\n接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。\n","slug":"vue-vue的diff","published":1,"updated":"2019-09-17T02:43:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw9a002qkwfyym2q6k2y","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"关键源码\"><a href=\"#关键源码\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h2><h3 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren\"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p>\n<p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p>\n<p>规则很简单，循环体内：</p>\n<ul>\n<li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li>\n<li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li>\n<li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li>\n<li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li>\n<li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p>\n</li>\n<li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndIdx = oldCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartVnode = oldCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndIdx = newCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartVnode = newCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class=\"line\">    // to ensure removed elements stay <span class=\"keyword\">in</span> correct relative positions</span><br><span class=\"line\">    // during leaving transitions</span><br><span class=\"line\">    const canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      checkDuplicateKeys(newCh)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class=\"line\">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class=\"line\">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       /*</span><br><span class=\"line\">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class=\"line\">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class=\"line\">        */</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">            oldCh[idxInOld] = undefined</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // same key but different element. treat as new element</span><br><span class=\"line\">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class=\"line\">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\"><span class=\"keyword\">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> i, key</span><br><span class=\"line\">  const map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class=\"line\">    key = children[i].key</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(key)) map[key] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"patchVnode\"><a href=\"#patchVnode\" class=\"headerlink\" title=\"patchVnode\"></a>patchVnode</h3><p>代码在这：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p>\n<p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p>\n<p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p>\n<p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p>\n<p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p>\n<p>5.当新老节点都无子节点的时候，只是文本的替换。</p>\n<h3 id=\"sameVnode\"><a href=\"#sameVnode\" class=\"headerlink\" title=\"sameVnode\"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> sameVnode (a, b) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (</span><br><span class=\"line\">    a.key === b.key &amp;&amp; (</span><br><span class=\"line\">      (</span><br><span class=\"line\">        a.tag === b.tag &amp;&amp;</span><br><span class=\"line\">        a.isComment === b.isComment &amp;&amp;</span><br><span class=\"line\">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class=\"line\">        sameInputType(a, b)</span><br><span class=\"line\">      ) || (</span><br><span class=\"line\">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class=\"line\">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class=\"line\">        isUndef(b.asyncFactory.error)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开始BB\"><a href=\"#开始BB\" class=\"headerlink\" title=\"开始BB\"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p>\n<ul>\n<li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p>\n</li>\n<li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    oldKey0: 0,</span><br><span class=\"line\">    oldKey1: 1,</span><br><span class=\"line\">    oldKey2: 2,</span><br><span class=\"line\">    oldKey3: 3,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"举个🌰\"><a href=\"#举个🌰\" class=\"headerlink\" title=\"举个🌰\"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg\" alt=\"1\"></p>\n<h4 id=\"第1步\"><a href=\"#第1步\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h4 id=\"第2步\"><a href=\"#第2步\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg\" alt=\"2\"></p>\n<h4 id=\"第3步\"><a href=\"#第3步\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg\" alt=\"2\"></p>\n<h4 id=\"第4步\"><a href=\"#第4步\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg\" alt=\"2\"></p>\n<h4 id=\"第5步\"><a href=\"#第5步\" class=\"headerlink\" title=\"第5步\"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg\" alt></p>\n<p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p>\n<p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p>\n<blockquote>\n<ol>\n<li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li>\n<li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li>\n<li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li>\n<li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li>\n</ol>\n</blockquote>\n<p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p>\n<h3 id=\"再举个🌰\"><a href=\"#再举个🌰\" class=\"headerlink\" title=\"再举个🌰\"></a>再举个🌰</h3><h4 id=\"第1步-1\"><a href=\"#第1步-1\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg\" alt></p>\n<h4 id=\"第2步-1\"><a href=\"#第2步-1\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p>\n<p>move的代码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure>\n<p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href=\"https://github.com/vuejs/vue/tree/2.6/src/platforms\" target=\"_blank\" rel=\"noopener\">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p>\n<p>如图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg\" alt></p>\n<h4 id=\"第3步-1\"><a href=\"#第3步-1\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg\" alt></p>\n<h4 id=\"第4步-1\"><a href=\"#第4步-1\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg\" alt></p>\n<h3 id=\"再再举个例子\"><a href=\"#再再举个例子\" class=\"headerlink\" title=\"再再举个例子\"></a>再再举个例子</h3><h4 id=\"第1步-2\"><a href=\"#第1步-2\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg\" alt></p>\n<h4 id=\"第2步-2\"><a href=\"#第2步-2\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg\" alt></p>\n<h4 id=\"第3步-2\"><a href=\"#第3步-2\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg\" alt></p>\n<h4 id=\"第4步-2\"><a href=\"#第4步-2\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p>\n</blockquote>","more":"<h2 id=\"关键源码\"><a href=\"#关键源码\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h2><h3 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren\"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p>\n<p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p>\n<p>规则很简单，循环体内：</p>\n<ul>\n<li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li>\n<li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li>\n<li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li>\n<li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li>\n<li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p>\n</li>\n<li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndIdx = oldCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartVnode = oldCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndIdx = newCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartVnode = newCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class=\"line\">    // to ensure removed elements stay <span class=\"keyword\">in</span> correct relative positions</span><br><span class=\"line\">    // during leaving transitions</span><br><span class=\"line\">    const canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      checkDuplicateKeys(newCh)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class=\"line\">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class=\"line\">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       /*</span><br><span class=\"line\">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class=\"line\">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class=\"line\">        */</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">            oldCh[idxInOld] = undefined</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // same key but different element. treat as new element</span><br><span class=\"line\">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class=\"line\">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\"><span class=\"keyword\">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> i, key</span><br><span class=\"line\">  const map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class=\"line\">    key = children[i].key</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(key)) map[key] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"patchVnode\"><a href=\"#patchVnode\" class=\"headerlink\" title=\"patchVnode\"></a>patchVnode</h3><p>代码在这：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p>\n<p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p>\n<p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p>\n<p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p>\n<p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p>\n<p>5.当新老节点都无子节点的时候，只是文本的替换。</p>\n<h3 id=\"sameVnode\"><a href=\"#sameVnode\" class=\"headerlink\" title=\"sameVnode\"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> sameVnode (a, b) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (</span><br><span class=\"line\">    a.key === b.key &amp;&amp; (</span><br><span class=\"line\">      (</span><br><span class=\"line\">        a.tag === b.tag &amp;&amp;</span><br><span class=\"line\">        a.isComment === b.isComment &amp;&amp;</span><br><span class=\"line\">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class=\"line\">        sameInputType(a, b)</span><br><span class=\"line\">      ) || (</span><br><span class=\"line\">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class=\"line\">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class=\"line\">        isUndef(b.asyncFactory.error)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开始BB\"><a href=\"#开始BB\" class=\"headerlink\" title=\"开始BB\"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p>\n<ul>\n<li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p>\n</li>\n<li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    oldKey0: 0,</span><br><span class=\"line\">    oldKey1: 1,</span><br><span class=\"line\">    oldKey2: 2,</span><br><span class=\"line\">    oldKey3: 3,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"举个🌰\"><a href=\"#举个🌰\" class=\"headerlink\" title=\"举个🌰\"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg\" alt=\"1\"></p>\n<h4 id=\"第1步\"><a href=\"#第1步\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h4 id=\"第2步\"><a href=\"#第2步\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg\" alt=\"2\"></p>\n<h4 id=\"第3步\"><a href=\"#第3步\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg\" alt=\"2\"></p>\n<h4 id=\"第4步\"><a href=\"#第4步\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg\" alt=\"2\"></p>\n<h4 id=\"第5步\"><a href=\"#第5步\" class=\"headerlink\" title=\"第5步\"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg\" alt></p>\n<p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p>\n<p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p>\n<blockquote>\n<ol>\n<li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li>\n<li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li>\n<li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li>\n<li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li>\n</ol>\n</blockquote>\n<p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p>\n<h3 id=\"再举个🌰\"><a href=\"#再举个🌰\" class=\"headerlink\" title=\"再举个🌰\"></a>再举个🌰</h3><h4 id=\"第1步-1\"><a href=\"#第1步-1\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg\" alt></p>\n<h4 id=\"第2步-1\"><a href=\"#第2步-1\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p>\n<p>move的代码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure>\n<p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href=\"https://github.com/vuejs/vue/tree/2.6/src/platforms\" target=\"_blank\" rel=\"noopener\">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p>\n<p>如图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg\" alt></p>\n<h4 id=\"第3步-1\"><a href=\"#第3步-1\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg\" alt></p>\n<h4 id=\"第4步-1\"><a href=\"#第4步-1\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg\" alt></p>\n<h3 id=\"再再举个例子\"><a href=\"#再再举个例子\" class=\"headerlink\" title=\"再再举个例子\"></a>再再举个例子</h3><h4 id=\"第1步-2\"><a href=\"#第1步-2\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg\" alt></p>\n<h4 id=\"第2步-2\"><a href=\"#第2步-2\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg\" alt></p>\n<h4 id=\"第3步-2\"><a href=\"#第3步-2\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg\" alt></p>\n<h4 id=\"第4步-2\"><a href=\"#第4步-2\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>"},{"title":"Ngnix","date":"2018-07-19T04:25:14.000Z","_content":"### Nginx是啥\nNginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。\n<!--more-->\n### Nginx可以干什么\n网站资源服务器，反向代理负载均衡。\n\n### 正向代理\n在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！\n\n上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。\n\n### 反向代理\n多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！\n\n### 负载均衡\n首先明确两个概念：\n\n+ 负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。\n+ 均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。\n故将服务器接收到的请求按照规则分发的过程，称为负载均衡。\n#### HTTP重定向实现\b\n当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br>\n\n在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br>\n\n调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br>\n\n+ 随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。\n\n+ 轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。\n\n由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br>\n\n##### 优缺点分析\n\n采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br>\n\n在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br>\n\n由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br>\n\n若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br>\n\n#### DNS负载均衡\nDNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。\n\n##### 具体做法\n首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。\n\n当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。\n\n##### 调度策略\n\n一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。\n\n##### 优缺点分析\n\nDNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。\n此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。\n<br>\n但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。\n<br>\nDNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。\n<br>\n此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。\n<br>\n动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。\n<br>\n#### 反向代理负载均衡\n反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。\n<br>\n之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。\n<br>\n我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。\n<br>\n##### 优点\n\n+ 隐藏后端服务器。\n+ 与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。\n故障转移\n+ 与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。\n合理分配任务\n+ HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。\n##### 缺点\n\n+ 调度者压力过大\n+ 由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。\n制约扩展\n+ 当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。\n","source":"_posts/杂记-Ngnix.md","raw":"---\ntitle: Ngnix\ndate: 2018-07-19 12:25:14\ntags: 学习\ncategories: 学习\n---\n### Nginx是啥\nNginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。\n<!--more-->\n### Nginx可以干什么\n网站资源服务器，反向代理负载均衡。\n\n### 正向代理\n在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！\n\n上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。\n\n### 反向代理\n多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！\n\n### 负载均衡\n首先明确两个概念：\n\n+ 负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。\n+ 均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。\n故将服务器接收到的请求按照规则分发的过程，称为负载均衡。\n#### HTTP重定向实现\b\n当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br>\n\n在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br>\n\n调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br>\n\n+ 随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。\n\n+ 轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。\n\n由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br>\n\n##### 优缺点分析\n\n采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br>\n\n在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br>\n\n由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br>\n\n若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br>\n\n#### DNS负载均衡\nDNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。\n\n##### 具体做法\n首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。\n\n当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。\n\n##### 调度策略\n\n一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。\n\n##### 优缺点分析\n\nDNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。\n此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。\n<br>\n但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。\n<br>\nDNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。\n<br>\n此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。\n<br>\n动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。\n<br>\n#### 反向代理负载均衡\n反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。\n<br>\n之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。\n<br>\n我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。\n<br>\n##### 优点\n\n+ 隐藏后端服务器。\n+ 与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。\n故障转移\n+ 与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。\n合理分配任务\n+ HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。\n##### 缺点\n\n+ 调度者压力过大\n+ 由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。\n制约扩展\n+ 当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。\n","slug":"杂记-Ngnix","published":1,"updated":"2019-09-17T02:41:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rw9b002tkwfyfer5t7ec","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"Nginx是啥\"><a href=\"#Nginx是啥\" class=\"headerlink\" title=\"Nginx是啥\"></a>Nginx是啥</h3><p>Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br><a id=\"more\"></a></p>\n<h3 id=\"Nginx可以干什么\"><a href=\"#Nginx可以干什么\" class=\"headerlink\" title=\"Nginx可以干什么\"></a>Nginx可以干什么</h3><p>网站资源服务器，反向代理负载均衡。</p>\n<h3 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h3><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p>\n<p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>首先明确两个概念：</p>\n<ul>\n<li>负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。</li>\n<li>均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。<br>故将服务器接收到的请求按照规则分发的过程，称为负载均衡。<h4 id=\"HTTP重定向实现\"><a href=\"#HTTP重定向实现\" class=\"headerlink\" title=\"HTTP重定向实现\b\"></a>HTTP重定向实现\b</h4>当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br></li>\n</ul>\n<p>在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br></p>\n<p>调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br></p>\n<ul>\n<li><p>随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。</p>\n</li>\n<li><p>轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。</p>\n</li>\n</ul>\n<p>由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br></p>\n<h5 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br></p>\n<p>在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br></p>\n<p>由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br></p>\n<p>若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br></p>\n<h4 id=\"DNS负载均衡\"><a href=\"#DNS负载均衡\" class=\"headerlink\" title=\"DNS负载均衡\"></a>DNS负载均衡</h4><p>DNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。</p>\n<h5 id=\"具体做法\"><a href=\"#具体做法\" class=\"headerlink\" title=\"具体做法\"></a>具体做法</h5><p>首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。</p>\n<p>当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。</p>\n<h5 id=\"调度策略\"><a href=\"#调度策略\" class=\"headerlink\" title=\"调度策略\"></a>调度策略</h5><p>一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。</p>\n<h5 id=\"优缺点分析-1\"><a href=\"#优缺点分析-1\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。<br>此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。<br><br><br>但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。<br><br><br>DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。<br><br><br>此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。<br><br><br>动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。<br><br></p>\n<h4 id=\"反向代理负载均衡\"><a href=\"#反向代理负载均衡\" class=\"headerlink\" title=\"反向代理负载均衡\"></a>反向代理负载均衡</h4><p>反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。<br><br><br>之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。<br><br><br>我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。<br><br></p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>隐藏后端服务器。</li>\n<li>与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。<br>故障转移</li>\n<li>与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。<br>合理分配任务</li>\n<li><p>HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5></li>\n<li><p>调度者压力过大</p>\n</li>\n<li>由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。<br>制约扩展</li>\n<li>当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"Nginx是啥\"><a href=\"#Nginx是啥\" class=\"headerlink\" title=\"Nginx是啥\"></a>Nginx是啥</h3><p>Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br>","more":"</p>\n<h3 id=\"Nginx可以干什么\"><a href=\"#Nginx可以干什么\" class=\"headerlink\" title=\"Nginx可以干什么\"></a>Nginx可以干什么</h3><p>网站资源服务器，反向代理负载均衡。</p>\n<h3 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h3><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p>\n<p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>首先明确两个概念：</p>\n<ul>\n<li>负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。</li>\n<li>均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。<br>故将服务器接收到的请求按照规则分发的过程，称为负载均衡。<h4 id=\"HTTP重定向实现\"><a href=\"#HTTP重定向实现\" class=\"headerlink\" title=\"HTTP重定向实现\b\"></a>HTTP重定向实现\b</h4>当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br></li>\n</ul>\n<p>在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br></p>\n<p>调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br></p>\n<ul>\n<li><p>随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。</p>\n</li>\n<li><p>轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。</p>\n</li>\n</ul>\n<p>由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br></p>\n<h5 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br></p>\n<p>在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br></p>\n<p>由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br></p>\n<p>若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br></p>\n<h4 id=\"DNS负载均衡\"><a href=\"#DNS负载均衡\" class=\"headerlink\" title=\"DNS负载均衡\"></a>DNS负载均衡</h4><p>DNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。</p>\n<h5 id=\"具体做法\"><a href=\"#具体做法\" class=\"headerlink\" title=\"具体做法\"></a>具体做法</h5><p>首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。</p>\n<p>当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。</p>\n<h5 id=\"调度策略\"><a href=\"#调度策略\" class=\"headerlink\" title=\"调度策略\"></a>调度策略</h5><p>一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。</p>\n<h5 id=\"优缺点分析-1\"><a href=\"#优缺点分析-1\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。<br>此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。<br><br><br>但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。<br><br><br>DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。<br><br><br>此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。<br><br><br>动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。<br><br></p>\n<h4 id=\"反向代理负载均衡\"><a href=\"#反向代理负载均衡\" class=\"headerlink\" title=\"反向代理负载均衡\"></a>反向代理负载均衡</h4><p>反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。<br><br><br>之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。<br><br><br>我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。<br><br></p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>隐藏后端服务器。</li>\n<li>与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。<br>故障转移</li>\n<li>与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。<br>合理分配任务</li>\n<li><p>HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5></li>\n<li><p>调度者压力过大</p>\n</li>\n<li>由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。<br>制约扩展</li>\n<li>当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。</li>\n</ul>"},{"title":"前端面试收集","date":"2018-04-02T06:42:08.000Z","_content":"\n本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。\n\n<!--more-->\n\n## HTML\n\n#### 1. DOCTYPE 作用？有哪些模式，模式怎么区分？\n\n**答**：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：\n\n1. 标准模式（standards mode）：浏览器根据标准规约来渲染页面。\n2. 混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。\n\n\n如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。\n\n1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）\n2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）\n3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）\n4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）\n#### 2. 常用的DOCTYPE声明有几种？\n\n**答**：\n\n1. HTML5 `<!DOCTYPE html>`\n2. HTML 4.01 Strict `<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">`\n3. HTML 4.01 Transitional\n\n```HTML\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n#### 3. 什么是 HTML 语义化，为什么要语义化？\n\n**答**：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含\n\n1. 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重\n2. 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构\n3. 方便其他设备的解析\n4. 便于团队开发和维护\n\n#### 4. 行内元素、块级元素、空(void)元素都有那些？\n\n**答**：\n\n* 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n* 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n* 空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img\n\n#### 5. 简述一下 src 与 href 的区别？\n\n**答**：\n\n* href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接\n* src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部\n\n#### 6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\n\n**答**：Cookie, localStorage 和 sessionStorage.\n\n1. Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。\n2. LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。\n\n以下为三者之间的区别：\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>特性</th>\n\t\t\t<th>Cookie</th>\n\t\t\t<th>localStorage</th>\n\t\t\t<th>sessionStorage</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>数据的生命期</td>\n\t\t\t<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n\t\t\t<td>除非被清除，否则永久保存</td>\n\t\t\t<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>存放数据大小</td>\n\t\t\t<td>4K左右</td>\n\t\t\t<td colspan=\"2\">一般为5MB</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>与服务器端通信</td>\n\t\t\t<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n\t\t\t<td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>易用性</td>\n\t\t\t<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n\t\t\t<td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n#### 7. 什么是跨域请求？其限制原因有哪些？\n\n**答**：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。\n\n#### 8. 前端跨域请求解决方案都有哪些？\n\n**答**：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 [前端跨域请求解决方案汇总](https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md) 或者 [Joe's Blog](https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/).\n\n#### 9. iframe 的优缺点？\n\n**答**：\n\n优点\n\n1. 程序调入静态页面比较方便\n2. 页面和程序分离\n3. 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)\n4. 能够原封不动的把嵌入的网页展现出来\n\n缺点\n\n1. 会产生很多页面，不容易管理\n2. 不容易打印\n3. 浏览器的后退按钮无效\n4. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用\niframe会不利于搜索引擎优化\n5. 多数小型的移动设备无法完全显示框架，设备兼容性差\n6. 多框架的页面会增加服务器的http请求，对于大型网站是不可取的\n\n#### 10. iframe 有哪些使用场景？\n\n**答**：\n\n1. 沙箱隔离。\n2. 引用第三方内容。\n3. 独立的带有交互的内容，比如幻灯片。\n4. 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。\n\n#### 11. HTML 的全局属性都有哪些？\n\n**答**：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。\n\n- `accesskey`:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按``alt + shift + a``可激活元素\n- `class`:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素\n- `contenteditable`: 指定元素内容是否可编辑\n- `contextmenu`: 自定义鼠标右键弹出菜单内容\n- `data-*`: 为元素增加自定义属性\n- `dir`: 设置元素文本方向\n- `draggable`: 设置元素是否可拖拽\n- `dropzone`: 设置元素拖放类型： copy, move, link\n- `hidden`: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果\n- `id`: 元素id，文档内唯一\n- `lang`: 元素内容的的语言\n- `spellcheck`: 是否启动拼写和语法检查\n- `style`: 行内css样式\n- `tabindex`: 设置元素可以获得焦点，通过tab可以导航\n- `title`: 元素相关的建议信息\n- `translate`: 元素和子孙节点内容是否需要本地化\n\n#### 12. 常见的浏览器内核有哪些？\n\n浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。\n\n* Trident 为 IE 内核，又称 MSHTML\n* Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核\n* Webkit 内核：Safari, Chrome 等\n* Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支\n* Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink\n* 移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident\n\n\n## JavaScript\n\n#### 1. ECMAScript/JavaScript 中都有那些数据类型？\n\n**答**：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.\n\n#### 2. 把非数值转化为数值的函数都有哪些？\n\n**答**：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。\n\n#### 3. JavaScript 中的 new 关键词做了什么？\n\n* **答**：他做了五件事\n\n1. 他生成了一个新对象。这个对象的类型只是一个普通的对象；\n2. 他将新对象内部、不可访问的原型属性（例如：`__proto__`）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 `prototype` 属性）；\n3. 他将 `this` 变量指向这个新生成的对象；\n4. 他执行构造器函数，对于每个提及到 `this` 的地方使用新生成的对象执行；\n5. 他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；\n\n#### 4. JavaScript 的六种继承类型？\n\n* **答**：\n\n* 简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；\n\n```\nfunction Super(){\n    this.val = 1;\n}\nfunction Sub(){\n    // ...\n}\nSub.prototype = new Super();\nlet sub1 = new Sub();\n```\n\n* 借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 `fun` 函数，太多了就会影响性能；\n\n```\nfunction Super(val){\n    this.val = val;\n    this.fun = function(){\n        // ...\n    }\n}\nfunction Sub(val){\n    Super.call(this, val);   // 核心\n}\nlet sub1 = new Sub(1);\n```\n\n* 组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；\n\n```\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nSub.prototype = new Super();    // 核心\nlet sub1 = new Sub(1);\n```\n\n* 原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n// 拿到父类对象\nlet sup = new Super();\n// 生孩子\nlet sub = beget(sup);\n```\n\n* 寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；\n\n```\nfunction beget(obj){   // 生孩子函数\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nfunction getSubObject(obj){\n    // 创建新对象\n    let clone = beget(obj); // 核心\n    // 增强\n    clone.attr1 = 1;\n    clone.attr2 = 2;\n    return clone;\n}\nvar sub = getSubObject(new Super());\n```\n\n* 寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n    this.arr = [1];\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nSuper.prototype.fun2 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nlet proto = beget(Super.prototype); // 核心\nproto.constructor = Sub;            // 核心\nSub.prototype = proto;              // 核心\nlet sub = new Sub();\n```\n\n#### 5. 箭头函数的适用规则？\n\n* **答**：\n\n* 如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=>箭头函数。\n* 对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=>函数语法。\n\n#### 6. 为什么我们区别 LHS 和 RHS 那么重要？\n\n**答**：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。\n\n#### 7. 如何区分声明和表达式？\n\n**答**：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。\n\n#### 8. IIFE 方式与变种？\n\n**答**：\n\n```javascript\n// 1\n(function foo(){ .. })()\n// 2\n(function(){ .. }())\n// 3，用于 UMD 项目\n(function IIFE( def ){\n\tdef( window );\n})(function def( global ){\n\tlet a = 3;\n\tconsole.log( a ); // 3\n\tconsole.log( global.a ); // 2\n});\n```\n\n#### 9. 请解释如下代码执行的结果？\n\n```\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n```\n\n**答**：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为\"\"因此{}也会被强制转换为一个string：\"[object Object]\"。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。\n\n#### 10. 什么是事件委托？\n\n**答**：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。\n\n#### 11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\n\n**答**：\n\n1. 捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；\n2. 目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；\n3. 冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；\n\n#### 12. 触摸事件都有哪些？\n\n**答**：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件\n\n1. touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。\n2. touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。\n3. touchend事件：当手指从屏幕上离开的时候触发。\n\n#### 13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\n\n**答**：\n\n1. event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。\n2. event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。**特别说明：IE不支持！**\n3. screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。\n4. event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。**特别说明：只有IE支持！**\n\n## CSS\n\n#### 1. 什么是盒子模型？\n\n**答**：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。\n\n#### 2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\n\n**答**：使用 CSS `word-break` 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS `text-overflow` 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。\n\n#### 3. 什么是 Data URI？\n\n**答**：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。\n\n#### 4. Data URI 的好处和缺点都有哪些？\n\n**答**：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：\n\n* 当访问外部资源很麻烦或受限时。\n* 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。\n* 当图片的体积太小，占用一个HTTP会话不是很值得时。\n\nData URL也有一些不适用的场合：\n\n* Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。\n* Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。\n\n#### 5. 内联元素和块级元素的区别？\n\n**答**：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。\n\n#### 6. CSS Transform / Transition / Animation 属性的区别？\n\n**答**：\n\n* transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；\n* transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；\n* animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；\n\n#### 7. position 布局方式都有哪些？\n\n**答**：\n\n* **static** - static 是默认值。任意 `position: static;` 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。\n* **relative** - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。\n* **fixed** - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。\n* **absolute** - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。\n\n*记住一个“positioned”元素是指 position 值不是 static 的元素。*\n\n#### 8. display 的属性都有哪些？\n\n**答**：块级元素默认值为 block，而行内元素为 inline。\n\n* **block** - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。\n* **inline** - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。\n* **none** - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。\n\n其他 display 值，例如 inline-block, list-item, table 和 flex。\n\n## Node 软件包管理\n\n#### 1. 简述同步和异步之间的区别？\n\n**答**：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率\n\n#### 2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 `\"d3\": \"^3.9.0\"` 或者 `\"d3\": \"~3.9.0\"`，请问 \"^\" 和 \"~\" 的含义分别是什么？\n\n**答**：根据 [\"npm install --save\" No Longer Using Tildes](http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/) 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。\n\n## 浏览器\n\n#### 3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\n\n**答**：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：\n\n```\nfunction inIframe () {\n    try {\n        return window.self !== window.top;\n    } catch (e) {\n        return true;\n    }\n}\n```\n\ntop 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。\n\n## HTTP\n\n#### 1. HTTP/0.9 只有一个命令 `GET`, HTTP/1.0 引入了 `POST` 命令和 `HEAD` 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\n\n**答**：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是\n\n1. OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'\\*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n2. HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\n3. GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法\n4. POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\n5. PUT：向指定资源位置上传其最新内容。\n6. DELETE：请求服务器删除Request-URI所标识的资源。\n7. TRACE：回显服务器收到的请求，主要用于测试或诊断。\n8. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\n\n#### 2. HTTP 状态码的主要类型有哪些？\n\n**答**：状态代码的第一个数字代表当前响应的类型，主要为五类\n\n1. 1xx消息——请求已被服务器接收，继续处理\n2. 2xx成功——请求已成功被服务器接收、理解、并接受\n3. 3xx重定向——需要后续操作才能完成这一请求\n4. 4xx请求错误——请求含有词法错误或者无法被执行\n5. 5xx服务器错误——服务器在处理某个正确请求时发生错误\n\n详细情况见 [维基百科](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)。\n\n#### 3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\n\n**答**：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n#### 4. HTTPS 建立连接的过程？\n\n**答**：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。\n\n1. 客户端发出握手请求 (Client Hello)，包含以下信息：\n\t* 支持的协议版本，比如TLS 1.0\n\t* 一个客户端生成的随机数(random\\_1)，这个随机数既需要客户端保存又需要发送给服务器\n\t* 支持的加密方法，比如RSA公钥加密\n\t* 支持的压缩方法\n2. 服务器回复 (Server Hello)，包含以下信息：\n\t* 确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信\n\t* 一个服务器生成的随机数 (random\\_2)\n\t* 确认使用的加密方法，比如RSA公钥加密\n\t* 服务器证书（其中包含服务器放入公钥）\n\t* 可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书\n3. 客户端回应，包含以下步骤：\n\t* 验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开\n\t* 客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验\n4. 服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random\\_1 和 random\\_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验\n\n在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。\n\n需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。\n\n![SSL 连接建立过程详解图](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png\")\n\n#### 4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\n\n**答**：\n\n* OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n* TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。\n* 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。\n* 每一层的协议如下：\n\t* 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）\n\t* 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）\n\t* 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）\n\t* 传输层：TCP、UDP、SPX\n\t* 会话层：NFS、SQL、NETBIOS、RPC\n\t* 表示层：JPEG、MPEG、ASII\n\t* 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n* 每一层的作用如下：\n\t* 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\n\t* 数据链路层：将比特组装成帧和点到点的传递（帧Frame）\n\t* 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\n\t* 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\n\t* 会话层：建立、管理和终止会话（会话协议数据单元SPDU）\n\t* 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\n\t* 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\n\n#### 5. IP 地址的分类？\n\n**答**：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—\n192.168.255.255 为 Internet 上保留地址用于内部。\n\n#### 6. 互联网上各类协议的介绍？\n\n**答**：\n\n1. ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。\n2. TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。\n3. HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。\n4. DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。\nNAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。\n5. DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。\n\n#### 7. TCP 和 UDP 的区别？\n\n**答**：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：\n\n```\nTCP 协议\n（1） FTP：定义了文件传输协议，使用21端口。\n（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。\n（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。\n（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。\n（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。\nUDP协议\n（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。\n（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\n（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。\n```\n","source":"_posts/js-面试.md","raw":"---\ntitle: 前端面试收集\ndate: 2018-04-02 14:42:08\ntags: javascript\ncategories: 学习\n---\n\n本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。\n\n<!--more-->\n\n## HTML\n\n#### 1. DOCTYPE 作用？有哪些模式，模式怎么区分？\n\n**答**：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：\n\n1. 标准模式（standards mode）：浏览器根据标准规约来渲染页面。\n2. 混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。\n\n\n如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。\n\n1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）\n2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）\n3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）\n4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）\n#### 2. 常用的DOCTYPE声明有几种？\n\n**答**：\n\n1. HTML5 `<!DOCTYPE html>`\n2. HTML 4.01 Strict `<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">`\n3. HTML 4.01 Transitional\n\n```HTML\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n#### 3. 什么是 HTML 语义化，为什么要语义化？\n\n**答**：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含\n\n1. 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重\n2. 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构\n3. 方便其他设备的解析\n4. 便于团队开发和维护\n\n#### 4. 行内元素、块级元素、空(void)元素都有那些？\n\n**答**：\n\n* 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n* 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n* 空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img\n\n#### 5. 简述一下 src 与 href 的区别？\n\n**答**：\n\n* href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接\n* src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部\n\n#### 6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\n\n**答**：Cookie, localStorage 和 sessionStorage.\n\n1. Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。\n2. LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。\n\n以下为三者之间的区别：\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>特性</th>\n\t\t\t<th>Cookie</th>\n\t\t\t<th>localStorage</th>\n\t\t\t<th>sessionStorage</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>数据的生命期</td>\n\t\t\t<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n\t\t\t<td>除非被清除，否则永久保存</td>\n\t\t\t<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>存放数据大小</td>\n\t\t\t<td>4K左右</td>\n\t\t\t<td colspan=\"2\">一般为5MB</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>与服务器端通信</td>\n\t\t\t<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n\t\t\t<td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>易用性</td>\n\t\t\t<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n\t\t\t<td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n#### 7. 什么是跨域请求？其限制原因有哪些？\n\n**答**：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。\n\n#### 8. 前端跨域请求解决方案都有哪些？\n\n**答**：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 [前端跨域请求解决方案汇总](https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md) 或者 [Joe's Blog](https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/).\n\n#### 9. iframe 的优缺点？\n\n**答**：\n\n优点\n\n1. 程序调入静态页面比较方便\n2. 页面和程序分离\n3. 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)\n4. 能够原封不动的把嵌入的网页展现出来\n\n缺点\n\n1. 会产生很多页面，不容易管理\n2. 不容易打印\n3. 浏览器的后退按钮无效\n4. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用\niframe会不利于搜索引擎优化\n5. 多数小型的移动设备无法完全显示框架，设备兼容性差\n6. 多框架的页面会增加服务器的http请求，对于大型网站是不可取的\n\n#### 10. iframe 有哪些使用场景？\n\n**答**：\n\n1. 沙箱隔离。\n2. 引用第三方内容。\n3. 独立的带有交互的内容，比如幻灯片。\n4. 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。\n\n#### 11. HTML 的全局属性都有哪些？\n\n**答**：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。\n\n- `accesskey`:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按``alt + shift + a``可激活元素\n- `class`:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素\n- `contenteditable`: 指定元素内容是否可编辑\n- `contextmenu`: 自定义鼠标右键弹出菜单内容\n- `data-*`: 为元素增加自定义属性\n- `dir`: 设置元素文本方向\n- `draggable`: 设置元素是否可拖拽\n- `dropzone`: 设置元素拖放类型： copy, move, link\n- `hidden`: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果\n- `id`: 元素id，文档内唯一\n- `lang`: 元素内容的的语言\n- `spellcheck`: 是否启动拼写和语法检查\n- `style`: 行内css样式\n- `tabindex`: 设置元素可以获得焦点，通过tab可以导航\n- `title`: 元素相关的建议信息\n- `translate`: 元素和子孙节点内容是否需要本地化\n\n#### 12. 常见的浏览器内核有哪些？\n\n浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。\n\n* Trident 为 IE 内核，又称 MSHTML\n* Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核\n* Webkit 内核：Safari, Chrome 等\n* Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支\n* Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink\n* 移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident\n\n\n## JavaScript\n\n#### 1. ECMAScript/JavaScript 中都有那些数据类型？\n\n**答**：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.\n\n#### 2. 把非数值转化为数值的函数都有哪些？\n\n**答**：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。\n\n#### 3. JavaScript 中的 new 关键词做了什么？\n\n* **答**：他做了五件事\n\n1. 他生成了一个新对象。这个对象的类型只是一个普通的对象；\n2. 他将新对象内部、不可访问的原型属性（例如：`__proto__`）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 `prototype` 属性）；\n3. 他将 `this` 变量指向这个新生成的对象；\n4. 他执行构造器函数，对于每个提及到 `this` 的地方使用新生成的对象执行；\n5. 他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；\n\n#### 4. JavaScript 的六种继承类型？\n\n* **答**：\n\n* 简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；\n\n```\nfunction Super(){\n    this.val = 1;\n}\nfunction Sub(){\n    // ...\n}\nSub.prototype = new Super();\nlet sub1 = new Sub();\n```\n\n* 借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 `fun` 函数，太多了就会影响性能；\n\n```\nfunction Super(val){\n    this.val = val;\n    this.fun = function(){\n        // ...\n    }\n}\nfunction Sub(val){\n    Super.call(this, val);   // 核心\n}\nlet sub1 = new Sub(1);\n```\n\n* 组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；\n\n```\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nSub.prototype = new Super();    // 核心\nlet sub1 = new Sub(1);\n```\n\n* 原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n// 拿到父类对象\nlet sup = new Super();\n// 生孩子\nlet sub = beget(sup);\n```\n\n* 寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；\n\n```\nfunction beget(obj){   // 生孩子函数\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nfunction getSubObject(obj){\n    // 创建新对象\n    let clone = beget(obj); // 核心\n    // 增强\n    clone.attr1 = 1;\n    clone.attr2 = 2;\n    return clone;\n}\nvar sub = getSubObject(new Super());\n```\n\n* 寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n    this.arr = [1];\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nSuper.prototype.fun2 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nlet proto = beget(Super.prototype); // 核心\nproto.constructor = Sub;            // 核心\nSub.prototype = proto;              // 核心\nlet sub = new Sub();\n```\n\n#### 5. 箭头函数的适用规则？\n\n* **答**：\n\n* 如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=>箭头函数。\n* 对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=>函数语法。\n\n#### 6. 为什么我们区别 LHS 和 RHS 那么重要？\n\n**答**：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。\n\n#### 7. 如何区分声明和表达式？\n\n**答**：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。\n\n#### 8. IIFE 方式与变种？\n\n**答**：\n\n```javascript\n// 1\n(function foo(){ .. })()\n// 2\n(function(){ .. }())\n// 3，用于 UMD 项目\n(function IIFE( def ){\n\tdef( window );\n})(function def( global ){\n\tlet a = 3;\n\tconsole.log( a ); // 3\n\tconsole.log( global.a ); // 2\n});\n```\n\n#### 9. 请解释如下代码执行的结果？\n\n```\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n```\n\n**答**：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为\"\"因此{}也会被强制转换为一个string：\"[object Object]\"。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。\n\n#### 10. 什么是事件委托？\n\n**答**：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。\n\n#### 11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\n\n**答**：\n\n1. 捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；\n2. 目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；\n3. 冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；\n\n#### 12. 触摸事件都有哪些？\n\n**答**：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件\n\n1. touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。\n2. touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。\n3. touchend事件：当手指从屏幕上离开的时候触发。\n\n#### 13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\n\n**答**：\n\n1. event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。\n2. event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。**特别说明：IE不支持！**\n3. screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。\n4. event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。**特别说明：只有IE支持！**\n\n## CSS\n\n#### 1. 什么是盒子模型？\n\n**答**：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。\n\n#### 2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\n\n**答**：使用 CSS `word-break` 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS `text-overflow` 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。\n\n#### 3. 什么是 Data URI？\n\n**答**：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。\n\n#### 4. Data URI 的好处和缺点都有哪些？\n\n**答**：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：\n\n* 当访问外部资源很麻烦或受限时。\n* 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。\n* 当图片的体积太小，占用一个HTTP会话不是很值得时。\n\nData URL也有一些不适用的场合：\n\n* Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。\n* Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。\n\n#### 5. 内联元素和块级元素的区别？\n\n**答**：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。\n\n#### 6. CSS Transform / Transition / Animation 属性的区别？\n\n**答**：\n\n* transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；\n* transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；\n* animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；\n\n#### 7. position 布局方式都有哪些？\n\n**答**：\n\n* **static** - static 是默认值。任意 `position: static;` 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。\n* **relative** - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。\n* **fixed** - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。\n* **absolute** - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。\n\n*记住一个“positioned”元素是指 position 值不是 static 的元素。*\n\n#### 8. display 的属性都有哪些？\n\n**答**：块级元素默认值为 block，而行内元素为 inline。\n\n* **block** - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。\n* **inline** - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。\n* **none** - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。\n\n其他 display 值，例如 inline-block, list-item, table 和 flex。\n\n## Node 软件包管理\n\n#### 1. 简述同步和异步之间的区别？\n\n**答**：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率\n\n#### 2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 `\"d3\": \"^3.9.0\"` 或者 `\"d3\": \"~3.9.0\"`，请问 \"^\" 和 \"~\" 的含义分别是什么？\n\n**答**：根据 [\"npm install --save\" No Longer Using Tildes](http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/) 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。\n\n## 浏览器\n\n#### 3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\n\n**答**：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：\n\n```\nfunction inIframe () {\n    try {\n        return window.self !== window.top;\n    } catch (e) {\n        return true;\n    }\n}\n```\n\ntop 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。\n\n## HTTP\n\n#### 1. HTTP/0.9 只有一个命令 `GET`, HTTP/1.0 引入了 `POST` 命令和 `HEAD` 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\n\n**答**：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是\n\n1. OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'\\*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n2. HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\n3. GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法\n4. POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\n5. PUT：向指定资源位置上传其最新内容。\n6. DELETE：请求服务器删除Request-URI所标识的资源。\n7. TRACE：回显服务器收到的请求，主要用于测试或诊断。\n8. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\n\n#### 2. HTTP 状态码的主要类型有哪些？\n\n**答**：状态代码的第一个数字代表当前响应的类型，主要为五类\n\n1. 1xx消息——请求已被服务器接收，继续处理\n2. 2xx成功——请求已成功被服务器接收、理解、并接受\n3. 3xx重定向——需要后续操作才能完成这一请求\n4. 4xx请求错误——请求含有词法错误或者无法被执行\n5. 5xx服务器错误——服务器在处理某个正确请求时发生错误\n\n详细情况见 [维基百科](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)。\n\n#### 3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\n\n**答**：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n#### 4. HTTPS 建立连接的过程？\n\n**答**：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。\n\n1. 客户端发出握手请求 (Client Hello)，包含以下信息：\n\t* 支持的协议版本，比如TLS 1.0\n\t* 一个客户端生成的随机数(random\\_1)，这个随机数既需要客户端保存又需要发送给服务器\n\t* 支持的加密方法，比如RSA公钥加密\n\t* 支持的压缩方法\n2. 服务器回复 (Server Hello)，包含以下信息：\n\t* 确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信\n\t* 一个服务器生成的随机数 (random\\_2)\n\t* 确认使用的加密方法，比如RSA公钥加密\n\t* 服务器证书（其中包含服务器放入公钥）\n\t* 可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书\n3. 客户端回应，包含以下步骤：\n\t* 验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开\n\t* 客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验\n4. 服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random\\_1 和 random\\_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验\n\n在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。\n\n需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。\n\n![SSL 连接建立过程详解图](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png\")\n\n#### 4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\n\n**答**：\n\n* OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n* TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。\n* 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。\n* 每一层的协议如下：\n\t* 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）\n\t* 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）\n\t* 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）\n\t* 传输层：TCP、UDP、SPX\n\t* 会话层：NFS、SQL、NETBIOS、RPC\n\t* 表示层：JPEG、MPEG、ASII\n\t* 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n* 每一层的作用如下：\n\t* 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\n\t* 数据链路层：将比特组装成帧和点到点的传递（帧Frame）\n\t* 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\n\t* 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\n\t* 会话层：建立、管理和终止会话（会话协议数据单元SPDU）\n\t* 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\n\t* 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\n\n#### 5. IP 地址的分类？\n\n**答**：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—\n192.168.255.255 为 Internet 上保留地址用于内部。\n\n#### 6. 互联网上各类协议的介绍？\n\n**答**：\n\n1. ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。\n2. TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。\n3. HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。\n4. DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。\nNAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。\n5. DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。\n\n#### 7. TCP 和 UDP 的区别？\n\n**答**：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：\n\n```\nTCP 协议\n（1） FTP：定义了文件传输协议，使用21端口。\n（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。\n（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。\n（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。\n（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。\nUDP协议\n（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。\n（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\n（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。\n```\n","slug":"js-面试","published":1,"updated":"2019-09-17T02:38:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rwcd0031kwfyyvhqtm65","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。</p>\n<a id=\"more\"></a>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h4 id=\"1-DOCTYPE-作用？有哪些模式，模式怎么区分？\"><a href=\"#1-DOCTYPE-作用？有哪些模式，模式怎么区分？\" class=\"headerlink\" title=\"1. DOCTYPE 作用？有哪些模式，模式怎么区分？\"></a>1. DOCTYPE 作用？有哪些模式，模式怎么区分？</h4><p><strong>答</strong>：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：</p>\n<ol>\n<li>标准模式（standards mode）：浏览器根据标准规约来渲染页面。</li>\n<li>混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。</li>\n</ol>\n<p>如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。</p>\n<p>1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）<br>2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）<br>3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）<br>4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）</p>\n<h4 id=\"2-常用的DOCTYPE声明有几种？\"><a href=\"#2-常用的DOCTYPE声明有几种？\" class=\"headerlink\" title=\"2. 常用的DOCTYPE声明有几种？\"></a>2. 常用的DOCTYPE声明有几种？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>HTML5 <code>&lt;!DOCTYPE html&gt;</code></li>\n<li>HTML 4.01 Strict <code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li>\n<li>HTML 4.01 Transitional</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-什么是-HTML-语义化，为什么要语义化？\"><a href=\"#3-什么是-HTML-语义化，为什么要语义化？\" class=\"headerlink\" title=\"3. 什么是 HTML 语义化，为什么要语义化？\"></a>3. 什么是 HTML 语义化，为什么要语义化？</h4><p><strong>答</strong>：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含</p>\n<ol>\n<li>有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重</li>\n<li>语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构</li>\n<li>方便其他设备的解析</li>\n<li>便于团队开发和维护</li>\n</ol>\n<h4 id=\"4-行内元素、块级元素、空-void-元素都有那些？\"><a href=\"#4-行内元素、块级元素、空-void-元素都有那些？\" class=\"headerlink\" title=\"4. 行内元素、块级元素、空(void)元素都有那些？\"></a>4. 行内元素、块级元素、空(void)元素都有那些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</li>\n<li>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</li>\n<li>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</li>\n</ul>\n<h4 id=\"5-简述一下-src-与-href-的区别？\"><a href=\"#5-简述一下-src-与-href-的区别？\" class=\"headerlink\" title=\"5. 简述一下 src 与 href 的区别？\"></a>5. 简述一下 src 与 href 的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接</li>\n<li>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</li>\n</ul>\n<h4 id=\"6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\"><a href=\"#6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\" class=\"headerlink\" title=\"6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\"></a>6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？</h4><p><strong>答</strong>：Cookie, localStorage 和 sessionStorage.</p>\n<ol>\n<li>Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。</li>\n<li>LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。</li>\n</ol>\n<p>以下为三者之间的区别：</p>\n<table><br>    <thead><br>        <tr><br>            <th>特性</th><br>            <th>Cookie</th><br>            <th>localStorage</th><br>            <th>sessionStorage</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>数据的生命期</td><br>            <td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><br>            <td>除非被清除，否则永久保存</td><br>            <td>仅在当前会话下有效，关闭页面或浏览器后被清除</td><br>        </tr><br>        <tr><br>            <td>存放数据大小</td><br>            <td>4K左右</td><br>            <td colspan=\"2\">一般为5MB</td><br>        </tr><br>        <tr><br>            <td>与服务器端通信</td><br>            <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td><br>            <td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><br>        </tr><br>        <tr><br>            <td>易用性</td><br>            <td>需要程序员自己封装，源生的Cookie接口不友好</td><br>            <td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td><br>        </tr><br>    </tbody><br></table>\n\n<h4 id=\"7-什么是跨域请求？其限制原因有哪些？\"><a href=\"#7-什么是跨域请求？其限制原因有哪些？\" class=\"headerlink\" title=\"7. 什么是跨域请求？其限制原因有哪些？\"></a>7. 什么是跨域请求？其限制原因有哪些？</h4><p><strong>答</strong>：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>\n<p>跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<h4 id=\"8-前端跨域请求解决方案都有哪些？\"><a href=\"#8-前端跨域请求解决方案都有哪些？\" class=\"headerlink\" title=\"8. 前端跨域请求解决方案都有哪些？\"></a>8. 前端跨域请求解决方案都有哪些？</h4><p><strong>答</strong>：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 <a href=\"https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md\" target=\"_blank\" rel=\"noopener\">前端跨域请求解决方案汇总</a> 或者 <a href=\"https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/\" target=\"_blank\" rel=\"noopener\">Joe’s Blog</a>.</p>\n<h4 id=\"9-iframe-的优缺点？\"><a href=\"#9-iframe-的优缺点？\" class=\"headerlink\" title=\"9. iframe 的优缺点？\"></a>9. iframe 的优缺点？</h4><p><strong>答</strong>：</p>\n<p>优点</p>\n<ol>\n<li>程序调入静态页面比较方便</li>\n<li>页面和程序分离</li>\n<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)</li>\n<li>能够原封不动的把嵌入的网页展现出来</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>会产生很多页面，不容易管理</li>\n<li>不容易打印</li>\n<li>浏览器的后退按钮无效</li>\n<li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用<br>iframe会不利于搜索引擎优化</li>\n<li>多数小型的移动设备无法完全显示框架，设备兼容性差</li>\n<li>多框架的页面会增加服务器的http请求，对于大型网站是不可取的</li>\n</ol>\n<h4 id=\"10-iframe-有哪些使用场景？\"><a href=\"#10-iframe-有哪些使用场景？\" class=\"headerlink\" title=\"10. iframe 有哪些使用场景？\"></a>10. iframe 有哪些使用场景？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>沙箱隔离。</li>\n<li>引用第三方内容。</li>\n<li>独立的带有交互的内容，比如幻灯片。</li>\n<li>需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。</li>\n</ol>\n<h4 id=\"11-HTML-的全局属性都有哪些？\"><a href=\"#11-HTML-的全局属性都有哪些？\" class=\"headerlink\" title=\"11. HTML 的全局属性都有哪些？\"></a>11. HTML 的全局属性都有哪些？</h4><p><strong>答</strong>：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。</p>\n<ul>\n<li><code>accesskey</code>:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按<code>alt + shift + a</code>可激活元素</li>\n<li><code>class</code>:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li>\n<li><code>contenteditable</code>: 指定元素内容是否可编辑</li>\n<li><code>contextmenu</code>: 自定义鼠标右键弹出菜单内容</li>\n<li><code>data-*</code>: 为元素增加自定义属性</li>\n<li><code>dir</code>: 设置元素文本方向</li>\n<li><code>draggable</code>: 设置元素是否可拖拽</li>\n<li><code>dropzone</code>: 设置元素拖放类型： copy, move, link</li>\n<li><code>hidden</code>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li>\n<li><code>id</code>: 元素id，文档内唯一</li>\n<li><code>lang</code>: 元素内容的的语言</li>\n<li><code>spellcheck</code>: 是否启动拼写和语法检查</li>\n<li><code>style</code>: 行内css样式</li>\n<li><code>tabindex</code>: 设置元素可以获得焦点，通过tab可以导航</li>\n<li><code>title</code>: 元素相关的建议信息</li>\n<li><code>translate</code>: 元素和子孙节点内容是否需要本地化</li>\n</ul>\n<h4 id=\"12-常见的浏览器内核有哪些？\"><a href=\"#12-常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"12. 常见的浏览器内核有哪些？\"></a>12. 常见的浏览器内核有哪些？</h4><p>浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。</p>\n<ul>\n<li>Trident 为 IE 内核，又称 MSHTML</li>\n<li>Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核</li>\n<li>Webkit 内核：Safari, Chrome 等</li>\n<li>Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支</li>\n<li>Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink</li>\n<li>移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident</li>\n</ul>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h4 id=\"1-ECMAScript-JavaScript-中都有那些数据类型？\"><a href=\"#1-ECMAScript-JavaScript-中都有那些数据类型？\" class=\"headerlink\" title=\"1. ECMAScript/JavaScript 中都有那些数据类型？\"></a>1. ECMAScript/JavaScript 中都有那些数据类型？</h4><p><strong>答</strong>：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.</p>\n<h4 id=\"2-把非数值转化为数值的函数都有哪些？\"><a href=\"#2-把非数值转化为数值的函数都有哪些？\" class=\"headerlink\" title=\"2. 把非数值转化为数值的函数都有哪些？\"></a>2. 把非数值转化为数值的函数都有哪些？</h4><p><strong>答</strong>：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p>\n<h4 id=\"3-JavaScript-中的-new-关键词做了什么？\"><a href=\"#3-JavaScript-中的-new-关键词做了什么？\" class=\"headerlink\" title=\"3. JavaScript 中的 new 关键词做了什么？\"></a>3. JavaScript 中的 new 关键词做了什么？</h4><ul>\n<li><strong>答</strong>：他做了五件事</li>\n</ul>\n<ol>\n<li>他生成了一个新对象。这个对象的类型只是一个普通的对象；</li>\n<li>他将新对象内部、不可访问的原型属性（例如：<code>__proto__</code>）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 <code>prototype</code> 属性）；</li>\n<li>他将 <code>this</code> 变量指向这个新生成的对象；</li>\n<li>他执行构造器函数，对于每个提及到 <code>this</code> 的地方使用新生成的对象执行；</li>\n<li>他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；</li>\n</ol>\n<h4 id=\"4-JavaScript-的六种继承类型？\"><a href=\"#4-JavaScript-的六种继承类型？\" class=\"headerlink\" title=\"4. JavaScript 的六种继承类型？\"></a>4. JavaScript 的六种继承类型？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();</span><br><span class=\"line\">let sub1 = new Sub();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 <code>fun</code> 函数，太多了就会影响性能；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val = val;</span><br><span class=\"line\">    this.fun = function()&#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this, val);   // 核心</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();    // 核心</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 拿到父类对象</span><br><span class=\"line\">let sup = new Super();</span><br><span class=\"line\">// 生孩子</span><br><span class=\"line\">let sub = beget(sup);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getSubObject(obj)&#123;</span><br><span class=\"line\">    // 创建新对象</span><br><span class=\"line\">    let clone = beget(obj); // 核心</span><br><span class=\"line\">    // 增强</span><br><span class=\"line\">    clone.attr1 = 1;</span><br><span class=\"line\">    clone.attr2 = 2;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sub = getSubObject(new Super());</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">Super.prototype.fun2 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proto = beget(Super.prototype); // 核心</span><br><span class=\"line\">proto.constructor = Sub;            // 核心</span><br><span class=\"line\">Sub.prototype = proto;              // 核心</span><br><span class=\"line\">let sub = new Sub();</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-箭头函数的适用规则？\"><a href=\"#5-箭头函数的适用规则？\" class=\"headerlink\" title=\"5. 箭头函数的适用规则？\"></a>5. 箭头函数的适用规则？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=&gt;箭头函数。</p>\n</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=&gt;箭头函数。</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=&gt;箭头函数。</li>\n<li>对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=&gt;函数语法。</li>\n</ul>\n<h4 id=\"6-为什么我们区别-LHS-和-RHS-那么重要？\"><a href=\"#6-为什么我们区别-LHS-和-RHS-那么重要？\" class=\"headerlink\" title=\"6. 为什么我们区别 LHS 和 RHS 那么重要？\"></a>6. 为什么我们区别 LHS 和 RHS 那么重要？</h4><p><strong>答</strong>：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。</p>\n<h4 id=\"7-如何区分声明和表达式？\"><a href=\"#7-如何区分声明和表达式？\" class=\"headerlink\" title=\"7. 如何区分声明和表达式？\"></a>7. 如何区分声明和表达式？</h4><p><strong>答</strong>：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。</p>\n<h4 id=\"8-IIFE-方式与变种？\"><a href=\"#8-IIFE-方式与变种？\" class=\"headerlink\" title=\"8. IIFE 方式与变种？\"></a>8. IIFE 方式与变种？</h4><p><strong>答</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;)()</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;())</span><br><span class=\"line\"><span class=\"comment\">// 3，用于 UMD 项目</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>)</span>&#123;</span><br><span class=\"line\">\tdef( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-请解释如下代码执行的结果？\"><a href=\"#9-请解释如下代码执行的结果？\" class=\"headerlink\" title=\"9. 请解释如下代码执行的结果？\"></a>9. 请解释如下代码执行的结果？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + &#123;&#125;; // &quot;[object Object]&quot;</span><br><span class=\"line\">&#123;&#125; + []; // 0</span><br></pre></td></tr></table></figure>\n<p><strong>答</strong>：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为””因此{}也会被强制转换为一个string：”[object Object]”。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。</p>\n<h4 id=\"10-什么是事件委托？\"><a href=\"#10-什么是事件委托？\" class=\"headerlink\" title=\"10. 什么是事件委托？\"></a>10. 什么是事件委托？</h4><p><strong>答</strong>：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。</p>\n<h4 id=\"11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\"><a href=\"#11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\" class=\"headerlink\" title=\"11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\"></a>11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；</li>\n<li>目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；</li>\n<li>冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>\n</ol>\n<h4 id=\"12-触摸事件都有哪些？\"><a href=\"#12-触摸事件都有哪些？\" class=\"headerlink\" title=\"12. 触摸事件都有哪些？\"></a>12. 触摸事件都有哪些？</h4><p><strong>答</strong>：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件</p>\n<ol>\n<li>touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。</li>\n<li>touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。</li>\n<li>touchend事件：当手指从屏幕上离开的时候触发。</li>\n</ol>\n<h4 id=\"13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\"><a href=\"#13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\" class=\"headerlink\" title=\"13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\"></a>13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。</li>\n<li>event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。<strong>特别说明：IE不支持！</strong></li>\n<li>screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。</li>\n<li>event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。<strong>特别说明：只有IE支持！</strong></li>\n</ol>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h4 id=\"1-什么是盒子模型？\"><a href=\"#1-什么是盒子模型？\" class=\"headerlink\" title=\"1. 什么是盒子模型？\"></a>1. 什么是盒子模型？</h4><p><strong>答</strong>：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p>\n<h4 id=\"2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"><a href=\"#2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\" class=\"headerlink\" title=\"2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"></a>2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？</h4><p><strong>答</strong>：使用 CSS <code>word-break</code> 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS <code>text-overflow</code> 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。</p>\n<h4 id=\"3-什么是-Data-URI？\"><a href=\"#3-什么是-Data-URI？\" class=\"headerlink\" title=\"3. 什么是 Data URI？\"></a>3. 什么是 Data URI？</h4><p><strong>答</strong>：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。</p>\n<h4 id=\"4-Data-URI-的好处和缺点都有哪些？\"><a href=\"#4-Data-URI-的好处和缺点都有哪些？\" class=\"headerlink\" title=\"4. Data URI 的好处和缺点都有哪些？\"></a>4. Data URI 的好处和缺点都有哪些？</h4><p><strong>答</strong>：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：</p>\n<ul>\n<li>当访问外部资源很麻烦或受限时。</li>\n<li>当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。</li>\n<li>当图片的体积太小，占用一个HTTP会话不是很值得时。</li>\n</ul>\n<p>Data URL也有一些不适用的场合：</p>\n<ul>\n<li>Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。</li>\n<li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。</li>\n</ul>\n<h4 id=\"5-内联元素和块级元素的区别？\"><a href=\"#5-内联元素和块级元素的区别？\" class=\"headerlink\" title=\"5. 内联元素和块级元素的区别？\"></a>5. 内联元素和块级元素的区别？</h4><p><strong>答</strong>：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。</p>\n<h4 id=\"6-CSS-Transform-Transition-Animation-属性的区别？\"><a href=\"#6-CSS-Transform-Transition-Animation-属性的区别？\" class=\"headerlink\" title=\"6. CSS Transform / Transition / Animation 属性的区别？\"></a>6. CSS Transform / Transition / Animation 属性的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；</li>\n<li>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；</li>\n<li>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；</li>\n</ul>\n<h4 id=\"7-position-布局方式都有哪些？\"><a href=\"#7-position-布局方式都有哪些？\" class=\"headerlink\" title=\"7. position 布局方式都有哪些？\"></a>7. position 布局方式都有哪些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li><strong>static</strong> - static 是默认值。任意 <code>position: static;</code> 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。</li>\n<li><strong>relative</strong> - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。</li>\n<li><strong>fixed</strong> - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。</li>\n<li><strong>absolute</strong> - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。</li>\n</ul>\n<p><em>记住一个“positioned”元素是指 position 值不是 static 的元素。</em></p>\n<h4 id=\"8-display-的属性都有哪些？\"><a href=\"#8-display-的属性都有哪些？\" class=\"headerlink\" title=\"8. display 的属性都有哪些？\"></a>8. display 的属性都有哪些？</h4><p><strong>答</strong>：块级元素默认值为 block，而行内元素为 inline。</p>\n<ul>\n<li><strong>block</strong> - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。</li>\n<li><strong>inline</strong> - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。</li>\n<li><strong>none</strong> - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。</li>\n</ul>\n<p>其他 display 值，例如 inline-block, list-item, table 和 flex。</p>\n<h2 id=\"Node-软件包管理\"><a href=\"#Node-软件包管理\" class=\"headerlink\" title=\"Node 软件包管理\"></a>Node 软件包管理</h2><h4 id=\"1-简述同步和异步之间的区别？\"><a href=\"#1-简述同步和异步之间的区别？\" class=\"headerlink\" title=\"1. 简述同步和异步之间的区别？\"></a>1. 简述同步和异步之间的区别？</h4><p><strong>答</strong>：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率</p>\n<h4 id=\"2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\"><a href=\"#2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\" class=\"headerlink\" title=\"2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 &quot;d3&quot;: &quot;^3.9.0&quot; 或者 &quot;d3&quot;: &quot;~3.9.0&quot;，请问 “^” 和 “~” 的含义分别是什么？\"></a>2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 <code>&quot;d3&quot;: &quot;^3.9.0&quot;</code> 或者 <code>&quot;d3&quot;: &quot;~3.9.0&quot;</code>，请问 “^” 和 “~” 的含义分别是什么？</h4><p><strong>答</strong>：根据 <a href=\"http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/\" target=\"_blank\" rel=\"noopener\">“npm install –save” No Longer Using Tildes</a> 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。</p>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><h4 id=\"3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"><a href=\"#3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\" class=\"headerlink\" title=\"3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"></a>3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？</h4><p><strong>答</strong>：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inIframe () &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return window.self !== window.top;</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>top 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h4 id=\"1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\"><a href=\"#1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\" class=\"headerlink\" title=\"1. HTTP/0.9 只有一个命令 GET, HTTP/1.0 引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\"></a>1. HTTP/0.9 只有一个命令 <code>GET</code>, HTTP/1.0 引入了 <code>POST</code> 命令和 <code>HEAD</code> 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？</h4><p><strong>答</strong>：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是</p>\n<ol>\n<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*‘来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</li>\n<li>HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li>\n<li>GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法</li>\n<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>\n<li>PUT：向指定资源位置上传其最新内容。</li>\n<li>DELETE：请求服务器删除Request-URI所标识的资源。</li>\n<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>\n<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</li>\n</ol>\n<h4 id=\"2-HTTP-状态码的主要类型有哪些？\"><a href=\"#2-HTTP-状态码的主要类型有哪些？\" class=\"headerlink\" title=\"2. HTTP 状态码的主要类型有哪些？\"></a>2. HTTP 状态码的主要类型有哪些？</h4><p><strong>答</strong>：状态代码的第一个数字代表当前响应的类型，主要为五类</p>\n<ol>\n<li>1xx消息——请求已被服务器接收，继续处理</li>\n<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>\n<li>3xx重定向——需要后续操作才能完成这一请求</li>\n<li>4xx请求错误——请求含有词法错误或者无法被执行</li>\n<li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li>\n</ol>\n<p>详细情况见 <a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" rel=\"noopener\">维基百科</a>。</p>\n<h4 id=\"3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"><a href=\"#3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\" class=\"headerlink\" title=\"3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"></a>3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><p><strong>答</strong>：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>\n<h4 id=\"4-HTTPS-建立连接的过程？\"><a href=\"#4-HTTPS-建立连接的过程？\" class=\"headerlink\" title=\"4. HTTPS 建立连接的过程？\"></a>4. HTTPS 建立连接的过程？</h4><p><strong>答</strong>：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。</p>\n<ol>\n<li>客户端发出握手请求 (Client Hello)，包含以下信息：<ul>\n<li>支持的协议版本，比如TLS 1.0</li>\n<li>一个客户端生成的随机数(random_1)，这个随机数既需要客户端保存又需要发送给服务器</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回复 (Server Hello)，包含以下信息：<ul>\n<li>确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信</li>\n<li>一个服务器生成的随机数 (random_2)</li>\n<li>确认使用的加密方法，比如RSA公钥加密</li>\n<li>服务器证书（其中包含服务器放入公钥）</li>\n<li>可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书</li>\n</ul>\n</li>\n<li>客户端回应，包含以下步骤：<ul>\n<li>验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开</li>\n<li>客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验</li>\n</ul>\n</li>\n<li>服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random_1 和 random_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验</li>\n</ul>\n</li>\n</ol>\n<p>在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。</p>\n<p>需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png&quot;\" alt=\"SSL 连接建立过程详解图\"></p>\n<h4 id=\"4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\"><a href=\"#4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\" class=\"headerlink\" title=\"4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\"></a>4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>\n<li>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</li>\n<li>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</li>\n<li>每一层的协议如下：<ul>\n<li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）</li>\n<li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li>\n<li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>\n<li>传输层：TCP、UDP、SPX</li>\n<li>会话层：NFS、SQL、NETBIOS、RPC</li>\n<li>表示层：JPEG、MPEG、ASII</li>\n<li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>\n</ul>\n</li>\n<li>每一层的作用如下：<ul>\n<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li>\n<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>\n<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>\n<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>\n<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>\n<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>\n<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-IP-地址的分类？\"><a href=\"#5-IP-地址的分类？\" class=\"headerlink\" title=\"5. IP 地址的分类？\"></a>5. IP 地址的分类？</h4><p><strong>答</strong>：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—<br>192.168.255.255 为 Internet 上保留地址用于内部。</p>\n<h4 id=\"6-互联网上各类协议的介绍？\"><a href=\"#6-互联网上各类协议的介绍？\" class=\"headerlink\" title=\"6. 互联网上各类协议的介绍？\"></a>6. 互联网上各类协议的介绍？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li>\n<li>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</li>\n<li>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</li>\n<li>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。</li>\n<li>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</li>\n</ol>\n<h4 id=\"7-TCP-和-UDP-的区别？\"><a href=\"#7-TCP-和-UDP-的区别？\" class=\"headerlink\" title=\"7. TCP 和 UDP 的区别？\"></a>7. TCP 和 UDP 的区别？</h4><p><strong>答</strong>：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP 协议</span><br><span class=\"line\">（1） FTP：定义了文件传输协议，使用21端口。</span><br><span class=\"line\">（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</span><br><span class=\"line\">（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</span><br><span class=\"line\">（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</span><br><span class=\"line\">（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</span><br><span class=\"line\">UDP协议</span><br><span class=\"line\">（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</span><br><span class=\"line\">（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</span><br><span class=\"line\">（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。</p>","more":"<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h4 id=\"1-DOCTYPE-作用？有哪些模式，模式怎么区分？\"><a href=\"#1-DOCTYPE-作用？有哪些模式，模式怎么区分？\" class=\"headerlink\" title=\"1. DOCTYPE 作用？有哪些模式，模式怎么区分？\"></a>1. DOCTYPE 作用？有哪些模式，模式怎么区分？</h4><p><strong>答</strong>：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：</p>\n<ol>\n<li>标准模式（standards mode）：浏览器根据标准规约来渲染页面。</li>\n<li>混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。</li>\n</ol>\n<p>如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。</p>\n<p>1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）<br>2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）<br>3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）<br>4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）</p>\n<h4 id=\"2-常用的DOCTYPE声明有几种？\"><a href=\"#2-常用的DOCTYPE声明有几种？\" class=\"headerlink\" title=\"2. 常用的DOCTYPE声明有几种？\"></a>2. 常用的DOCTYPE声明有几种？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>HTML5 <code>&lt;!DOCTYPE html&gt;</code></li>\n<li>HTML 4.01 Strict <code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li>\n<li>HTML 4.01 Transitional</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-什么是-HTML-语义化，为什么要语义化？\"><a href=\"#3-什么是-HTML-语义化，为什么要语义化？\" class=\"headerlink\" title=\"3. 什么是 HTML 语义化，为什么要语义化？\"></a>3. 什么是 HTML 语义化，为什么要语义化？</h4><p><strong>答</strong>：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含</p>\n<ol>\n<li>有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重</li>\n<li>语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构</li>\n<li>方便其他设备的解析</li>\n<li>便于团队开发和维护</li>\n</ol>\n<h4 id=\"4-行内元素、块级元素、空-void-元素都有那些？\"><a href=\"#4-行内元素、块级元素、空-void-元素都有那些？\" class=\"headerlink\" title=\"4. 行内元素、块级元素、空(void)元素都有那些？\"></a>4. 行内元素、块级元素、空(void)元素都有那些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</li>\n<li>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</li>\n<li>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</li>\n</ul>\n<h4 id=\"5-简述一下-src-与-href-的区别？\"><a href=\"#5-简述一下-src-与-href-的区别？\" class=\"headerlink\" title=\"5. 简述一下 src 与 href 的区别？\"></a>5. 简述一下 src 与 href 的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接</li>\n<li>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</li>\n</ul>\n<h4 id=\"6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\"><a href=\"#6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\" class=\"headerlink\" title=\"6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\"></a>6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？</h4><p><strong>答</strong>：Cookie, localStorage 和 sessionStorage.</p>\n<ol>\n<li>Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。</li>\n<li>LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。</li>\n</ol>\n<p>以下为三者之间的区别：</p>\n<table><br>    <thead><br>        <tr><br>            <th>特性</th><br>            <th>Cookie</th><br>            <th>localStorage</th><br>            <th>sessionStorage</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>数据的生命期</td><br>            <td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><br>            <td>除非被清除，否则永久保存</td><br>            <td>仅在当前会话下有效，关闭页面或浏览器后被清除</td><br>        </tr><br>        <tr><br>            <td>存放数据大小</td><br>            <td>4K左右</td><br>            <td colspan=\"2\">一般为5MB</td><br>        </tr><br>        <tr><br>            <td>与服务器端通信</td><br>            <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td><br>            <td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><br>        </tr><br>        <tr><br>            <td>易用性</td><br>            <td>需要程序员自己封装，源生的Cookie接口不友好</td><br>            <td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td><br>        </tr><br>    </tbody><br></table>\n\n<h4 id=\"7-什么是跨域请求？其限制原因有哪些？\"><a href=\"#7-什么是跨域请求？其限制原因有哪些？\" class=\"headerlink\" title=\"7. 什么是跨域请求？其限制原因有哪些？\"></a>7. 什么是跨域请求？其限制原因有哪些？</h4><p><strong>答</strong>：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>\n<p>跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<h4 id=\"8-前端跨域请求解决方案都有哪些？\"><a href=\"#8-前端跨域请求解决方案都有哪些？\" class=\"headerlink\" title=\"8. 前端跨域请求解决方案都有哪些？\"></a>8. 前端跨域请求解决方案都有哪些？</h4><p><strong>答</strong>：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 <a href=\"https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md\" target=\"_blank\" rel=\"noopener\">前端跨域请求解决方案汇总</a> 或者 <a href=\"https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/\" target=\"_blank\" rel=\"noopener\">Joe’s Blog</a>.</p>\n<h4 id=\"9-iframe-的优缺点？\"><a href=\"#9-iframe-的优缺点？\" class=\"headerlink\" title=\"9. iframe 的优缺点？\"></a>9. iframe 的优缺点？</h4><p><strong>答</strong>：</p>\n<p>优点</p>\n<ol>\n<li>程序调入静态页面比较方便</li>\n<li>页面和程序分离</li>\n<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)</li>\n<li>能够原封不动的把嵌入的网页展现出来</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>会产生很多页面，不容易管理</li>\n<li>不容易打印</li>\n<li>浏览器的后退按钮无效</li>\n<li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用<br>iframe会不利于搜索引擎优化</li>\n<li>多数小型的移动设备无法完全显示框架，设备兼容性差</li>\n<li>多框架的页面会增加服务器的http请求，对于大型网站是不可取的</li>\n</ol>\n<h4 id=\"10-iframe-有哪些使用场景？\"><a href=\"#10-iframe-有哪些使用场景？\" class=\"headerlink\" title=\"10. iframe 有哪些使用场景？\"></a>10. iframe 有哪些使用场景？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>沙箱隔离。</li>\n<li>引用第三方内容。</li>\n<li>独立的带有交互的内容，比如幻灯片。</li>\n<li>需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。</li>\n</ol>\n<h4 id=\"11-HTML-的全局属性都有哪些？\"><a href=\"#11-HTML-的全局属性都有哪些？\" class=\"headerlink\" title=\"11. HTML 的全局属性都有哪些？\"></a>11. HTML 的全局属性都有哪些？</h4><p><strong>答</strong>：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。</p>\n<ul>\n<li><code>accesskey</code>:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按<code>alt + shift + a</code>可激活元素</li>\n<li><code>class</code>:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li>\n<li><code>contenteditable</code>: 指定元素内容是否可编辑</li>\n<li><code>contextmenu</code>: 自定义鼠标右键弹出菜单内容</li>\n<li><code>data-*</code>: 为元素增加自定义属性</li>\n<li><code>dir</code>: 设置元素文本方向</li>\n<li><code>draggable</code>: 设置元素是否可拖拽</li>\n<li><code>dropzone</code>: 设置元素拖放类型： copy, move, link</li>\n<li><code>hidden</code>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li>\n<li><code>id</code>: 元素id，文档内唯一</li>\n<li><code>lang</code>: 元素内容的的语言</li>\n<li><code>spellcheck</code>: 是否启动拼写和语法检查</li>\n<li><code>style</code>: 行内css样式</li>\n<li><code>tabindex</code>: 设置元素可以获得焦点，通过tab可以导航</li>\n<li><code>title</code>: 元素相关的建议信息</li>\n<li><code>translate</code>: 元素和子孙节点内容是否需要本地化</li>\n</ul>\n<h4 id=\"12-常见的浏览器内核有哪些？\"><a href=\"#12-常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"12. 常见的浏览器内核有哪些？\"></a>12. 常见的浏览器内核有哪些？</h4><p>浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。</p>\n<ul>\n<li>Trident 为 IE 内核，又称 MSHTML</li>\n<li>Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核</li>\n<li>Webkit 内核：Safari, Chrome 等</li>\n<li>Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支</li>\n<li>Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink</li>\n<li>移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident</li>\n</ul>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h4 id=\"1-ECMAScript-JavaScript-中都有那些数据类型？\"><a href=\"#1-ECMAScript-JavaScript-中都有那些数据类型？\" class=\"headerlink\" title=\"1. ECMAScript/JavaScript 中都有那些数据类型？\"></a>1. ECMAScript/JavaScript 中都有那些数据类型？</h4><p><strong>答</strong>：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.</p>\n<h4 id=\"2-把非数值转化为数值的函数都有哪些？\"><a href=\"#2-把非数值转化为数值的函数都有哪些？\" class=\"headerlink\" title=\"2. 把非数值转化为数值的函数都有哪些？\"></a>2. 把非数值转化为数值的函数都有哪些？</h4><p><strong>答</strong>：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p>\n<h4 id=\"3-JavaScript-中的-new-关键词做了什么？\"><a href=\"#3-JavaScript-中的-new-关键词做了什么？\" class=\"headerlink\" title=\"3. JavaScript 中的 new 关键词做了什么？\"></a>3. JavaScript 中的 new 关键词做了什么？</h4><ul>\n<li><strong>答</strong>：他做了五件事</li>\n</ul>\n<ol>\n<li>他生成了一个新对象。这个对象的类型只是一个普通的对象；</li>\n<li>他将新对象内部、不可访问的原型属性（例如：<code>__proto__</code>）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 <code>prototype</code> 属性）；</li>\n<li>他将 <code>this</code> 变量指向这个新生成的对象；</li>\n<li>他执行构造器函数，对于每个提及到 <code>this</code> 的地方使用新生成的对象执行；</li>\n<li>他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；</li>\n</ol>\n<h4 id=\"4-JavaScript-的六种继承类型？\"><a href=\"#4-JavaScript-的六种继承类型？\" class=\"headerlink\" title=\"4. JavaScript 的六种继承类型？\"></a>4. JavaScript 的六种继承类型？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();</span><br><span class=\"line\">let sub1 = new Sub();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 <code>fun</code> 函数，太多了就会影响性能；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val = val;</span><br><span class=\"line\">    this.fun = function()&#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this, val);   // 核心</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();    // 核心</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 拿到父类对象</span><br><span class=\"line\">let sup = new Super();</span><br><span class=\"line\">// 生孩子</span><br><span class=\"line\">let sub = beget(sup);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getSubObject(obj)&#123;</span><br><span class=\"line\">    // 创建新对象</span><br><span class=\"line\">    let clone = beget(obj); // 核心</span><br><span class=\"line\">    // 增强</span><br><span class=\"line\">    clone.attr1 = 1;</span><br><span class=\"line\">    clone.attr2 = 2;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sub = getSubObject(new Super());</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">Super.prototype.fun2 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proto = beget(Super.prototype); // 核心</span><br><span class=\"line\">proto.constructor = Sub;            // 核心</span><br><span class=\"line\">Sub.prototype = proto;              // 核心</span><br><span class=\"line\">let sub = new Sub();</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-箭头函数的适用规则？\"><a href=\"#5-箭头函数的适用规则？\" class=\"headerlink\" title=\"5. 箭头函数的适用规则？\"></a>5. 箭头函数的适用规则？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=&gt;箭头函数。</p>\n</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=&gt;箭头函数。</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=&gt;箭头函数。</li>\n<li>对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=&gt;函数语法。</li>\n</ul>\n<h4 id=\"6-为什么我们区别-LHS-和-RHS-那么重要？\"><a href=\"#6-为什么我们区别-LHS-和-RHS-那么重要？\" class=\"headerlink\" title=\"6. 为什么我们区别 LHS 和 RHS 那么重要？\"></a>6. 为什么我们区别 LHS 和 RHS 那么重要？</h4><p><strong>答</strong>：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。</p>\n<h4 id=\"7-如何区分声明和表达式？\"><a href=\"#7-如何区分声明和表达式？\" class=\"headerlink\" title=\"7. 如何区分声明和表达式？\"></a>7. 如何区分声明和表达式？</h4><p><strong>答</strong>：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。</p>\n<h4 id=\"8-IIFE-方式与变种？\"><a href=\"#8-IIFE-方式与变种？\" class=\"headerlink\" title=\"8. IIFE 方式与变种？\"></a>8. IIFE 方式与变种？</h4><p><strong>答</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;)()</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;())</span><br><span class=\"line\"><span class=\"comment\">// 3，用于 UMD 项目</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>)</span>&#123;</span><br><span class=\"line\">\tdef( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-请解释如下代码执行的结果？\"><a href=\"#9-请解释如下代码执行的结果？\" class=\"headerlink\" title=\"9. 请解释如下代码执行的结果？\"></a>9. 请解释如下代码执行的结果？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + &#123;&#125;; // &quot;[object Object]&quot;</span><br><span class=\"line\">&#123;&#125; + []; // 0</span><br></pre></td></tr></table></figure>\n<p><strong>答</strong>：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为””因此{}也会被强制转换为一个string：”[object Object]”。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。</p>\n<h4 id=\"10-什么是事件委托？\"><a href=\"#10-什么是事件委托？\" class=\"headerlink\" title=\"10. 什么是事件委托？\"></a>10. 什么是事件委托？</h4><p><strong>答</strong>：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。</p>\n<h4 id=\"11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\"><a href=\"#11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\" class=\"headerlink\" title=\"11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\"></a>11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；</li>\n<li>目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；</li>\n<li>冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>\n</ol>\n<h4 id=\"12-触摸事件都有哪些？\"><a href=\"#12-触摸事件都有哪些？\" class=\"headerlink\" title=\"12. 触摸事件都有哪些？\"></a>12. 触摸事件都有哪些？</h4><p><strong>答</strong>：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件</p>\n<ol>\n<li>touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。</li>\n<li>touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。</li>\n<li>touchend事件：当手指从屏幕上离开的时候触发。</li>\n</ol>\n<h4 id=\"13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\"><a href=\"#13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\" class=\"headerlink\" title=\"13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\"></a>13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。</li>\n<li>event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。<strong>特别说明：IE不支持！</strong></li>\n<li>screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。</li>\n<li>event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。<strong>特别说明：只有IE支持！</strong></li>\n</ol>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h4 id=\"1-什么是盒子模型？\"><a href=\"#1-什么是盒子模型？\" class=\"headerlink\" title=\"1. 什么是盒子模型？\"></a>1. 什么是盒子模型？</h4><p><strong>答</strong>：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p>\n<h4 id=\"2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"><a href=\"#2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\" class=\"headerlink\" title=\"2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"></a>2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？</h4><p><strong>答</strong>：使用 CSS <code>word-break</code> 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS <code>text-overflow</code> 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。</p>\n<h4 id=\"3-什么是-Data-URI？\"><a href=\"#3-什么是-Data-URI？\" class=\"headerlink\" title=\"3. 什么是 Data URI？\"></a>3. 什么是 Data URI？</h4><p><strong>答</strong>：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。</p>\n<h4 id=\"4-Data-URI-的好处和缺点都有哪些？\"><a href=\"#4-Data-URI-的好处和缺点都有哪些？\" class=\"headerlink\" title=\"4. Data URI 的好处和缺点都有哪些？\"></a>4. Data URI 的好处和缺点都有哪些？</h4><p><strong>答</strong>：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：</p>\n<ul>\n<li>当访问外部资源很麻烦或受限时。</li>\n<li>当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。</li>\n<li>当图片的体积太小，占用一个HTTP会话不是很值得时。</li>\n</ul>\n<p>Data URL也有一些不适用的场合：</p>\n<ul>\n<li>Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。</li>\n<li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。</li>\n</ul>\n<h4 id=\"5-内联元素和块级元素的区别？\"><a href=\"#5-内联元素和块级元素的区别？\" class=\"headerlink\" title=\"5. 内联元素和块级元素的区别？\"></a>5. 内联元素和块级元素的区别？</h4><p><strong>答</strong>：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。</p>\n<h4 id=\"6-CSS-Transform-Transition-Animation-属性的区别？\"><a href=\"#6-CSS-Transform-Transition-Animation-属性的区别？\" class=\"headerlink\" title=\"6. CSS Transform / Transition / Animation 属性的区别？\"></a>6. CSS Transform / Transition / Animation 属性的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；</li>\n<li>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；</li>\n<li>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；</li>\n</ul>\n<h4 id=\"7-position-布局方式都有哪些？\"><a href=\"#7-position-布局方式都有哪些？\" class=\"headerlink\" title=\"7. position 布局方式都有哪些？\"></a>7. position 布局方式都有哪些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li><strong>static</strong> - static 是默认值。任意 <code>position: static;</code> 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。</li>\n<li><strong>relative</strong> - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。</li>\n<li><strong>fixed</strong> - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。</li>\n<li><strong>absolute</strong> - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。</li>\n</ul>\n<p><em>记住一个“positioned”元素是指 position 值不是 static 的元素。</em></p>\n<h4 id=\"8-display-的属性都有哪些？\"><a href=\"#8-display-的属性都有哪些？\" class=\"headerlink\" title=\"8. display 的属性都有哪些？\"></a>8. display 的属性都有哪些？</h4><p><strong>答</strong>：块级元素默认值为 block，而行内元素为 inline。</p>\n<ul>\n<li><strong>block</strong> - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。</li>\n<li><strong>inline</strong> - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。</li>\n<li><strong>none</strong> - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。</li>\n</ul>\n<p>其他 display 值，例如 inline-block, list-item, table 和 flex。</p>\n<h2 id=\"Node-软件包管理\"><a href=\"#Node-软件包管理\" class=\"headerlink\" title=\"Node 软件包管理\"></a>Node 软件包管理</h2><h4 id=\"1-简述同步和异步之间的区别？\"><a href=\"#1-简述同步和异步之间的区别？\" class=\"headerlink\" title=\"1. 简述同步和异步之间的区别？\"></a>1. 简述同步和异步之间的区别？</h4><p><strong>答</strong>：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率</p>\n<h4 id=\"2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\"><a href=\"#2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\" class=\"headerlink\" title=\"2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 &quot;d3&quot;: &quot;^3.9.0&quot; 或者 &quot;d3&quot;: &quot;~3.9.0&quot;，请问 “^” 和 “~” 的含义分别是什么？\"></a>2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 <code>&quot;d3&quot;: &quot;^3.9.0&quot;</code> 或者 <code>&quot;d3&quot;: &quot;~3.9.0&quot;</code>，请问 “^” 和 “~” 的含义分别是什么？</h4><p><strong>答</strong>：根据 <a href=\"http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/\" target=\"_blank\" rel=\"noopener\">“npm install –save” No Longer Using Tildes</a> 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。</p>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><h4 id=\"3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"><a href=\"#3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\" class=\"headerlink\" title=\"3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"></a>3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？</h4><p><strong>答</strong>：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inIframe () &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return window.self !== window.top;</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>top 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h4 id=\"1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\"><a href=\"#1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\" class=\"headerlink\" title=\"1. HTTP/0.9 只有一个命令 GET, HTTP/1.0 引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\"></a>1. HTTP/0.9 只有一个命令 <code>GET</code>, HTTP/1.0 引入了 <code>POST</code> 命令和 <code>HEAD</code> 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？</h4><p><strong>答</strong>：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是</p>\n<ol>\n<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*‘来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</li>\n<li>HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li>\n<li>GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法</li>\n<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>\n<li>PUT：向指定资源位置上传其最新内容。</li>\n<li>DELETE：请求服务器删除Request-URI所标识的资源。</li>\n<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>\n<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</li>\n</ol>\n<h4 id=\"2-HTTP-状态码的主要类型有哪些？\"><a href=\"#2-HTTP-状态码的主要类型有哪些？\" class=\"headerlink\" title=\"2. HTTP 状态码的主要类型有哪些？\"></a>2. HTTP 状态码的主要类型有哪些？</h4><p><strong>答</strong>：状态代码的第一个数字代表当前响应的类型，主要为五类</p>\n<ol>\n<li>1xx消息——请求已被服务器接收，继续处理</li>\n<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>\n<li>3xx重定向——需要后续操作才能完成这一请求</li>\n<li>4xx请求错误——请求含有词法错误或者无法被执行</li>\n<li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li>\n</ol>\n<p>详细情况见 <a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" rel=\"noopener\">维基百科</a>。</p>\n<h4 id=\"3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"><a href=\"#3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\" class=\"headerlink\" title=\"3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"></a>3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><p><strong>答</strong>：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>\n<h4 id=\"4-HTTPS-建立连接的过程？\"><a href=\"#4-HTTPS-建立连接的过程？\" class=\"headerlink\" title=\"4. HTTPS 建立连接的过程？\"></a>4. HTTPS 建立连接的过程？</h4><p><strong>答</strong>：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。</p>\n<ol>\n<li>客户端发出握手请求 (Client Hello)，包含以下信息：<ul>\n<li>支持的协议版本，比如TLS 1.0</li>\n<li>一个客户端生成的随机数(random_1)，这个随机数既需要客户端保存又需要发送给服务器</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回复 (Server Hello)，包含以下信息：<ul>\n<li>确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信</li>\n<li>一个服务器生成的随机数 (random_2)</li>\n<li>确认使用的加密方法，比如RSA公钥加密</li>\n<li>服务器证书（其中包含服务器放入公钥）</li>\n<li>可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书</li>\n</ul>\n</li>\n<li>客户端回应，包含以下步骤：<ul>\n<li>验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开</li>\n<li>客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验</li>\n</ul>\n</li>\n<li>服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random_1 和 random_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验</li>\n</ul>\n</li>\n</ol>\n<p>在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。</p>\n<p>需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png&quot;\" alt=\"SSL 连接建立过程详解图\"></p>\n<h4 id=\"4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\"><a href=\"#4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\" class=\"headerlink\" title=\"4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\"></a>4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>\n<li>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</li>\n<li>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</li>\n<li>每一层的协议如下：<ul>\n<li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）</li>\n<li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li>\n<li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>\n<li>传输层：TCP、UDP、SPX</li>\n<li>会话层：NFS、SQL、NETBIOS、RPC</li>\n<li>表示层：JPEG、MPEG、ASII</li>\n<li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>\n</ul>\n</li>\n<li>每一层的作用如下：<ul>\n<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li>\n<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>\n<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>\n<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>\n<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>\n<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>\n<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-IP-地址的分类？\"><a href=\"#5-IP-地址的分类？\" class=\"headerlink\" title=\"5. IP 地址的分类？\"></a>5. IP 地址的分类？</h4><p><strong>答</strong>：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—<br>192.168.255.255 为 Internet 上保留地址用于内部。</p>\n<h4 id=\"6-互联网上各类协议的介绍？\"><a href=\"#6-互联网上各类协议的介绍？\" class=\"headerlink\" title=\"6. 互联网上各类协议的介绍？\"></a>6. 互联网上各类协议的介绍？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li>\n<li>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</li>\n<li>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</li>\n<li>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。</li>\n<li>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</li>\n</ol>\n<h4 id=\"7-TCP-和-UDP-的区别？\"><a href=\"#7-TCP-和-UDP-的区别？\" class=\"headerlink\" title=\"7. TCP 和 UDP 的区别？\"></a>7. TCP 和 UDP 的区别？</h4><p><strong>答</strong>：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP 协议</span><br><span class=\"line\">（1） FTP：定义了文件传输协议，使用21端口。</span><br><span class=\"line\">（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</span><br><span class=\"line\">（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</span><br><span class=\"line\">（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</span><br><span class=\"line\">（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</span><br><span class=\"line\">UDP协议</span><br><span class=\"line\">（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</span><br><span class=\"line\">（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</span><br><span class=\"line\">（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</span><br></pre></td></tr></table></figure>"},{"title":"http学习总结","date":"2018-04-19T05:30:30.000Z","_content":"\n> 做一下http总结吧！！！\n\n<!-- more -->\n\n # HTTP简介\n\nHTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本----HTTP 1.1。\n\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\n\nHTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：\n\n- 对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。\n- 在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。\n- Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。\n- 管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。\n\n<br>\n<br><br>\n\n一次http链接的生命周期，基本包括请求和响应。\n\n# 请求\n\n一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。\n\n## 请求行\n\n请求行分为三个部分：请求方法、请求地址和协议版本.\n\n### 请求方法\n\n方法      | 描述\n------- | ---------------------------------------------------\nGET     | 从服务端获取资源\nPOST    | 用来传输实体的主题\nHEAD    | 获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等\nOPTIONS | 询问支持的方法\nPUT     | 传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）\nDELETE  | 按请求URI删除指定文件\nTRACE   | 追踪路径，易引发XST（跨站攻击），不常用\n\n### 请求地址\n\nURL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。\n\n说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。\n\n### 协议版本\n\n常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：\n\n- 多路复用<br>\n  2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。\n- 头部压缩<br>\n  当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。\n- 随时复位<br>\n  HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。\n- 服务器端推流: Server Push<br>\n  客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。\n- 优先权和依赖<br>\n  每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。\n\n## 请求头部\n\n请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段\n\n### 通用请求首部\n\n首部                | 描述\n----------------- | ---------------------------------------------------------------------------\nConnection        | 允许客户端和服务器指定与请求/响应连接有关的选项\nDate              | 提供日期和时间标志，说明报文是什么时间创建的\nMIME-Version      | 给出了发送短使用的 MINE 版本\nTrailer           | 如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合\nTransfer-Encoding | 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式\nUpdate            | 给出了发送端可能想要\"升级\"使用的新版本或协议\nVia               | 显示报文经过的中间节点（代理、网关）\n\n### 请求首部字段\n\n首部字段名               | 说明\n------------------- | --------------------------------\nAccept              | 用户代理可处理的媒体类型\nAccept-Charset      | 优先的字符集\nAccept-Encoding     | 优先的内容编码\nAccept-Language     | 有限的语言\nAuthorization       | Web认证信息\nExpect              | 期待副武器的特定行为\nfrom                | 用户的电子邮件地址\nHost                | 请求资源所在服务器\nIf-Match            | 比较实体标记ETag\nIf-Modified-Sincce  | 比较资源的更新时间\nIf-None-Match       | 比较实体标记与If-Match相反\nIf-Range            | 资源委更新时发送实体Byte的范围请求\nIf-Unmodified-Since | 比较资源的更新时间 与 If-Modified-Sincce相反\nMax-Forwards        | 最大传输逐跳数\nProxy-Authorization | 代理服务器要求客户端的认证消息\nRange               | 实体的字节范围请求\nReferer             | 队请求中URI的原始获取方法\nTE                  | 传输编码的优先级\nUser-Agent          | HTTP客户端程序的信息\n\n> 从今以后请称呼在下位为前端打字员，谢谢\n\n### 实体首部\n\n首部               | 描述\n---------------- | -----------------------------------------\nAllow            | 列出可以对此事提执行的请求方法\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式\nContent-Language | 理解主体时最适宜使用的自然语言\nContent-Length   | 主体的长度或尺寸\nContent-Locaton  | 资源实际所处的位置\nContent-MD5      | 主体的 MD5 校验和\nContent-Range    | 在整个资源中此实体表示的字节范围\nContent-Type     | 在这个主体的对象类型\nETag             | 与此实体相关的实体标记\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间\nLast-Modified    | 这个实体最后一次被修改的日期和时间\n\n## 空行\n\n即使第四部分的请求数据为空，也必须有空行。\n\n## 请求数据\n\n请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n# 响应\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n## 状态行\n\n状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n\n说一下状态码（复制粘贴的）\n\n状态码 | 含义\n--- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n100 | 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。\n101 | 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。\n102 | 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n200 | 请求已成功，请求所希望的响应头或数据体将随此响应返回。\n201 | 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。\n202 | 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。\n203 | 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。\n204 | 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n205 | 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。\n206 | 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。\n207 | 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\n300 | 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。\n301 | 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。\n302 | 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。\n303 | 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。\n304 | 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。\n305 | 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。\n306 | 在最新版的规范中，306状态码已经不再被使用。\n307 | 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n400 | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。\n401 | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。\n402 | 该状态码是为了将来可能的需求而预留的。\n403 | 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。\n404 | 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。\n405 | 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。\n406 | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。\n407 | 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。\n408 | 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。\n409 | 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。\n410 | 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。\n411 | 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。\n412 | 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。\n413 | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。\n414 | 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI \"黑洞\"，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。\n415 | 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。\n416 | 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。\n417 | 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。\n421 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）\n424 | 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）\n425 | 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。\n426 | 客户端应当切换到TLS/1.0。（RFC 2817）\n449 | 由微软扩展，代表请求应当在执行完适当的操作后进行重试。\n500 | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。\n501 | 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n502 | 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n503 | 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。\n504 | 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误\n505 | 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。\n506 | 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。\n507 | 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)\n509 | 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。\n510 | 获取资源所需要的策略并没有没满足。（RFC 2774）\n\n## 响应报头\n\n### 响应首部\n\n首部                 | 描述\n------------------ | ---------------------------------------------------------------------\nAge                | （从最初创建开始)响应持续时间。\nPublic             | 服务器为其资源支持的请求方法列表。\nRetry-After        | 如果资源不可用的话，在此日期或时间重试。\nServer             | 服务器应用程序软件的名称和版本。\nTitle              | 对 HTML 文档来说，就是 HTML 文档的源端给出的标题。\nWarning            | 比原因短语更详细一些的警告报文。\nAccept-Ranges      | 对此资源来说，服务器可接受的范围类型。\nVary               | 服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。\nProxy-Authenticate | 来自代理的对客户端的质询列表。\nSet-Cookie         | 不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。\nSet-Cookie2        | 与 Set-Cookie 类似，PFC 2965 Cookie定义。\nWWW-Authenticate   | 来自服务器对客户端的质询列表。\n\n\n\n# 实体首部\n\n首部               | 描述\n---------------- | ------------------------------------------\nAllow            | 列出可以对此事提执行的请求方法。\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式。\nContent-Language | 理解主体时最适宜使用的自然语言。\nContent-Length   | 主体的长度或尺寸。\nContent-Locaton  | 资源实际所处的位置。\nContent-MD5      | 主体的 MD5 校验和。\nContent-Range    | 在整个资源中此实体表示的字节范围。\nContent-Type     | 在这个主体的对象类型。\nETag             | 与此实体相关的实体标记。\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间。\nLast-Modified    | 这个实体最后一次被修改的日期和时间。\n\n[参考链接](http://tool.oschina.net/commons?type=5)\n","source":"_posts/网络-http.md","raw":"---\ntitle: http学习总结\ndate: 2018-04-19T13:30:30.000Z\ntags: 网络\ncategories: 学习\n---\n\n> 做一下http总结吧！！！\n\n<!-- more -->\n\n # HTTP简介\n\nHTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本----HTTP 1.1。\n\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\n\nHTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：\n\n- 对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。\n- 在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。\n- Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。\n- 管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。\n\n<br>\n<br><br>\n\n一次http链接的生命周期，基本包括请求和响应。\n\n# 请求\n\n一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。\n\n## 请求行\n\n请求行分为三个部分：请求方法、请求地址和协议版本.\n\n### 请求方法\n\n方法      | 描述\n------- | ---------------------------------------------------\nGET     | 从服务端获取资源\nPOST    | 用来传输实体的主题\nHEAD    | 获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等\nOPTIONS | 询问支持的方法\nPUT     | 传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）\nDELETE  | 按请求URI删除指定文件\nTRACE   | 追踪路径，易引发XST（跨站攻击），不常用\n\n### 请求地址\n\nURL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。\n\n说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。\n\n### 协议版本\n\n常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：\n\n- 多路复用<br>\n  2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。\n- 头部压缩<br>\n  当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。\n- 随时复位<br>\n  HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。\n- 服务器端推流: Server Push<br>\n  客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。\n- 优先权和依赖<br>\n  每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。\n\n## 请求头部\n\n请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段\n\n### 通用请求首部\n\n首部                | 描述\n----------------- | ---------------------------------------------------------------------------\nConnection        | 允许客户端和服务器指定与请求/响应连接有关的选项\nDate              | 提供日期和时间标志，说明报文是什么时间创建的\nMIME-Version      | 给出了发送短使用的 MINE 版本\nTrailer           | 如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合\nTransfer-Encoding | 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式\nUpdate            | 给出了发送端可能想要\"升级\"使用的新版本或协议\nVia               | 显示报文经过的中间节点（代理、网关）\n\n### 请求首部字段\n\n首部字段名               | 说明\n------------------- | --------------------------------\nAccept              | 用户代理可处理的媒体类型\nAccept-Charset      | 优先的字符集\nAccept-Encoding     | 优先的内容编码\nAccept-Language     | 有限的语言\nAuthorization       | Web认证信息\nExpect              | 期待副武器的特定行为\nfrom                | 用户的电子邮件地址\nHost                | 请求资源所在服务器\nIf-Match            | 比较实体标记ETag\nIf-Modified-Sincce  | 比较资源的更新时间\nIf-None-Match       | 比较实体标记与If-Match相反\nIf-Range            | 资源委更新时发送实体Byte的范围请求\nIf-Unmodified-Since | 比较资源的更新时间 与 If-Modified-Sincce相反\nMax-Forwards        | 最大传输逐跳数\nProxy-Authorization | 代理服务器要求客户端的认证消息\nRange               | 实体的字节范围请求\nReferer             | 队请求中URI的原始获取方法\nTE                  | 传输编码的优先级\nUser-Agent          | HTTP客户端程序的信息\n\n> 从今以后请称呼在下位为前端打字员，谢谢\n\n### 实体首部\n\n首部               | 描述\n---------------- | -----------------------------------------\nAllow            | 列出可以对此事提执行的请求方法\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式\nContent-Language | 理解主体时最适宜使用的自然语言\nContent-Length   | 主体的长度或尺寸\nContent-Locaton  | 资源实际所处的位置\nContent-MD5      | 主体的 MD5 校验和\nContent-Range    | 在整个资源中此实体表示的字节范围\nContent-Type     | 在这个主体的对象类型\nETag             | 与此实体相关的实体标记\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间\nLast-Modified    | 这个实体最后一次被修改的日期和时间\n\n## 空行\n\n即使第四部分的请求数据为空，也必须有空行。\n\n## 请求数据\n\n请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n# 响应\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n## 状态行\n\n状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n\n说一下状态码（复制粘贴的）\n\n状态码 | 含义\n--- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n100 | 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。\n101 | 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。\n102 | 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n200 | 请求已成功，请求所希望的响应头或数据体将随此响应返回。\n201 | 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。\n202 | 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。\n203 | 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。\n204 | 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n205 | 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。\n206 | 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。\n207 | 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\n300 | 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。\n301 | 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。\n302 | 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。\n303 | 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。\n304 | 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。\n305 | 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。\n306 | 在最新版的规范中，306状态码已经不再被使用。\n307 | 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n400 | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。\n401 | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。\n402 | 该状态码是为了将来可能的需求而预留的。\n403 | 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。\n404 | 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。\n405 | 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。\n406 | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。\n407 | 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。\n408 | 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。\n409 | 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。\n410 | 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。\n411 | 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。\n412 | 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。\n413 | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。\n414 | 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI \"黑洞\"，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。\n415 | 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。\n416 | 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。\n417 | 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。\n421 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）\n424 | 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）\n425 | 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。\n426 | 客户端应当切换到TLS/1.0。（RFC 2817）\n449 | 由微软扩展，代表请求应当在执行完适当的操作后进行重试。\n500 | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。\n501 | 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n502 | 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n503 | 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。\n504 | 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误\n505 | 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。\n506 | 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。\n507 | 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)\n509 | 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。\n510 | 获取资源所需要的策略并没有没满足。（RFC 2774）\n\n## 响应报头\n\n### 响应首部\n\n首部                 | 描述\n------------------ | ---------------------------------------------------------------------\nAge                | （从最初创建开始)响应持续时间。\nPublic             | 服务器为其资源支持的请求方法列表。\nRetry-After        | 如果资源不可用的话，在此日期或时间重试。\nServer             | 服务器应用程序软件的名称和版本。\nTitle              | 对 HTML 文档来说，就是 HTML 文档的源端给出的标题。\nWarning            | 比原因短语更详细一些的警告报文。\nAccept-Ranges      | 对此资源来说，服务器可接受的范围类型。\nVary               | 服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。\nProxy-Authenticate | 来自代理的对客户端的质询列表。\nSet-Cookie         | 不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。\nSet-Cookie2        | 与 Set-Cookie 类似，PFC 2965 Cookie定义。\nWWW-Authenticate   | 来自服务器对客户端的质询列表。\n\n\n\n# 实体首部\n\n首部               | 描述\n---------------- | ------------------------------------------\nAllow            | 列出可以对此事提执行的请求方法。\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式。\nContent-Language | 理解主体时最适宜使用的自然语言。\nContent-Length   | 主体的长度或尺寸。\nContent-Locaton  | 资源实际所处的位置。\nContent-MD5      | 主体的 MD5 校验和。\nContent-Range    | 在整个资源中此实体表示的字节范围。\nContent-Type     | 在这个主体的对象类型。\nETag             | 与此实体相关的实体标记。\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间。\nLast-Modified    | 这个实体最后一次被修改的日期和时间。\n\n[参考链接](http://tool.oschina.net/commons?type=5)\n","slug":"网络-http","published":1,"updated":"2019-09-17T02:40:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0n9rwcf0032kwfyqjz8msdg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>做一下http总结吧！！！</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h1><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本—-HTTP 1.1。</p>\n<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>\n<p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：</p>\n<ul>\n<li>对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。</li>\n<li>在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。</li>\n<li>Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。</li>\n<li>管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。</li>\n</ul>\n<p><br><br><br><br></p>\n<p>一次http链接的生命周期，基本包括请求和响应。</p>\n<h1 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h1><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。</p>\n<h2 id=\"请求行\"><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h2><p>请求行分为三个部分：请求方法、请求地址和协议版本.</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>从服务端获取资源</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>用来传输实体的主题</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>询问支持的方法</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>按请求URI删除指定文件</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>追踪路径，易引发XST（跨站攻击），不常用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求地址\"><a href=\"#请求地址\" class=\"headerlink\" title=\"请求地址\"></a>请求地址</h3><p>URL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。</p>\n<p>说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。</p>\n<h3 id=\"协议版本\"><a href=\"#协议版本\" class=\"headerlink\" title=\"协议版本\"></a>协议版本</h3><p>常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：</p>\n<ul>\n<li>多路复用<br><br>2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</li>\n<li>头部压缩<br><br>当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。</li>\n<li>随时复位<br><br>HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。</li>\n<li>服务器端推流: Server Push<br><br>客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。</li>\n<li>优先权和依赖<br><br>每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</li>\n</ul>\n<h2 id=\"请求头部\"><a href=\"#请求头部\" class=\"headerlink\" title=\"请求头部\"></a>请求头部</h2><p>请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段</p>\n<h3 id=\"通用请求首部\"><a href=\"#通用请求首部\" class=\"headerlink\" title=\"通用请求首部\"></a>通用请求首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connection</td>\n<td>允许客户端和服务器指定与请求/响应连接有关的选项</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>提供日期和时间标志，说明报文是什么时间创建的</td>\n</tr>\n<tr>\n<td>MIME-Version</td>\n<td>给出了发送短使用的 MINE 版本</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>\n</tr>\n<tr>\n<td>Update</td>\n<td>给出了发送端可能想要”升级”使用的新版本或协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>显示报文经过的中间节点（代理、网关）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>有限的语言</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待副武器的特定行为</td>\n</tr>\n<tr>\n<td>from</td>\n<td>用户的电子邮件地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记ETag</td>\n</tr>\n<tr>\n<td>If-Modified-Sincce</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记与If-Match相反</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源委更新时发送实体Byte的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间 与 If-Modified-Sincce相反</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证消息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>队请求中URI的原始获取方法</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP客户端程序的信息</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>从今以后请称呼在下位为前端打字员，谢谢</p>\n</blockquote>\n<h3 id=\"实体首部\"><a href=\"#实体首部\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a>空行</h2><p>即使第四部分的请求数据为空，也必须有空行。</p>\n<h2 id=\"请求数据\"><a href=\"#请求数据\" class=\"headerlink\" title=\"请求数据\"></a>请求数据</h2><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h1 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h1><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<h2 id=\"状态行\"><a href=\"#状态行\" class=\"headerlink\" title=\"状态行\"></a>状态行</h2><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>\n<p>说一下状态码（复制粘贴的）</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>\n</tr>\n<tr>\n<td>101</td>\n<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>\n</tr>\n<tr>\n<td>102</td>\n<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>\n</tr>\n<tr>\n<td>200</td>\n<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>\n</tr>\n<tr>\n<td>201</td>\n<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>\n</tr>\n<tr>\n<td>202</td>\n<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>\n</tr>\n<tr>\n<td>205</td>\n<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>\n</tr>\n<tr>\n<td>206</td>\n<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>\n</tr>\n<tr>\n<td>207</td>\n<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>\n</tr>\n<tr>\n<td>300</td>\n<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>\n</tr>\n<tr>\n<td>306</td>\n<td>在最新版的规范中，306状态码已经不再被使用。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>\n</tr>\n<tr>\n<td>400</td>\n<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>402</td>\n<td>该状态码是为了将来可能的需求而预留的。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>\n</tr>\n<tr>\n<td>409</td>\n<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>\n</tr>\n<tr>\n<td>410</td>\n<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>\n</tr>\n<tr>\n<td>411</td>\n<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>\n</tr>\n<tr>\n<td>421</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>424</td>\n<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>425</td>\n<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>\n</tr>\n<tr>\n<td>426</td>\n<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>\n</tr>\n<tr>\n<td>449</td>\n<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>\n</tr>\n<tr>\n<td>500</td>\n<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>\n</tr>\n<tr>\n<td>505</td>\n<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>\n</tr>\n<tr>\n<td>506</td>\n<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>\n</tr>\n<tr>\n<td>507</td>\n<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>\n</tr>\n<tr>\n<td>509</td>\n<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>\n</tr>\n<tr>\n<td>510</td>\n<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"响应报头\"><a href=\"#响应报头\" class=\"headerlink\" title=\"响应报头\"></a>响应报头</h2><h3 id=\"响应首部\"><a href=\"#响应首部\" class=\"headerlink\" title=\"响应首部\"></a>响应首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>（从最初创建开始)响应持续时间。</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>服务器为其资源支持的请求方法列表。</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果资源不可用的话，在此日期或时间重试。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器应用程序软件的名称和版本。</td>\n</tr>\n<tr>\n<td>Title</td>\n<td>对 HTML 文档来说，就是 HTML 文档的源端给出的标题。</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>比原因短语更详细一些的警告报文。</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>对此资源来说，服务器可接受的范围类型。</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>来自代理的对客户端的质询列表。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。</td>\n</tr>\n<tr>\n<td>Set-Cookie2</td>\n<td>与 Set-Cookie 类似，PFC 2965 Cookie定义。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>来自服务器对客户端的质询列表。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"实体首部-1\"><a href=\"#实体首部-1\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h1><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式。</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸。</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置。</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和。</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型。</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间。</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间。</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://tool.oschina.net/commons?type=5\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>做一下http总结吧！！！</p>\n</blockquote>","more":"<h1 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h1><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本—-HTTP 1.1。</p>\n<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>\n<p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：</p>\n<ul>\n<li>对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。</li>\n<li>在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。</li>\n<li>Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。</li>\n<li>管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。</li>\n</ul>\n<p><br><br><br><br></p>\n<p>一次http链接的生命周期，基本包括请求和响应。</p>\n<h1 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h1><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。</p>\n<h2 id=\"请求行\"><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h2><p>请求行分为三个部分：请求方法、请求地址和协议版本.</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>从服务端获取资源</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>用来传输实体的主题</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>询问支持的方法</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>按请求URI删除指定文件</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>追踪路径，易引发XST（跨站攻击），不常用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求地址\"><a href=\"#请求地址\" class=\"headerlink\" title=\"请求地址\"></a>请求地址</h3><p>URL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。</p>\n<p>说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。</p>\n<h3 id=\"协议版本\"><a href=\"#协议版本\" class=\"headerlink\" title=\"协议版本\"></a>协议版本</h3><p>常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：</p>\n<ul>\n<li>多路复用<br><br>2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</li>\n<li>头部压缩<br><br>当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。</li>\n<li>随时复位<br><br>HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。</li>\n<li>服务器端推流: Server Push<br><br>客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。</li>\n<li>优先权和依赖<br><br>每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</li>\n</ul>\n<h2 id=\"请求头部\"><a href=\"#请求头部\" class=\"headerlink\" title=\"请求头部\"></a>请求头部</h2><p>请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段</p>\n<h3 id=\"通用请求首部\"><a href=\"#通用请求首部\" class=\"headerlink\" title=\"通用请求首部\"></a>通用请求首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connection</td>\n<td>允许客户端和服务器指定与请求/响应连接有关的选项</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>提供日期和时间标志，说明报文是什么时间创建的</td>\n</tr>\n<tr>\n<td>MIME-Version</td>\n<td>给出了发送短使用的 MINE 版本</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>\n</tr>\n<tr>\n<td>Update</td>\n<td>给出了发送端可能想要”升级”使用的新版本或协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>显示报文经过的中间节点（代理、网关）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>有限的语言</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待副武器的特定行为</td>\n</tr>\n<tr>\n<td>from</td>\n<td>用户的电子邮件地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记ETag</td>\n</tr>\n<tr>\n<td>If-Modified-Sincce</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记与If-Match相反</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源委更新时发送实体Byte的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间 与 If-Modified-Sincce相反</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证消息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>队请求中URI的原始获取方法</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP客户端程序的信息</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>从今以后请称呼在下位为前端打字员，谢谢</p>\n</blockquote>\n<h3 id=\"实体首部\"><a href=\"#实体首部\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a>空行</h2><p>即使第四部分的请求数据为空，也必须有空行。</p>\n<h2 id=\"请求数据\"><a href=\"#请求数据\" class=\"headerlink\" title=\"请求数据\"></a>请求数据</h2><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h1 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h1><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<h2 id=\"状态行\"><a href=\"#状态行\" class=\"headerlink\" title=\"状态行\"></a>状态行</h2><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>\n<p>说一下状态码（复制粘贴的）</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>\n</tr>\n<tr>\n<td>101</td>\n<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>\n</tr>\n<tr>\n<td>102</td>\n<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>\n</tr>\n<tr>\n<td>200</td>\n<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>\n</tr>\n<tr>\n<td>201</td>\n<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>\n</tr>\n<tr>\n<td>202</td>\n<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>\n</tr>\n<tr>\n<td>205</td>\n<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>\n</tr>\n<tr>\n<td>206</td>\n<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>\n</tr>\n<tr>\n<td>207</td>\n<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>\n</tr>\n<tr>\n<td>300</td>\n<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>\n</tr>\n<tr>\n<td>306</td>\n<td>在最新版的规范中，306状态码已经不再被使用。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>\n</tr>\n<tr>\n<td>400</td>\n<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>402</td>\n<td>该状态码是为了将来可能的需求而预留的。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>\n</tr>\n<tr>\n<td>409</td>\n<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>\n</tr>\n<tr>\n<td>410</td>\n<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>\n</tr>\n<tr>\n<td>411</td>\n<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>\n</tr>\n<tr>\n<td>421</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>424</td>\n<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>425</td>\n<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>\n</tr>\n<tr>\n<td>426</td>\n<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>\n</tr>\n<tr>\n<td>449</td>\n<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>\n</tr>\n<tr>\n<td>500</td>\n<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>\n</tr>\n<tr>\n<td>505</td>\n<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>\n</tr>\n<tr>\n<td>506</td>\n<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>\n</tr>\n<tr>\n<td>507</td>\n<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>\n</tr>\n<tr>\n<td>509</td>\n<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>\n</tr>\n<tr>\n<td>510</td>\n<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"响应报头\"><a href=\"#响应报头\" class=\"headerlink\" title=\"响应报头\"></a>响应报头</h2><h3 id=\"响应首部\"><a href=\"#响应首部\" class=\"headerlink\" title=\"响应首部\"></a>响应首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>（从最初创建开始)响应持续时间。</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>服务器为其资源支持的请求方法列表。</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果资源不可用的话，在此日期或时间重试。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器应用程序软件的名称和版本。</td>\n</tr>\n<tr>\n<td>Title</td>\n<td>对 HTML 文档来说，就是 HTML 文档的源端给出的标题。</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>比原因短语更详细一些的警告报文。</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>对此资源来说，服务器可接受的范围类型。</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>来自代理的对客户端的质询列表。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。</td>\n</tr>\n<tr>\n<td>Set-Cookie2</td>\n<td>与 Set-Cookie 类似，PFC 2965 Cookie定义。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>来自服务器对客户端的质询列表。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"实体首部-1\"><a href=\"#实体首部-1\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h1><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式。</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸。</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置。</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和。</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型。</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间。</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间。</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://tool.oschina.net/commons?type=5\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck0n9rv7l0007kwfyz2iqniri","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv7z000fkwfy412dm1f1"},{"post_id":"ck0n9rv730000kwfyydbgd6ht","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv83000kkwfy528wv48x"},{"post_id":"ck0n9rv7n0008kwfy4q12hie3","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv89000nkwfyx8ws7xep"},{"post_id":"ck0n9rv7c0002kwfy3bq2ae5b","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8c000rkwfy1wemqc5x"},{"post_id":"ck0n9rv7x000ekwfy06qshqjq","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8f000ukwfyxf0u3fvt"},{"post_id":"ck0n9rv7k0006kwfyl77u00w3","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8g000xkwfyygzlb7dg"},{"post_id":"ck0n9rv85000mkwfy9xtm2ltt","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8i0010kwfy4eqlqr6x"},{"post_id":"ck0n9rv8b000qkwfyjnsepwuw","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8k0013kwfycxu51ajn"},{"post_id":"ck0n9rv8e000tkwfyx35q7bh8","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8l0016kwfyo5xc5y8z"},{"post_id":"ck0n9rv8f000wkwfysdwtwy1y","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8o0019kwfyo97eu5xp"},{"post_id":"ck0n9rv8h000zkwfyci1b0jj3","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8s001dkwfyrs1q3doy"},{"post_id":"ck0n9rv8i0012kwfyekqox3ci","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv8v001gkwfy3qrua6nd"},{"post_id":"ck0n9rv8u001fkwfycb7ttcil","category_id":"ck0n9rv8q001bkwfyfp7tkpmv","_id":"ck0n9rv8z001okwfydi19majf"},{"post_id":"ck0n9rv8k0015kwfyew129s4p","category_id":"ck0n9rv8q001bkwfyfp7tkpmv","_id":"ck0n9rv92001rkwfyxehb4tli"},{"post_id":"ck0n9rv8r001ckwfyinjmkllb","category_id":"ck0n9rv8q001bkwfyfp7tkpmv","_id":"ck0n9rv94001ukwfyxl1jat3r"},{"post_id":"ck0n9rv90001qkwfyns911maf","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rv97001ykwfyx9r0o2vh"},{"post_id":"ck0n9rw8y002ckwfyuqa0m4h7","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rw95002ikwfyd4gw52y0"},{"post_id":"ck0n9rw8z002dkwfyfwfuz72v","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rw96002kkwfy2evidz9t"},{"post_id":"ck0n9rw93002fkwfygno4bufd","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rw99002okwfy6zq4vcej"},{"post_id":"ck0n9rw94002hkwfyk00qbzza","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rw9b002rkwfyekeftri2"},{"post_id":"ck0n9rw96002jkwfyp0wfmfwx","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rw9c002ukwfyh3pkuhlv"},{"post_id":"ck0n9rw98002mkwfy5yllydfy","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rw9d002wkwfy29yy59nb"},{"post_id":"ck0n9rw9b002tkwfyfer5t7ec","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rw9e002zkwfyff5fhd25"},{"post_id":"ck0n9rwcd0031kwfyyvhqtm65","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rwci0035kwfyxe1blerh"},{"post_id":"ck0n9rwcf0032kwfyqjz8msdg","category_id":"ck0n9rv7h0004kwfyiaykw1le","_id":"ck0n9rwci0036kwfyutq8nenk"}],"PostTag":[{"post_id":"ck0n9rv7l0007kwfyz2iqniri","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rv7u000bkwfyz2ddjdei"},{"post_id":"ck0n9rv730000kwfyydbgd6ht","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rv7x000dkwfyurors9lp"},{"post_id":"ck0n9rv7n0008kwfy4q12hie3","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rv81000ikwfyw53cs6v1"},{"post_id":"ck0n9rv7c0002kwfy3bq2ae5b","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rv85000lkwfye5ixs52d"},{"post_id":"ck0n9rv7x000ekwfy06qshqjq","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rv8a000pkwfyo4409jhe"},{"post_id":"ck0n9rv7k0006kwfyl77u00w3","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rv8e000skwfyrt1htaq5"},{"post_id":"ck0n9rv7v000ckwfy1kcpc4u3","tag_id":"ck0n9rv89000okwfy8owc0tir","_id":"ck0n9rv8g000ykwfyhu6ot1ea"},{"post_id":"ck0n9rv81000jkwfy6oz6y23j","tag_id":"ck0n9rv8f000vkwfydlkmd6ay","_id":"ck0n9rv8k0014kwfy5bhn8jew"},{"post_id":"ck0n9rv85000mkwfy9xtm2ltt","tag_id":"ck0n9rv8i0011kwfy1z7q7nc6","_id":"ck0n9rv8q001akwfymvi6jet4"},{"post_id":"ck0n9rv8b000qkwfyjnsepwuw","tag_id":"ck0n9rv8i0011kwfy1z7q7nc6","_id":"ck0n9rv8v001hkwfyfeatnbix"},{"post_id":"ck0n9rv8v001ikwfyby5xydvv","tag_id":"ck0n9rv89000okwfy8owc0tir","_id":"ck0n9rv8y001mkwfy0lmluoc4"},{"post_id":"ck0n9rv8e000tkwfyx35q7bh8","tag_id":"ck0n9rv8t001ekwfy0wpeg4wv","_id":"ck0n9rv90001pkwfypucc2be1"},{"post_id":"ck0n9rv8y001nkwfyaomroyk5","tag_id":"ck0n9rv89000okwfy8owc0tir","_id":"ck0n9rv93001tkwfyrcivb57o"},{"post_id":"ck0n9rv8f000wkwfysdwtwy1y","tag_id":"ck0n9rv8t001ekwfy0wpeg4wv","_id":"ck0n9rv95001vkwfyrr12ryo8"},{"post_id":"ck0n9rv8h000zkwfyci1b0jj3","tag_id":"ck0n9rv8t001ekwfy0wpeg4wv","_id":"ck0n9rv97001xkwfyjhwtfj9u"},{"post_id":"ck0n9rv8i0012kwfyekqox3ci","tag_id":"ck0n9rv8t001ekwfy0wpeg4wv","_id":"ck0n9rv980020kwfy9w4mn85c"},{"post_id":"ck0n9rv8k0015kwfyew129s4p","tag_id":"ck0n9rv97001zkwfylrrku270","_id":"ck0n9rv990022kwfynns51lo4"},{"post_id":"ck0n9rv8m0018kwfyefidm2um","tag_id":"ck0n9rv980021kwfy2xwaxd5r","_id":"ck0n9rv9b0024kwfyepzbxk2f"},{"post_id":"ck0n9rv8r001ckwfyinjmkllb","tag_id":"ck0n9rv97001zkwfylrrku270","_id":"ck0n9rv9c0026kwfyzg0gf1sn"},{"post_id":"ck0n9rv8u001fkwfycb7ttcil","tag_id":"ck0n9rv97001zkwfylrrku270","_id":"ck0n9rv9d0028kwfyv0j4dk2m"},{"post_id":"ck0n9rv8x001kkwfyg36486jf","tag_id":"ck0n9rv9c0027kwfyegpej697","_id":"ck0n9rv9d002akwfywteye9aq"},{"post_id":"ck0n9rv90001qkwfyns911maf","tag_id":"ck0n9rv9d0029kwfyalp26up3","_id":"ck0n9rv9d002bkwfyph3acu3j"},{"post_id":"ck0n9rw8y002ckwfyuqa0m4h7","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rw92002ekwfyslo46jlc"},{"post_id":"ck0n9rw94002hkwfyk00qbzza","tag_id":"ck0n9rv8f000vkwfydlkmd6ay","_id":"ck0n9rw98002lkwfyx06r0n2r"},{"post_id":"ck0n9rw96002jkwfyp0wfmfwx","tag_id":"ck0n9rv8i0011kwfy1z7q7nc6","_id":"ck0n9rw9a002pkwfyn603e3r3"},{"post_id":"ck0n9rw8z002dkwfyfwfuz72v","tag_id":"ck0n9rw94002gkwfyuzk1678l","_id":"ck0n9rw9b002skwfyninpzgwr"},{"post_id":"ck0n9rw98002mkwfy5yllydfy","tag_id":"ck0n9rv8t001ekwfy0wpeg4wv","_id":"ck0n9rw9d002vkwfyp5zrv33w"},{"post_id":"ck0n9rw9a002qkwfyym2q6k2y","tag_id":"ck0n9rv8t001ekwfy0wpeg4wv","_id":"ck0n9rw9d002xkwfy5o4qe40o"},{"post_id":"ck0n9rw93002fkwfygno4bufd","tag_id":"ck0n9rw99002nkwfyfcjyi9ak","_id":"ck0n9rw9d002ykwfyfsigwybn"},{"post_id":"ck0n9rw9b002tkwfyfer5t7ec","tag_id":"ck0n9rv89000okwfy8owc0tir","_id":"ck0n9rw9e0030kwfyy621ybc5"},{"post_id":"ck0n9rwcd0031kwfyyvhqtm65","tag_id":"ck0n9rv7j0005kwfynfx2mwab","_id":"ck0n9rwch0033kwfyq99jbkp1"},{"post_id":"ck0n9rwcf0032kwfyqjz8msdg","tag_id":"ck0n9rwch0034kwfye85r9a9n","_id":"ck0n9rwci0037kwfy6m2teowr"}],"Tag":[{"name":"javascript","_id":"ck0n9rv7j0005kwfynfx2mwab"},{"name":"学习","_id":"ck0n9rv89000okwfy8owc0tir"},{"name":"react","_id":"ck0n9rv8f000vkwfydlkmd6ay"},{"name":"React Native","_id":"ck0n9rv8i0011kwfy1z7q7nc6"},{"name":"vue","_id":"ck0n9rv8t001ekwfy0wpeg4wv"},{"name":"指弹","_id":"ck0n9rv97001zkwfylrrku270"},{"name":"其他","_id":"ck0n9rv980021kwfy2xwaxd5r"},{"name":"杂记","_id":"ck0n9rv9c0027kwfyegpej697"},{"name":"浏览器","_id":"ck0n9rv9d0029kwfyalp26up3"},{"name":"算法","_id":"ck0n9rw94002gkwfyuzk1678l"},{"name":"koa","_id":"ck0n9rw99002nkwfyfcjyi9ak"},{"name":"网络","_id":"ck0n9rwch0034kwfye85r9a9n"}]}}
=======
{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"940324331303436852794632deb53f33f8746ffb","modified":1563708306000},{"_id":"source/CNAME","hash":"6224041a5b0039720f1ad195f43105f54b82dc10","modified":1563710335000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1563711919000},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1563711919000},{"_id":"themes/maupassant/README.md","hash":"90032cb3a46f741a3d6198de9f83ce384505519e","modified":1563711919000},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1563711919000},{"_id":"themes/maupassant/_config.yml","hash":"4c8c4328c1bd933a78319d3678d97b5453780831","modified":1563711943000},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1563711919000},{"_id":"source/_posts/Array.md","hash":"2dca078e46744e0f0a06a12202c6886a42a6410f","modified":1563708306000},{"_id":"source/_posts/JSX.md","hash":"ee62b60b99332200bd26cc4c31c34b55245908e0","modified":1563708306000},{"_id":"source/_posts/VueInAction1.md","hash":"d8a5827f28e6d8aa7783708e5b4f9c7c01bd978c","modified":1563708306000},{"_id":"source/_posts/Ngnix.md","hash":"6b543bc3e2924e1e013bd3b2c688a5ae0a43de01","modified":1563708306000},{"_id":"source/_posts/Vue-lifecycle.md","hash":"362b672834dc6712fadec9cb4a7613457fc56452","modified":1563708306000},{"_id":"source/_posts/ReactNativeComponent.md","hash":"a1f3f4e5b77f4639b66501b5c5c8ba029c2ffaa7","modified":1563708306000},{"_id":"source/_posts/VueInAction2.md","hash":"4cf785e84449e45640981160f2d8e8f039c3fedc","modified":1563708306000},{"_id":"source/_posts/axioshhh.md","hash":"aad3c54ca4074ed83fba258524cd2798501608f1","modified":1563708306000},{"_id":"source/_posts/choppingHand1.md","hash":"13e464d6db80af2ce4c39768c9407e9d0fabec9a","modified":1563708306000},{"_id":"source/_posts/choppingHand2.md","hash":"75d1e655c0cb2976c94225e29da97c16107c0ac1","modified":1563708306000},{"_id":"source/_posts/debounce.md","hash":"14907657ed142222dfc3ff36270a91d8bb892422","modified":1563708306000},{"_id":"source/_posts/friendships.md","hash":"c3ee0e93f315c756bc994891d4b41f983f133e07","modified":1563708306000},{"_id":"source/_posts/git杂记.md","hash":"26e84600d30ab51392327b939eb8c3df202bd6f0","modified":1563708306000},{"_id":"source/_posts/hexoml.md","hash":"a3708907f51577d5c37386bbabdea8609c671c4b","modified":1563708306000},{"_id":"source/_posts/http.md","hash":"ac09f67dbb1e428139415ffb28d2f5dca4617e60","modified":1563708306000},{"_id":"source/_posts/instanceof.md","hash":"e5b7eb8e31bf49de05fab29adf5725ea018f1fab","modified":1563708306000},{"_id":"source/_posts/jsMemoryManagent.md","hash":"b4236c084970a5a65f3921f338819d0256530ec1","modified":1563708306000},{"_id":"source/_posts/koaMiddle.md","hash":"3863c621d592c4b6df981a34cd00806c1110d25c","modified":1563708306000},{"_id":"source/_posts/prototype.md","hash":"1207822fa57ba99fceddc8d704361b10e49afa51","modified":1563708306000},{"_id":"source/_posts/react的setState.md","hash":"decb111e95a87446e383babc9a57aec59745c92a","modified":1563708306000},{"_id":"source/_posts/selfPromise.md","hash":"543ecc9cb5415a3c87307a75fb5e187e4b058fec","modified":1563708306000},{"_id":"source/_posts/timetravel.md","hash":"21880ec75c35fdacc2293d15daa756dbb64ac0db","modified":1563708306000},{"_id":"source/_posts/template.md","hash":"05149ea43fe9ee8679adc4a3ae996a5153c17ced","modified":1563708306000},{"_id":"source/_posts/this.md","hash":"8fddfc2cf406ab2b232b737551ec07cd2a526f92","modified":1563708306000},{"_id":"source/_posts/sort.md","hash":"35312e14fdde0bb448722f2918fa53d050794ab7","modified":1563708306000},{"_id":"source/_posts/toLittleCute.md","hash":"19f8519aeb7930924625fdef18daa10297daaf2d","modified":1563708306000},{"_id":"source/_posts/v-model.md","hash":"a2337d565d4fd6bacae1399bbb1e932f968691c9","modified":1563708306000},{"_id":"source/_posts/vue的diff.md","hash":"96762dfa92864a515afd4db7dd8dfa93bbbf4d2b","modified":1563708306000},{"_id":"source/_posts/流行的云.md","hash":"1b588a865ee106e1fb290f0e0f16187dd9437f35","modified":1563708306000},{"_id":"source/_posts/封培总结.md","hash":"42121364b682e4456a1e396c193436f1e9a31224","modified":1563763741000},{"_id":"source/_posts/面试.md","hash":"c429846da195fb3e314a2ac05ad00957ae4af5fc","modified":1563708306000},{"_id":"source/about/React高阶组件.md","hash":"f6595c756fe23f9826cd830407eaa8ad6b698b40","modified":1563708306000},{"_id":"source/youlian/index.md","hash":"77ac6ea5391630bec3edfe00ba01e319b2d54dbf","modified":1563708306000},{"_id":"source/about/index.md","hash":"80ae88f9c3f83c35b78d56f0987c00ab51a1ee7a","modified":1563708306000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1563711919000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1563711919000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1563711912000},{"_id":"themes/maupassant/.git/packed-refs","hash":"4abcc58543ef23fdb894778f62d5597928dbd2aa","modified":1563711919000},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1563711919000},{"_id":"themes/maupassant/.git/index","hash":"41a6a6e97e1d5c2d18c4a46d3c6512283e39dde6","modified":1563711919000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1563711919000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1563711919000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1563711919000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1563711919000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1563711919000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1563711919000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1563711919000},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1563711919000},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1563711919000},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1563711919000},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1563711919000},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1563711919000},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1563711919000},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1563711919000},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1563711919000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1563711912000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"14541f3738335050b09bde8bca6756ad841eaafc","modified":1563711919000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1563711912000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1563711912000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1563711912000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"507fd8d2fde98df6216ed7c8f60ebea7cf77bfb2","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1563711919000},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1563711919000},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1563711919000},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1563711919000},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1563711919000},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1563711919000},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1563711919000},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1563711919000},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1563711919000},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1563711919000},{"_id":"themes/maupassant/source/css/style.scss","hash":"fa5dfd0867f95fe1708e6fda90e41db6364c01d9","modified":1563711919000},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1563711919000},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1563711919000},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1563711919000},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1563711919000},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1563711919000},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1563711919000},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1563711919000},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1563711919000},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1563711919000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1563711919000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1563711919000},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1563711919000},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1563711919000},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1563711919000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1563711919000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1563711919000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1563711919000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"4038440af2ee0106fac646477c3d97866ea52a2f","modified":1563711919000},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1563711919000},{"_id":"themes/maupassant/.git/objects/pack/pack-830a89f81a3bdff38e17ab046e80fe65049cee0e.idx","hash":"4742a8f1e30a3be5d0ee33ae1d040738cd73a54c","modified":1563711919000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1563711919000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"14541f3738335050b09bde8bca6756ad841eaafc","modified":1563711919000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"14541f3738335050b09bde8bca6756ad841eaafc","modified":1563711919000},{"_id":"themes/maupassant/.git/objects/pack/pack-830a89f81a3bdff38e17ab046e80fe65049cee0e.pack","hash":"f8229e1064e453950eb977fc70da5e2e3cf9e172","modified":1563711919000},{"_id":"public/atom.xml","hash":"7054a69314e9ffac9f03976e824cedbcb9759490","modified":1563763778963},{"_id":"public/README.html","hash":"9bc83e765ef65eae53500f6af673efce26a8a56f","modified":1563763779051},{"_id":"public/about/React高阶组件.html","hash":"29a7eadb02ce4aa744dd28d4a862d83e1927aee4","modified":1563763779052},{"_id":"public/about/index.html","hash":"b9023d725bf8b38e865bec73db42935eebee8809","modified":1563763779052},{"_id":"public/youlian/index.html","hash":"bf93580ab845919950585bb6a165146fb26c5ec9","modified":1563763779053},{"_id":"public/2018/12/07/git杂记/index.html","hash":"99eeab19eb1c0d6ad8ff9744c4789ccec76a6793","modified":1563763779053},{"_id":"public/2018/06/15/choppingHand2/index.html","hash":"e765838700f385ad8ca16c310204ac2fb874cf13","modified":1563763779053},{"_id":"public/2018/05/23/friendships/index.html","hash":"881a52111c192f01e48c135abbeba0b392dbd0b0","modified":1563763779053},{"_id":"public/2018/05/20/流行的云/index.html","hash":"118a37f73aa50d3fc3c70008b9d8d15f263baadc","modified":1563763779053},{"_id":"public/2018/04/29/timetravel/index.html","hash":"1f7aa4d7862a99a0ecf848829901cc926ff4e8f9","modified":1563763779054},{"_id":"public/2018/03/28/toLittleCute/index.html","hash":"71902120889de59757b517e29daa40efa8fb2a8e","modified":1563763779054},{"_id":"public/2018/03/25/debounce/index.html","hash":"1136dd10456a01cb681b743d6a76fa44db83a5bc","modified":1563763779054},{"_id":"public/categories/学习/index.html","hash":"6852fd1f94674fb86f49bb62627512388bdebca6","modified":1563763779054},{"_id":"public/categories/学习/page/2/index.html","hash":"5ee4c5c1e40a4deabd25379bdcfc63f712d2fdc7","modified":1563763779054},{"_id":"public/categories/学习/page/3/index.html","hash":"466ca79c70f9fea5ae3b6b6b1455174bf4931e57","modified":1563763779054},{"_id":"public/categories/指弹/index.html","hash":"0db583f80a16249bd691be0c740895e7ace51133","modified":1563763779054},{"_id":"public/categories/生活/index.html","hash":"03ff6178cfa7424d13469c91f7b56152f3625494","modified":1563763779054},{"_id":"public/tags/React-Native/index.html","hash":"6ecce40e5a2b655c3e5241a3ac6ae048d35c52f1","modified":1563763779054},{"_id":"public/tags/vue/index.html","hash":"2a80cc450ad352ae6e2f590c193faa014cda04fd","modified":1563763779054},{"_id":"public/tags/javascript/index.html","hash":"04b62b76e3a914941140b7a0d7d3502d89baef2d","modified":1563763779054},{"_id":"public/tags/杂记/index.html","hash":"c7b507fe517e4b53fd3b4a50d066f8582597884f","modified":1563763779055},{"_id":"public/tags/Hexo/index.html","hash":"9f49c2b97ad021d648cb73f23f98bae709ec70be","modified":1563763779055},{"_id":"public/tags/指弹/index.html","hash":"553e6d017556d9a0f5fb07d3bc16a0deeb020947","modified":1563763779055},{"_id":"public/tags/react/index.html","hash":"9a595932f1f3fbe75275cc7720c2ea70a4ffe4d5","modified":1563763779055},{"_id":"public/tags/学习/index.html","hash":"9e89a1457102e82bc7b70e7881d5ffd0035ce3b9","modified":1563763779055},{"_id":"public/tags/不知道归为哪一列系列/index.html","hash":"1a3e9148c2a1489055712380b832d59cbb6d81c9","modified":1563763779055},{"_id":"public/tags/koa/index.html","hash":"35d55f77a6924d3031b1483761cd2208b21af04d","modified":1563763779057},{"_id":"public/tags/算法/index.html","hash":"26c7552f7d369a1f46f7128054ac079c92c2c8fc","modified":1563763779058},{"_id":"public/tags/http/index.html","hash":"918905590cbb39cdfda5f62f3b259f3cd0477980","modified":1563763779058},{"_id":"public/archives/index.html","hash":"73dbce9f9d3afbbbe83da4ae3d20e85c95c87e2c","modified":1563763779058},{"_id":"public/archives/page/2/index.html","hash":"1705b33ccb8707e8031e909b3e7d271fce0359be","modified":1563763779058},{"_id":"public/archives/page/3/index.html","hash":"69ceb0c8761ed4095f36774e009775b59beebe24","modified":1563763779058},{"_id":"public/archives/2018/index.html","hash":"b9dae6f7c0ed51a1a37beb17de86be3ed9977715","modified":1563763779058},{"_id":"public/archives/2018/page/2/index.html","hash":"9279a9c468300661b9d25f6b2da4c5d387dc06cc","modified":1563763779058},{"_id":"public/archives/2018/page/3/index.html","hash":"a3058efa7ceba738c13dc3dbb69db2886b609f04","modified":1563763779059},{"_id":"public/archives/2018/01/index.html","hash":"2bf725ecd93c469ce31e7fe9a2156e85402ee8f4","modified":1563763779059},{"_id":"public/archives/2018/03/index.html","hash":"bf9063d241337a90822a8c99c9837dfc72164bad","modified":1563763779059},{"_id":"public/archives/2018/04/index.html","hash":"e01e3f2390da18bef2812938adb3d8765212cea6","modified":1563763779059},{"_id":"public/archives/2018/05/index.html","hash":"7780433b07ed00d871f197b436d995b2e074d321","modified":1563763779060},{"_id":"public/archives/2018/06/index.html","hash":"dae98a725322f46cc0b67d43ec31508a2aa8dfac","modified":1563763779060},{"_id":"public/archives/2018/07/index.html","hash":"d2b48b12657586302abcd6537e19d28c3a7a5ef9","modified":1563763779060},{"_id":"public/archives/2018/08/index.html","hash":"3fcc58d85db7c8ae10d61bd62a4f686579addc64","modified":1563763779060},{"_id":"public/archives/2018/12/index.html","hash":"1a18ba38c3ca911bf8a06657559e47bd06ce8beb","modified":1563763779060},{"_id":"public/archives/2019/index.html","hash":"70d9363e3637bfaf09de0a0e64888229e19a65c1","modified":1563763779060},{"_id":"public/archives/2019/01/index.html","hash":"ebf5e06fb1a6b4c02d80efc4ba986385381d3a0f","modified":1563763779060},{"_id":"public/index.html","hash":"ea029cfec08f94948e7142fa1962a139b12f9e83","modified":1563763779060},{"_id":"public/page/2/index.html","hash":"399d420b19f1a2e5341c19ee10fb1aba066def30","modified":1563763779060},{"_id":"public/page/3/index.html","hash":"cfd1b708de658cdcce9fadab9dfaf6432ac00a8a","modified":1563763779060},{"_id":"public/2019/01/17/vue的diff/index.html","hash":"77adad8755a26d8f471fc395f84b5cb8a2d7986d","modified":1563763779060},{"_id":"public/2019/01/04/react的setState/index.html","hash":"a46a10fb69419b7101ba268d5f37b01b4d935d62","modified":1563763779061},{"_id":"public/2018/12/31/selfPromise/index.html","hash":"95457a325bffcc4414a2a238c5454c8e2f3d5368","modified":1563763779061},{"_id":"public/2018/08/07/koaMiddle/index.html","hash":"9bf36d36d6e00e1ef6a0842430fc1d11718bed11","modified":1563763779061},{"_id":"public/2018/07/25/sort/index.html","hash":"e5749410f8d324e28a21fd30fcfd8803af5aa102","modified":1563763779061},{"_id":"public/2018/07/19/Ngnix/index.html","hash":"af7e3c8594496633e63daf9af3d9551149fcdadc","modified":1563763779061},{"_id":"public/2018/06/08/choppingHand1/index.html","hash":"abca79a69ad3648ec9901818ff3bcf6ce6b9de9d","modified":1563763779061},{"_id":"public/2018/06/01/ReactNativeComponent/index.html","hash":"b1b668494af27c0ec718ee5d91e9cf12ef4ee52b","modified":1563763779062},{"_id":"public/2018/04/29/Vue-lifecycle/index.html","hash":"3a927dad1580856660fe968889cd24e4a48a63c2","modified":1563763779062},{"_id":"public/2018/04/19/http/index.html","hash":"5d227ff8f0f91bec0750eb971c29d94abc7c14fa","modified":1563763779062},{"_id":"public/2018/04/18/template/index.html","hash":"961ae0e19f33d1fe2adb02a684e641dcf51a1388","modified":1563763779062},{"_id":"public/2018/04/10/axioshhh/index.html","hash":"424d1672b679b0743b59e34f6a7bbafb9427425f","modified":1563763779062},{"_id":"public/2018/04/05/JSX/index.html","hash":"4ea9f137ef32d5c752ed9084161fe7af0991d8d1","modified":1563763779063},{"_id":"public/2018/04/02/面试/index.html","hash":"b8e76d99cf9fbf99981fa71d1f91081959882552","modified":1563763779063},{"_id":"public/2018/03/10/jsMemoryManagent/index.html","hash":"3483ddf16473104053396d52ed985538bd577b6f","modified":1563763779063},{"_id":"public/2018/03/07/this/index.html","hash":"2b3da4a18f0c61a746faaa87fbe038e93ebc9924","modified":1563763779063},{"_id":"public/2018/01/18/prototype/index.html","hash":"98a3d42e9efb11e2896181d1b9add8c8594a6e2f","modified":1563763779063},{"_id":"public/2018/01/16/instanceof/index.html","hash":"9d5c6f0c4650e286707a1e09de459f12bcd26422","modified":1563763779063},{"_id":"public/2018/01/13/Array/index.html","hash":"2d466832cc8250029f5ca6050092f5b711e5bdae","modified":1563763779063},{"_id":"public/2018/01/12/VueInAction2/index.html","hash":"c7721fde3c543fd75d5c569b3ba5bfeb8275869c","modified":1563763779063},{"_id":"public/2018/01/08/v-model/index.html","hash":"7fa4aab322073824261ca28a62d77a4c9a82e957","modified":1563763779063},{"_id":"public/2018/01/05/VueInAction1/index.html","hash":"a2b96f61683751cb17a810a798d9e736bde6a52f","modified":1563763779063},{"_id":"public/2018/01/05/hexoml/index.html","hash":"11d2bba895b1c88c89f95ba05e25bebefe08e26e","modified":1563763779064},{"_id":"public/2019/07/22/封培总结/index.html","hash":"13bbb0e0846efac307b8dd3cfe5d651ea7ddeab6","modified":1563763779074},{"_id":"public/archives/page/4/index.html","hash":"07de1c864b78698326b051644079668886749cee","modified":1563763779074},{"_id":"public/archives/2019/07/index.html","hash":"d821796071ec7ed23832b77de4a7140b363ca2c2","modified":1563763779074},{"_id":"public/page/4/index.html","hash":"00815647a4ffdcae53d1cc76399e492bf725f4ba","modified":1563763779074},{"_id":"public/CNAME","hash":"6224041a5b0039720f1ad195f43105f54b82dc10","modified":1563763779097},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1563763779097},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1563763779097},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1563763779098},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1563763779099},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1563763779099},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1563763779099},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1563763779099},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1563763779100},{"_id":"public/live2d/device.min.js","hash":"ad8ffa5cc29d478f718c73eef31052dd4cdae7b6","modified":1563763779100},{"_id":"public/live2d/assets/mtn/idle_01.mtn","hash":"908abce18f6cf7fd4bc1486f048c25a517f4a34a","modified":1563763779100},{"_id":"public/live2d/assets/mtn/idle_02.mtn","hash":"865874c50848fbc9a55011391531e2ec171c9b91","modified":1563763779100},{"_id":"public/live2d/assets/mtn/idle_03.mtn","hash":"84684914ebf5dc5b2df160338bb97dcc0a978476","modified":1563763779100},{"_id":"public/live2d/assets/mtn/idle_04.mtn","hash":"78e22091792abb0600f724a5dfd60371257954e8","modified":1563763779100},{"_id":"public/live2d/assets/mtn/shake_01.mtn","hash":"dffc54733127832f8f5e91aced55a83da58fa215","modified":1563763779100},{"_id":"public/live2d/assets/mtn/shake_02.mtn","hash":"7b6c914f6c33450eda2e53d9b638fd7045c0f683","modified":1563763779101},{"_id":"public/live2d/assets/mtn/touch_03.mtn","hash":"9c394975083915f0f3786caff1762381348b041e","modified":1563763779101},{"_id":"public/live2d/assets/mtn/touch_01.mtn","hash":"99270ea8fe1f8f5d88eadb94f36bd0810009d1e6","modified":1563763779101},{"_id":"public/live2d/assets/mtn/touch_05.mtn","hash":"9610bb8a937ba9b11445a3894d8cc0733a2b67e5","modified":1563763779102},{"_id":"public/live2d/assets/mtn/touch_02.mtn","hash":"4d1f099fbd18d15c598a644227ed5bf942a2ba71","modified":1563763779102},{"_id":"public/live2d/assets/wanko.model.json","hash":"b98a8ce54fbcf1606a489f1bc5f26b1a18c82d79","modified":1563763779102},{"_id":"public/live2d/assets/mtn/touch_04.mtn","hash":"8d2302cfdaec698e575048797ff4f30ae4d202de","modified":1563763779102},{"_id":"public/live2d/assets/mtn/touch_06.mtn","hash":"feb9237c73f2045ed1704c01b5362c9a54ee5a18","modified":1563763779102},{"_id":"public/assets/css/DPlayer.min.css","hash":"cb54789e9837b8547cd7675d7fe05f53f97a6423","modified":1563763779102},{"_id":"public/assets/js/Meting.min.js","hash":"6909537111a24455834c32b08610e392079921f7","modified":1563763779102},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1563763779103},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1563763779103},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1563763779203},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1563763779204},{"_id":"public/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1563763779204},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1563763779206},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1563763779207},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1563763779212},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1563763779212},{"_id":"public/live2d/assets/moc/wanko.1024/texture_00.png","hash":"c405c1eeb82bcced7aa7a20f04a76168f60ad561","modified":1563763779214},{"_id":"public/live2d/assets/moc/wanko.moc","hash":"7b188cd4dcddfe5bdba8ec51a65cb1c21cd2e57a","modified":1563763779214},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1563763779221},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1563763779221},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1563763779221},{"_id":"public/assets/js/DPlayer.min.js","hash":"9e1eb36ea38a848e82d0f6c1c2d957fc28ef6983","modified":1563763779221},{"_id":"public/live2d/script.js","hash":"6b85d115e5785ab244c8ffa8073be3930868589a","modified":1563763779221},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1563763779303},{"_id":"public/css/style.css","hash":"50dac51e44b24279f14cd3756bf1b388e5977f74","modified":1563763779475},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1563763779477}],"Category":[{"name":"学习","_id":"cjydskrrv0003hvs6bcyu9vdu"},{"name":"指弹","_id":"cjydskrsj000nhvs6e9788n5p"},{"name":"生活","_id":"cjydskrt0001nhvs646maig0q"}],"Data":[],"Page":[{"_content":"# source\nblog：https://666666666666.xyz\n","source":"README.md","raw":"# source\nblog：https://666666666666.xyz\n","date":"2019-07-21T11:25:06.000Z","updated":"2019-07-21T11:25:06.000Z","path":"README.html","title":"","comments":1,"layout":"page","_id":"cjydskrqm0000hvs62prxzk9h","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h1><p>blog：<a href=\"https://666666666666.xyz\" target=\"_blank\" rel=\"noopener\">https://666666666666.xyz</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h1><p>blog：<a href=\"https://666666666666.xyz\" target=\"_blank\" rel=\"noopener\">https://666666666666.xyz</a></p>\n"},{"title":"React高阶组件","date":"2019-01-14T11:24:50.000Z","tags":"react","_content":"\n> 早在一开始学习react的时候，就知其大名，最近实习用ant design的form自定义组件时，对ant design的高阶组件产生了兴趣，想着看看他的源码，然后做一些总结。\n\n### 啥是高阶组件\n\n高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant design的getFieldDecorator（后面稍微讲一下）。\n----\nloading","source":"about/React高阶组件.md","raw":"---\ntitle: React高阶组件\ndate: 2019-01-14 19:24:50\ntags: react\n---\n\n> 早在一开始学习react的时候，就知其大名，最近实习用ant design的form自定义组件时，对ant design的高阶组件产生了兴趣，想着看看他的源码，然后做一些总结。\n\n### 啥是高阶组件\n\n高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant design的getFieldDecorator（后面稍微讲一下）。\n----\nloading","updated":"2019-07-21T11:25:06.000Z","path":"about/React高阶组件.html","comments":1,"layout":"page","_id":"cjydskst70024hvs66d3kgthp","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>早在一开始学习react的时候，就知其大名，最近实习用ant design的form自定义组件时，对ant design的高阶组件产生了兴趣，想着看看他的源码，然后做一些总结。</p>\n</blockquote>\n<h3 id=\"啥是高阶组件\"><a href=\"#啥是高阶组件\" class=\"headerlink\" title=\"啥是高阶组件\"></a>啥是高阶组件</h3><h2 id=\"高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant-design的getFieldDecorator（后面稍微讲一下）。\"><a href=\"#高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant-design的getFieldDecorator（后面稍微讲一下）。\" class=\"headerlink\" title=\"高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant design的getFieldDecorator（后面稍微讲一下）。\"></a>高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant design的getFieldDecorator（后面稍微讲一下）。</h2><p>loading</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>早在一开始学习react的时候，就知其大名，最近实习用ant design的form自定义组件时，对ant design的高阶组件产生了兴趣，想着看看他的源码，然后做一些总结。</p>\n</blockquote>\n<h3 id=\"啥是高阶组件\"><a href=\"#啥是高阶组件\" class=\"headerlink\" title=\"啥是高阶组件\"></a>啥是高阶组件</h3><h2 id=\"高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant-design的getFieldDecorator（后面稍微讲一下）。\"><a href=\"#高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant-design的getFieldDecorator（后面稍微讲一下）。\" class=\"headerlink\" title=\"高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant design的getFieldDecorator（后面稍微讲一下）。\"></a>高阶组件其实就是一个函数，这个函数将一个组件作为输入，然后输出一个组件，这样我们就可以在函数内部做一些公共的逻辑封装，稍微复杂一点的一般会写成二阶函数的形式，形如react-redux的connect函数，ant design的getFieldDecorator（后面稍微讲一下）。</h2><p>loading</p>\n"},{"title":"在下","date":"2018-01-05T15:54:06.000Z","tags":"About","_content":"我是长沙理工大学的大四学生，喜欢前端，喜欢指弹，马上要毕业了，最后一学期的每一天都不能浪费。\n<br><br>\n\n### 关于指弹\n\n吉他，是我从高中的时候才喜欢上的，但是那个时候，住宿，根本没啥时间学这个，到了大学，跟父母要了人生的第一把吉他，100多的烧火棍，现在在阳台上代我经历风吹雨打。第二把是一把一千多的斗牛士，我跟爸妈借的钱（已还），后来在学校实验室接外包，挣了点钱买了第三把，也就是现在这把，takewood 。lakewood，要23500，贵的一批，就买了个5000左右的takewood，屌丝吧。\n<img style=\"width:300px;\" src=\"http://pkkch1tf7.bkt.clouddn.com/guitar1.jpeg\" />\n\n<img  style=\"width:300px;\"  src=\"http://pkkch1tf7.bkt.clouddn.com/guitar2.jpeg\"/>","source":"about/index.md","raw":"---\ntitle: 在下\ndate: 2018-01-05 23:54:06\ntags: About\n---\n我是长沙理工大学的大四学生，喜欢前端，喜欢指弹，马上要毕业了，最后一学期的每一天都不能浪费。\n<br><br>\n\n### 关于指弹\n\n吉他，是我从高中的时候才喜欢上的，但是那个时候，住宿，根本没啥时间学这个，到了大学，跟父母要了人生的第一把吉他，100多的烧火棍，现在在阳台上代我经历风吹雨打。第二把是一把一千多的斗牛士，我跟爸妈借的钱（已还），后来在学校实验室接外包，挣了点钱买了第三把，也就是现在这把，takewood 。lakewood，要23500，贵的一批，就买了个5000左右的takewood，屌丝吧。\n<img style=\"width:300px;\" src=\"http://pkkch1tf7.bkt.clouddn.com/guitar1.jpeg\" />\n\n<img  style=\"width:300px;\"  src=\"http://pkkch1tf7.bkt.clouddn.com/guitar2.jpeg\"/>","updated":"2019-07-21T11:25:06.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjydsksta0026hvs6yc5b1kbe","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>我是长沙理工大学的大四学生，喜欢前端，喜欢指弹，马上要毕业了，最后一学期的每一天都不能浪费。<br><br><br></p>\n<h3 id=\"关于指弹\"><a href=\"#关于指弹\" class=\"headerlink\" title=\"关于指弹\"></a>关于指弹</h3><p>吉他，是我从高中的时候才喜欢上的，但是那个时候，住宿，根本没啥时间学这个，到了大学，跟父母要了人生的第一把吉他，100多的烧火棍，现在在阳台上代我经历风吹雨打。第二把是一把一千多的斗牛士，我跟爸妈借的钱（已还），后来在学校实验室接外包，挣了点钱买了第三把，也就是现在这把，takewood 。lakewood，要23500，贵的一批，就买了个5000左右的takewood，屌丝吧。<br><img style=\"width:300px;\" src=\"http://pkkch1tf7.bkt.clouddn.com/guitar1.jpeg\"></p>\n<p><img style=\"width:300px;\" src=\"http://pkkch1tf7.bkt.clouddn.com/guitar2.jpeg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我是长沙理工大学的大四学生，喜欢前端，喜欢指弹，马上要毕业了，最后一学期的每一天都不能浪费。<br><br><br></p>\n<h3 id=\"关于指弹\"><a href=\"#关于指弹\" class=\"headerlink\" title=\"关于指弹\"></a>关于指弹</h3><p>吉他，是我从高中的时候才喜欢上的，但是那个时候，住宿，根本没啥时间学这个，到了大学，跟父母要了人生的第一把吉他，100多的烧火棍，现在在阳台上代我经历风吹雨打。第二把是一把一千多的斗牛士，我跟爸妈借的钱（已还），后来在学校实验室接外包，挣了点钱买了第三把，也就是现在这把，takewood 。lakewood，要23500，贵的一批，就买了个5000左右的takewood，屌丝吧。<br><img style=\"width:300px;\" src=\"http://pkkch1tf7.bkt.clouddn.com/guitar1.jpeg\"></p>\n<p><img style=\"width:300px;\" src=\"http://pkkch1tf7.bkt.clouddn.com/guitar2.jpeg\"></p>\n"},{"title":"在下","date":"2018-01-05T15:54:06.000Z","tags":"friends","_content":"","source":"youlian/index.md","raw":"---\ntitle: 在下\ndate: 2018-01-05 23:54:06\ntags: friends\n---\n","updated":"2019-07-21T11:25:06.000Z","path":"youlian/index.html","comments":1,"layout":"page","_id":"cjydskstd0029hvs69ikpkcvw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Vue学习笔记之啦啦啦","date":"2018-01-05T15:54:06.000Z","_content":"\n\n\n>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue\n>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码\n>再敲一遍，特此记录。\n\n  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br>\n\n<!--more-->\n\n\n\n\n## 生命周期\n\n每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br>\nVue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:\n  > + created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。\n  > + mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。\n  > + beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。\n\n<em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em>\n\n## 计算属性\n计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。\n\n## 一些新学到的指令\n+ v-cloak\n\n\n>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。\n\n\n```bash\n<div id=\"app\" v-cloak>\n  {{message}}\n</div>\n<script>\n  var app = new Vue({\n  el:'#app',\n  data:{\n  message:'这是一段文本'\n}\n})\n</script>\n```\n\n当网速较慢时，Vue.js还没加载完，页面上会出现{{message}}的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。\n\n```bash\n[v-cloak]{\n  display:none;\n}\n```\n\n就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。\n\n+ v-once\n\n>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。\n\n+ v-if,v-else-if,v-else\n\n\n>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            type:'name',\n            status:2\n        },\n        methods:{\n            handleToggleClick:function(){\n                this.type = this.type ==='name'?'mail':'name';\n            }\n        }\n    })\n</script>\n```\n\n点击切换按钮，虽然DOM元素改变了，但是之前在输入\n框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png)\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png)\n\n如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n```\n\n+ v-show\n\n>v-show是通过改变元素的display为none，来隐藏元素的。\n <strong>\nv-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v\n-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em>\n </strong>\n\n+ v-for\n\n\n> 关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br>\n\n\nPS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。\n","source":"_posts/VueInAction1.md","raw":"---\ntitle: Vue学习笔记之啦啦啦\ndate: 2018-01-05 23:54:06\ntags: vue\ncategories: 学习\n---\n\n\n\n>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue\n>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码\n>再敲一遍，特此记录。\n\n  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br>\n\n<!--more-->\n\n\n\n\n## 生命周期\n\n每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br>\nVue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:\n  > + created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。\n  > + mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。\n  > + beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。\n\n<em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em>\n\n## 计算属性\n计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。\n\n## 一些新学到的指令\n+ v-cloak\n\n\n>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。\n\n\n```bash\n<div id=\"app\" v-cloak>\n  {{message}}\n</div>\n<script>\n  var app = new Vue({\n  el:'#app',\n  data:{\n  message:'这是一段文本'\n}\n})\n</script>\n```\n\n当网速较慢时，Vue.js还没加载完，页面上会出现{{message}}的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。\n\n```bash\n[v-cloak]{\n  display:none;\n}\n```\n\n就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。\n\n+ v-once\n\n>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。\n\n+ v-if,v-else-if,v-else\n\n\n>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            type:'name',\n            status:2\n        },\n        methods:{\n            handleToggleClick:function(){\n                this.type = this.type ==='name'?'mail':'name';\n            }\n        }\n    })\n</script>\n```\n\n点击切换按钮，虽然DOM元素改变了，但是之前在输入\n框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png)\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png)\n\n如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：\n\n```bash\n<div id=\"app\">\n    <template v-if=\"type === 'name'\">\n        <label>用户名</label>\n        <input  placeholder=\"输入用户名\" key=\"name-input\">\n    </template>\n    <template v-else>\n        <label>邮箱：</label>\n        <input  placeholder=\"输入邮箱\" key=\"mail-input\">\n    </template>\n    <button @click=\"handleToggleClick\">输入切换类型</button>\n    <p v-show=\"status===1\">当status为1时显示</p>\n</div>\n```\n\n+ v-show\n\n>v-show是通过改变元素的display为none，来隐藏元素的。\n <strong>\nv-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v\n-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em>\n </strong>\n\n+ v-for\n\n\n> 关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br>\n\n\nPS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。\n","slug":"VueInAction1","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrro0001hvs6fkgn0320","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue<br>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码<br>再敲一遍，特此记录。</p>\n</blockquote>\n<p>  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br></p>\n<a id=\"more\"></a>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br><br>Vue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:</p>\n<blockquote>\n<ul>\n<li>created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。</li>\n<li>mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。</li>\n<li>beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。</li>\n</ul>\n</blockquote>\n<p><em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em></em></em></p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。</p>\n<h2 id=\"一些新学到的指令\"><a href=\"#一些新学到的指令\" class=\"headerlink\" title=\"一些新学到的指令\"></a>一些新学到的指令</h2><ul>\n<li>v-cloak</li>\n</ul>\n<blockquote>\n<p>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> v-cloak&gt;</span><br><span class=\"line\">  &#123;&#123;message&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var app = new Vue(&#123;</span><br><span class=\"line\">  el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">  message:<span class=\"string\">'这是一段文本'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当网速较慢时，Vue.js还没加载完，页面上会出现的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[v-cloak]&#123;</span><br><span class=\"line\">  display:none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。</p>\n<ul>\n<li>v-once</li>\n</ul>\n<blockquote>\n<p>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。</p>\n</blockquote>\n<ul>\n<li>v-if,v-else-if,v-else</li>\n</ul>\n<blockquote>\n<p>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            <span class=\"built_in\">type</span>:<span class=\"string\">'name'</span>,</span><br><span class=\"line\">            status:2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods:&#123;</span><br><span class=\"line\">            handleToggleClick:<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                this.type = this.type ===<span class=\"string\">'name'</span>?<span class=\"string\">'mail'</span>:<span class=\"string\">'name'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>点击切换按钮，虽然DOM元素改变了，但是之前在输入<br>框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png\" alt=\"\"><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png\" alt=\"\"></p>\n<p>如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>v-show</li>\n</ul>\n<blockquote>\n<p>v-show是通过改变元素的display为none，来隐藏元素的。<br> <strong><br>v-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v<br>-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em><br> </strong></p>\n</blockquote>\n<ul>\n<li>v-for</li>\n</ul>\n<blockquote>\n<p>关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br></p>\n</blockquote>\n<p>PS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>之前在慕课网上学过Vue，花了100多买了实站视频，照着敲了一遍，后来又学习node就把Vue<br>搁置了一段时间，后来静下心来决定平平稳稳地学，就买了本Vue.js实战，决定照着书把代码<br>再敲一遍，特此记录。</p>\n</blockquote>\n<p>  <strong>本文借鉴了梁灏先生的《Vue.js实战》的内容，特此声名。</strong><br></p>","more":"<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。<br><br>Vue的生命周期钩子与jQuery的ready()方法类似，比较常用的有:</p>\n<blockquote>\n<ul>\n<li>created实例创建完成后调用，此阶段完成了数据的观测,但尚未挂载，$el还不可用，需要初始化处理一些数据时会比较有用。</li>\n<li>mounted el挂载到实例上之后调用，一般用于开始我们的第一个业务。</li>\n<li>beforeDestory 实例销毁之前调用，主要解绑一些使用addEventListener坚挺的事件等。</li>\n</ul>\n</blockquote>\n<p><em>PS:Vue中输出位置只支持单个表达式，比如三元表达式，不支持语句和流控制。表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。<em></em></em></p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>计算属性可以完成各种复杂的计算，只要最终return返回值就可以，计算属性还可以依赖于多个Vue实例的数据，<strong>只要其中任一数据发生变化，计算属性就会重新执行，视图也会更新</strong>这正是Vue的双向绑定效果，业务逻辑与View层完全解耦，啧啧。</p>\n<h2 id=\"一些新学到的指令\"><a href=\"#一些新学到的指令\" class=\"headerlink\" title=\"一些新学到的指令\"></a>一些新学到的指令</h2><ul>\n<li>v-cloak</li>\n</ul>\n<blockquote>\n<p>该指令不需要表达式，他会在Vue实力结束编译时从绑定的HTML元素上移除，经常和CSS的display：none配合使用。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> v-cloak&gt;</span><br><span class=\"line\">  &#123;&#123;message&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var app = new Vue(&#123;</span><br><span class=\"line\">  el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">  message:<span class=\"string\">'这是一段文本'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当网速较慢时，Vue.js还没加载完，页面上会出现的字样，知道Vue创建实例,编译模板时，DOM才会被替换，所以屏幕会闪动，这时加一句CSS就OK。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[v-cloak]&#123;</span><br><span class=\"line\">  display:none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是说在浏览器加载完DOM，镶嵌CSS之后加载js之前，让他消失，当Vue实例编译过后，v-cloak会移除，这时display:none便不起作用了。</p>\n<ul>\n<li>v-once</li>\n</ul>\n<blockquote>\n<p>该指令也不需要表达式，作用是定义它的元素或组件，至渲染一次，后面数据改变时，也不会重新渲染。一般在优化性能时，才用得到。</p>\n</blockquote>\n<ul>\n<li>v-if,v-else-if,v-else</li>\n</ul>\n<blockquote>\n<p>关于这几个指令，这一次学到的是该指令会根据表达式的值在DOM中渲染或销毁元素或组件，销毁指的是从DOM树中移除，另外还有<strong>元素复用</strong>的问题。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            <span class=\"built_in\">type</span>:<span class=\"string\">'name'</span>,</span><br><span class=\"line\">            status:2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods:&#123;</span><br><span class=\"line\">            handleToggleClick:<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                this.type = this.type ===<span class=\"string\">'name'</span>?<span class=\"string\">'mail'</span>:<span class=\"string\">'name'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>点击切换按钮，虽然DOM元素改变了，但是之前在输入<br>框输入的内容没变，只是替换了placeholder的内容，说明input被复用了。如图所示：</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAcion1.png\" alt=\"\"><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueInAction2.png\" alt=\"\"></p>\n<p>如果不希望如此  可以给不想被复用的元素，加个key，key的值必须是惟一的。代码用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;template v-if=<span class=\"string\">\"type === 'name'\"</span>&gt;</span><br><span class=\"line\">        &lt;label&gt;用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入用户名\"</span> key=<span class=\"string\">\"name-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template v-else&gt;</span><br><span class=\"line\">        &lt;label&gt;邮箱：&lt;/label&gt;</span><br><span class=\"line\">        &lt;input  placeholder=<span class=\"string\">\"输入邮箱\"</span> key=<span class=\"string\">\"mail-input\"</span>&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"handleToggleClick\"</span>&gt;输入切换类型&lt;/button&gt;</span><br><span class=\"line\">    &lt;p v-show=<span class=\"string\">\"status===1\"</span>&gt;当status为1时显示&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>v-show</li>\n</ul>\n<blockquote>\n<p>v-show是通过改变元素的display为none，来隐藏元素的。<br> <strong><br>v-if和v-show都有类似的功能，不过v-if是真正的条件渲染，他会根据表达式适当的销毁或重建元素及绑定的事件或子组件。若表达式的初始值为false，则一开始元素/组件并不会被渲染，只有当条件第一次为真时，才开始编译。而v-show，无论条件真与否，都会被渲染。<em>相比之下，v<br>-if更适合不经常改变的场景，因为浏览器会引发回流，开销较大，而v-show适用于频繁切换条件。</em><br> </strong></p>\n</blockquote>\n<ul>\n<li>v-for</li>\n</ul>\n<blockquote>\n<p>关于这条指令，新学到的是of可以替换in，另外在遍历对象是参数是(value,key,index) in data。另外，v-for也支持双向绑定，如果data反生变化，视图会立刻改变。<br></p>\n</blockquote>\n<p>PS：这篇文章昨天晚上没写完，今天才弄完，唉，我得赶紧去拿我的小台灯了，下午去看小可爱，哈哈哈。</p>"},{"title":"choppingHand1","date":"2018-06-08T04:38:50.000Z","_content":"\n>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。\n\n<!--more-->\n\n今天\n\n写了几个界面，登录注册啥的。界面如下：\n<br>\n注册界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png)\n<br>\n登录界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png)\n<br>\n首页\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png)\n\n顺手把页面逻辑跳转写了\n\n```bash\nconst Tab = TabNavigator({\n        Home: {\n            screen: HomeView,\n            navigationOptions: {\n                tabBarLabel: '首页',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/homeSelect.png')}\n                        normalImage={require('./images/home.png')}\n                    />\n                )\n            }\n        },\n        Cart: {\n            screen: CartView,\n            navigationOptions: {\n                tabBarLabel: '购物车',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/cartSelect.png')}\n                        normalImage={require('./images/cart.png')}\n                    />\n                )\n            }\n        },\n        Mine: {\n            screen: MineView,\n            navigationOptions: {\n                tabBarLabel: '我',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/mineSelect.png')}\n                        normalImage={require('./images/mine.png')}\n                    />\n                )\n            }\n        }\n    },\n    // tabScreen配置\n    {\n        tabBarComponent: TabBarBottom, // 自定义\n        tabBarPosition: 'bottom',\n        swipeEnabled: false,\n        animationEnabled: true,\n        lazy: true,\n        tabBarOptions: {\n            activeTintColor: '#e5779c',\n            inactiveTintColor: '#71777c',\n            labelStyle: {\n                fontSize: 12, // 文字大小\n            }\n        }\n\n    }\n);\n\nconst Stack =StackNavigator(\n    {\n        Login: {\n            screen: LoginView,\n            navigationOptions: {\n                header: null\n            }\n        },\n        Tab: {\n            screen: Tab,\n        },\n        GoodPage:{\n            screen: GoodPageView,\n        },\n        Register: {\n            screen: RegisterView,\n            navigationOptions: {\n                header: null\n            }\n        },\n\n\n    }, {\n        navigationOptions: {\n            // 开启动画\n            animationEnabled: true,\n            // 开启边缘触摸返回\n            gesturesEnabled: true\n        },\n        mode: 'card'\n    })\n\n```\n刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。\n","source":"_posts/choppingHand1.md","raw":"---\ntitle: choppingHand1\ndate: 2018-06-8 12:38:50\ntags: React Native\ncategories: 学习\n---\n\n>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。\n\n<!--more-->\n\n今天\n\n写了几个界面，登录注册啥的。界面如下：\n<br>\n注册界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png)\n<br>\n登录界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png)\n<br>\n首页\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png)\n\n顺手把页面逻辑跳转写了\n\n```bash\nconst Tab = TabNavigator({\n        Home: {\n            screen: HomeView,\n            navigationOptions: {\n                tabBarLabel: '首页',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/homeSelect.png')}\n                        normalImage={require('./images/home.png')}\n                    />\n                )\n            }\n        },\n        Cart: {\n            screen: CartView,\n            navigationOptions: {\n                tabBarLabel: '购物车',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/cartSelect.png')}\n                        normalImage={require('./images/cart.png')}\n                    />\n                )\n            }\n        },\n        Mine: {\n            screen: MineView,\n            navigationOptions: {\n                tabBarLabel: '我',\n                tabBarIcon: ({focused, tintColor}) => (\n                    <TabBarItem\n                        tintColor={tintColor}\n                        focused={focused}\n                        selectedImage={require('./images/mineSelect.png')}\n                        normalImage={require('./images/mine.png')}\n                    />\n                )\n            }\n        }\n    },\n    // tabScreen配置\n    {\n        tabBarComponent: TabBarBottom, // 自定义\n        tabBarPosition: 'bottom',\n        swipeEnabled: false,\n        animationEnabled: true,\n        lazy: true,\n        tabBarOptions: {\n            activeTintColor: '#e5779c',\n            inactiveTintColor: '#71777c',\n            labelStyle: {\n                fontSize: 12, // 文字大小\n            }\n        }\n\n    }\n);\n\nconst Stack =StackNavigator(\n    {\n        Login: {\n            screen: LoginView,\n            navigationOptions: {\n                header: null\n            }\n        },\n        Tab: {\n            screen: Tab,\n        },\n        GoodPage:{\n            screen: GoodPageView,\n        },\n        Register: {\n            screen: RegisterView,\n            navigationOptions: {\n                header: null\n            }\n        },\n\n\n    }, {\n        navigationOptions: {\n            // 开启动画\n            animationEnabled: true,\n            // 开启边缘触摸返回\n            gesturesEnabled: true\n        },\n        mode: 'card'\n    })\n\n```\n刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。\n","slug":"choppingHand1","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrrt0002hvs6b3z21vfb","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>今天</p>\n<p>写了几个界面，登录注册啥的。界面如下：<br><br><br>注册界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png\" alt=\"\"><br><br><br>登录界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png\" alt=\"\"><br><br><br>首页<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png\" alt=\"\"></p>\n<p>顺手把页面逻辑跳转写了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Tab = TabNavigator(&#123;</span><br><span class=\"line\">        Home: &#123;</span><br><span class=\"line\">            screen: HomeView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/homeSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/home.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Cart: &#123;</span><br><span class=\"line\">            screen: CartView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'购物车'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/cartSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/cart.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Mine: &#123;</span><br><span class=\"line\">            screen: MineView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'我'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/mineSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/mine.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // tabScreen配置</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tabBarComponent: TabBarBottom, // 自定义</span><br><span class=\"line\">        tabBarPosition: <span class=\"string\">'bottom'</span>,</span><br><span class=\"line\">        swipeEnabled: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        lazy: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        tabBarOptions: &#123;</span><br><span class=\"line\">            activeTintColor: <span class=\"string\">'#e5779c'</span>,</span><br><span class=\"line\">            inactiveTintColor: <span class=\"string\">'#71777c'</span>,</span><br><span class=\"line\">            labelStyle: &#123;</span><br><span class=\"line\">                fontSize: 12, // 文字大小</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">const Stack =StackNavigator(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Login: &#123;</span><br><span class=\"line\">            screen: LoginView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Tab: &#123;</span><br><span class=\"line\">            screen: Tab,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        GoodPage:&#123;</span><br><span class=\"line\">            screen: GoodPageView,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Register: &#123;</span><br><span class=\"line\">            screen: RegisterView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        navigationOptions: &#123;</span><br><span class=\"line\">            // 开启动画</span><br><span class=\"line\">            animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            // 开启边缘触摸返回</span><br><span class=\"line\">            gesturesEnabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        mode: <span class=\"string\">'card'</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。</p>\n</blockquote>","more":"<p>今天</p>\n<p>写了几个界面，登录注册啥的。界面如下：<br><br><br>注册界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png\" alt=\"\"><br><br><br>登录界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png\" alt=\"\"><br><br><br>首页<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png\" alt=\"\"></p>\n<p>顺手把页面逻辑跳转写了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Tab = TabNavigator(&#123;</span><br><span class=\"line\">        Home: &#123;</span><br><span class=\"line\">            screen: HomeView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/homeSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/home.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Cart: &#123;</span><br><span class=\"line\">            screen: CartView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'购物车'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/cartSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/cart.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Mine: &#123;</span><br><span class=\"line\">            screen: MineView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                tabBarLabel: <span class=\"string\">'我'</span>,</span><br><span class=\"line\">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class=\"line\">                    &lt;TabBarItem</span><br><span class=\"line\">                        tintColor=&#123;tintColor&#125;</span><br><span class=\"line\">                        focused=&#123;focused&#125;</span><br><span class=\"line\">                        selectedImage=&#123;require(<span class=\"string\">'./images/mineSelect.png'</span>)&#125;</span><br><span class=\"line\">                        normalImage=&#123;require(<span class=\"string\">'./images/mine.png'</span>)&#125;</span><br><span class=\"line\">                    /&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // tabScreen配置</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tabBarComponent: TabBarBottom, // 自定义</span><br><span class=\"line\">        tabBarPosition: <span class=\"string\">'bottom'</span>,</span><br><span class=\"line\">        swipeEnabled: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        lazy: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        tabBarOptions: &#123;</span><br><span class=\"line\">            activeTintColor: <span class=\"string\">'#e5779c'</span>,</span><br><span class=\"line\">            inactiveTintColor: <span class=\"string\">'#71777c'</span>,</span><br><span class=\"line\">            labelStyle: &#123;</span><br><span class=\"line\">                fontSize: 12, // 文字大小</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">const Stack =StackNavigator(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Login: &#123;</span><br><span class=\"line\">            screen: LoginView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Tab: &#123;</span><br><span class=\"line\">            screen: Tab,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        GoodPage:&#123;</span><br><span class=\"line\">            screen: GoodPageView,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Register: &#123;</span><br><span class=\"line\">            screen: RegisterView,</span><br><span class=\"line\">            navigationOptions: &#123;</span><br><span class=\"line\">                header: null</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        navigationOptions: &#123;</span><br><span class=\"line\">            // 开启动画</span><br><span class=\"line\">            animationEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            // 开启边缘触摸返回</span><br><span class=\"line\">            gesturesEnabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        mode: <span class=\"string\">'card'</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。</p>"},{"title":"choppingHand2","date":"2018-06-15T05:07:12.000Z","_content":"\n这段时间把剩下的界面写完了，界面如下：\n<!--more-->\n<br>\n商品详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png)\n<br>\n购物车\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png)\n<br>\n收藏\n<br>\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png)\n<br>\n个人详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png)\n<br>\n订单界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png)\n\n期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来\nreact-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,\n\n```bash\n    constructor(props) {\n        super(props);\n        this.state = {\n            swipeShow: false,\n            store:[]\n        };\n        this.txt = null\n    }\n\n    componentWillMount() {\n        setTimeout(() => {\n            this.setState({\n                swipeShow: true,\n            })\n        })\n    }\n\n    renderSwiper() {\n        return (\n            <Swiper style={styles.swiper} autoplay={true} showsButtons>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide1.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide2.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide3.jpg')}/>\n                </View>\n            </Swiper>\n        )\n    }\n//...\n              <View style={{width: width, height: 150,}}>\n                  {this.state.swipeShow && this.renderSwiper()}\n                </View>\n\n```\n同理react-native-scrollable-tab-view也是同样的解决方案。\n","source":"_posts/choppingHand2.md","raw":"---\ntitle: choppingHand2\ndate: 2018-06-15 13:07:12\ntags: React Native\ncategories: 学习\n---\n\n这段时间把剩下的界面写完了，界面如下：\n<!--more-->\n<br>\n商品详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png)\n<br>\n购物车\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png)\n<br>\n收藏\n<br>\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png)\n<br>\n个人详情界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png)\n<br>\n订单界面\n<br>\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png)\n\n期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来\nreact-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,\n\n```bash\n    constructor(props) {\n        super(props);\n        this.state = {\n            swipeShow: false,\n            store:[]\n        };\n        this.txt = null\n    }\n\n    componentWillMount() {\n        setTimeout(() => {\n            this.setState({\n                swipeShow: true,\n            })\n        })\n    }\n\n    renderSwiper() {\n        return (\n            <Swiper style={styles.swiper} autoplay={true} showsButtons>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide1.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide2.jpg')}/>\n                </View>\n                <View style={styles.slideShow}>\n                    <Image style={styles.banner} source={require('../../images/slide3.jpg')}/>\n                </View>\n            </Swiper>\n        )\n    }\n//...\n              <View style={{width: width, height: 150,}}>\n                  {this.state.swipeShow && this.renderSwiper()}\n                </View>\n\n```\n同理react-native-scrollable-tab-view也是同样的解决方案。\n","slug":"choppingHand2","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrry0005hvs6f0m0t06o","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>这段时间把剩下的界面写完了，界面如下：<br><a id=\"more\"></a><br><br><br>商品详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png\" alt=\"\"><br><br><br>购物车<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png\" alt=\"\"><br><br><br>收藏<br><br></p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png\" alt=\"\"><br><br><br>个人详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png\" alt=\"\"><br><br><br>订单界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png\" alt=\"\"></p>\n<p>期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来<br>react-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            swipeShow: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            store:[]</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        this.txt = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentWillMount</span></span>() &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            this.setState(&#123;</span><br><span class=\"line\">                swipeShow: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">renderSwiper</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> (</span><br><span class=\"line\">            &lt;Swiper style=&#123;styles.swiper&#125; autoplay=&#123;<span class=\"literal\">true</span>&#125; showsButtons&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide1.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide2.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide3.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">            &lt;/Swiper&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//...</span><br><span class=\"line\">              &lt;View style=&#123;&#123;width: width, height: 150,&#125;&#125;&gt;</span><br><span class=\"line\">                  &#123;this.state.swipeShow &amp;&amp; this.renderSwiper()&#125;</span><br><span class=\"line\">                &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p>同理react-native-scrollable-tab-view也是同样的解决方案。</p>\n","site":{"data":{}},"excerpt":"<p>这段时间把剩下的界面写完了，界面如下：<br>","more":"<br><br><br>商品详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png\" alt=\"\"><br><br><br>购物车<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png\" alt=\"\"><br><br><br>收藏<br><br></p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png\" alt=\"\"><br><br><br>个人详情界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png\" alt=\"\"><br><br><br>订单界面<br><br><br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png\" alt=\"\"></p>\n<p>期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来<br>react-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            swipeShow: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            store:[]</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        this.txt = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">componentWillMount</span></span>() &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            this.setState(&#123;</span><br><span class=\"line\">                swipeShow: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">renderSwiper</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> (</span><br><span class=\"line\">            &lt;Swiper style=&#123;styles.swiper&#125; autoplay=&#123;<span class=\"literal\">true</span>&#125; showsButtons&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide1.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide2.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class=\"line\">                    &lt;Image style=&#123;styles.banner&#125; <span class=\"built_in\">source</span>=&#123;require(<span class=\"string\">'../../images/slide3.jpg'</span>)&#125;/&gt;</span><br><span class=\"line\">                &lt;/View&gt;</span><br><span class=\"line\">            &lt;/Swiper&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//...</span><br><span class=\"line\">              &lt;View style=&#123;&#123;width: width, height: 150,&#125;&#125;&gt;</span><br><span class=\"line\">                  &#123;this.state.swipeShow &amp;&amp; this.renderSwiper()&#125;</span><br><span class=\"line\">                &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p>同理react-native-scrollable-tab-view也是同样的解决方案。</p>"},{"title":"debounce","date":"2018-03-25T04:59:53.000Z","_content":"\n>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。\n\n\n<!--more-->\n\n### 防抖\n\n在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。\n在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。\n\n\n```bash\n//最简单的防抖函数\n\nfunction  debounce(fun , delay){\n  var timer = null;\n\n  return function(){\n\n    if(!timer) clearTimeout(timer);\n    timer = setTimeout(fun,delay);\n  }\n}\n\nfunction handleClick(){\n  //一个http请求的骚操作\n}\n//比如当我们点击登陆按钮时，\nbtn.addEventListener('click',debounce(handleClick,500));\n\n```\n上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。\n\n\n### 节流\n\n对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br>\n\n这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br>\n来一个简单的节流函数。\n```bash\nfunction throttle(fun,timeCell){\n\n  var last =new Date().getTime();\n\n  return function(){\n     var now =new Date().getTime();\n    if(last - now >= timeCell){\n      fun();\n      last = now;\n    }\n  }\n}\n\n```\n\n以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。\n","source":"_posts/debounce.md","raw":"---\ntitle: debounce\ndate: 2018-03-25 12:59:53\ntags: javascript\ncategories: 学习\n---\n\n>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。\n\n\n<!--more-->\n\n### 防抖\n\n在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。\n在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。\n\n\n```bash\n//最简单的防抖函数\n\nfunction  debounce(fun , delay){\n  var timer = null;\n\n  return function(){\n\n    if(!timer) clearTimeout(timer);\n    timer = setTimeout(fun,delay);\n  }\n}\n\nfunction handleClick(){\n  //一个http请求的骚操作\n}\n//比如当我们点击登陆按钮时，\nbtn.addEventListener('click',debounce(handleClick,500));\n\n```\n上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。\n\n\n### 节流\n\n对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br>\n\n这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br>\n来一个简单的节流函数。\n```bash\nfunction throttle(fun,timeCell){\n\n  var last =new Date().getTime();\n\n  return function(){\n     var now =new Date().getTime();\n    if(last - now >= timeCell){\n      fun();\n      last = now;\n    }\n  }\n}\n\n```\n\n以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。\n","slug":"debounce","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrrz0006hvs64c0obxqe","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。<br>在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//最简单的防抖函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>  debounce(fun , delay)&#123;</span><br><span class=\"line\">  var timer = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer) clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(fun,delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">handleClick</span></span>()&#123;</span><br><span class=\"line\">  //一个http请求的骚操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//比如当我们点击登陆按钮时，</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>,debounce(handleClick,500));</span><br></pre></td></tr></table></figure>\n<p>上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。</p>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br></p>\n<p>这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br><br>来一个简单的节流函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> throttle(fun,timeCell)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var last =new Date().getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">     var now =new Date().getTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(last - now &gt;= timeCell)&#123;</span><br><span class=\"line\">      fun();</span><br><span class=\"line\">      last = now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>逛掘金的时候，偶尔看到防抖和节流的文章，之前也用过，现在做一下总结。</p>\n</blockquote>","more":"<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>在开发过程中，经常会考虑这种情况，用户网不好（对，所有的用户网都不好），登陆时，用户像抽风一样狂点提交按钮。<br>在远古时代，逻辑处理都是放在后台，这种情况下，需要在前端设置一个隐藏的input，当用户提交登陆信息时，会把这个隐藏的input的值传到后台，作为token，而这个token会在页面刷新的时候更改，后台的同学，拿到这个token保存一下，当用户发送 请求带有一样的token时，后台就丢掉这个请求，但是这样无疑也是增加了成本。所以我们有必要在前端去拦截这个请求，当用户不再点击的 n ms后再去向后台发送请求。这就是防抖，是闭包的一个运用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//最简单的防抖函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>  debounce(fun , delay)&#123;</span><br><span class=\"line\">  var timer = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer) clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(fun,delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">handleClick</span></span>()&#123;</span><br><span class=\"line\">  //一个http请求的骚操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//比如当我们点击登陆按钮时，</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>,debounce(handleClick,500));</span><br></pre></td></tr></table></figure>\n<p>上述代码实现的效果就是当用户多次点击提交时，handleClick并不会执行，因为delay ms后事件还没来的及添入事件队列，就被clear了。</p>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>对于mousemove，scroll，我们想要的效果大概是均匀地触发某些操作，这个时候使用debounce就有点鸡肋了，可以想象一下，用debounce去触发拖拽效果，会是什么样的场景，当你拖动目标元素时，目标不会移动，当你停下鼠标时，它才会移动。<br></p>\n<p>这时，throttle会更适合一点，它的实现效果是短时间内触发多次，只会在固定的时间间隔内执行回调。<br><br>来一个简单的节流函数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> throttle(fun,timeCell)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var last =new Date().getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">     var now =new Date().getTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(last - now &gt;= timeCell)&#123;</span><br><span class=\"line\">      fun();</span><br><span class=\"line\">      last = now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上就是最简单的防抖和节流，如果要考虑函数调用的执行上下文，可以手动设置this，并显示绑定函数。</p>"},{"title":"git杂记","date":"2018-12-07T08:33:09.000Z","_content":"\n不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。\n<!--more-->\n\n### git的三个区域\n\n+ 工作区，就是在编辑器里看到的那些代码\n+ 缓存区，通过git add将指定文件添加到此区域\n+ 版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。\n\n### commitID\n形如 1953***6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  --oneline\n\n### 一些常用的命令\n#### git status (gst)\n当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。\n#### git branch  \n查看本地分支已经存在的分支，当前分支带*。\n+ -r 查看远程分支\n+ dev 加分支名，创建分支dev\n+ -d dev 删除分支dev\n\n#### git checkout\n+ dev 切换到dev分支上，然后更新工作目录。\n\n+ -b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。\n\n+ commitID file\n  查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。\n\n+ commitID\n  更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。\n\n+ -b dev origin/dev\n\t将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。\n\n#### git stash\n如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。\n\n### git pull\n将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）\n\n### git  revert\n\nRevert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。\n\n### git  reset\n这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br>\n如果你加上--hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。\n\n|命令      |作用域 |               常用场景           |\n|------|--|----|\n|git reset|提交层面|\t在私有分支上舍弃一些没有提交的更改|\n|git reset|\t|文件层面|\t将文件从缓存区中移除|\n|git checkout|\t提交层面|\t切换分支或查看旧版本|\n|git checkout|\t文件层面|\t舍弃工作目录中的更改|\n|git revert     |\t提交层面|\t在公共分支上回滚更改|\n\n\n+ [git好文](https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md)\n\n+ [一个有意思的学习git的网站](https://learngitbranching.js.org)\n\n","source":"_posts/git杂记.md","raw":"---\ntitle: git杂记\ndate: 2018-12-07 16:33:09\ntags: 杂记\n---\n\n不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。\n<!--more-->\n\n### git的三个区域\n\n+ 工作区，就是在编辑器里看到的那些代码\n+ 缓存区，通过git add将指定文件添加到此区域\n+ 版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。\n\n### commitID\n形如 1953***6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  --oneline\n\n### 一些常用的命令\n#### git status (gst)\n当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。\n#### git branch  \n查看本地分支已经存在的分支，当前分支带*。\n+ -r 查看远程分支\n+ dev 加分支名，创建分支dev\n+ -d dev 删除分支dev\n\n#### git checkout\n+ dev 切换到dev分支上，然后更新工作目录。\n\n+ -b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。\n\n+ commitID file\n  查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。\n\n+ commitID\n  更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。\n\n+ -b dev origin/dev\n\t将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。\n\n#### git stash\n如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。\n\n### git pull\n将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）\n\n### git  revert\n\nRevert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。\n\n### git  reset\n这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br>\n如果你加上--hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。\n\n|命令      |作用域 |               常用场景           |\n|------|--|----|\n|git reset|提交层面|\t在私有分支上舍弃一些没有提交的更改|\n|git reset|\t|文件层面|\t将文件从缓存区中移除|\n|git checkout|\t提交层面|\t切换分支或查看旧版本|\n|git checkout|\t文件层面|\t舍弃工作目录中的更改|\n|git revert     |\t提交层面|\t在公共分支上回滚更改|\n\n\n+ [git好文](https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md)\n\n+ [一个有意思的学习git的网站](https://learngitbranching.js.org)\n\n","slug":"git杂记","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrs00007hvs6gar59v6a","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。<br><a id=\"more\"></a></p>\n<h3 id=\"git的三个区域\"><a href=\"#git的三个区域\" class=\"headerlink\" title=\"git的三个区域\"></a>git的三个区域</h3><ul>\n<li>工作区，就是在编辑器里看到的那些代码</li>\n<li>缓存区，通过git add将指定文件添加到此区域</li>\n<li>版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。</li>\n</ul>\n<h3 id=\"commitID\"><a href=\"#commitID\" class=\"headerlink\" title=\"commitID\"></a>commitID</h3><p>形如 1953<em>*</em>6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  –oneline</p>\n<h3 id=\"一些常用的命令\"><a href=\"#一些常用的命令\" class=\"headerlink\" title=\"一些常用的命令\"></a>一些常用的命令</h3><h4 id=\"git-status-gst\"><a href=\"#git-status-gst\" class=\"headerlink\" title=\"git status (gst)\"></a>git status (gst)</h4><p>当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。</p>\n<h4 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h4><p>查看本地分支已经存在的分支，当前分支带*。</p>\n<ul>\n<li>-r 查看远程分支</li>\n<li>dev 加分支名，创建分支dev</li>\n<li>-d dev 删除分支dev</li>\n</ul>\n<h4 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h4><ul>\n<li><p>dev 切换到dev分支上，然后更新工作目录。</p>\n</li>\n<li><p>-b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。</p>\n</li>\n<li><p>commitID file<br>查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。</p>\n</li>\n<li><p>commitID<br>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。</p>\n</li>\n<li><p>-b dev origin/dev<br>  将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。</p>\n</li>\n</ul>\n<h4 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h4><p>如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。</p>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><p>将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）</p>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git  revert\"></a>git  revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git  reset\"></a>git  reset</h3><p>这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br><br>如果你加上–hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用域</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git reset</td>\n<td>提交层面</td>\n<td>在私有分支上舍弃一些没有提交的更改</td>\n</tr>\n<tr>\n<td>git reset</td>\n<td></td>\n<td>文件层面</td>\n<td>将文件从缓存区中移除</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>提交层面</td>\n<td>切换分支或查看旧版本</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>文件层面</td>\n<td>舍弃工作目录中的更改</td>\n</tr>\n<tr>\n<td>git revert</td>\n<td>提交层面</td>\n<td>在公共分支上回滚更改</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><a href=\"https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md\" target=\"_blank\" rel=\"noopener\">git好文</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org\" target=\"_blank\" rel=\"noopener\">一个有意思的学习git的网站</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。<br>","more":"</p>\n<h3 id=\"git的三个区域\"><a href=\"#git的三个区域\" class=\"headerlink\" title=\"git的三个区域\"></a>git的三个区域</h3><ul>\n<li>工作区，就是在编辑器里看到的那些代码</li>\n<li>缓存区，通过git add将指定文件添加到此区域</li>\n<li>版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。</li>\n</ul>\n<h3 id=\"commitID\"><a href=\"#commitID\" class=\"headerlink\" title=\"commitID\"></a>commitID</h3><p>形如 1953<em>*</em>6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  –oneline</p>\n<h3 id=\"一些常用的命令\"><a href=\"#一些常用的命令\" class=\"headerlink\" title=\"一些常用的命令\"></a>一些常用的命令</h3><h4 id=\"git-status-gst\"><a href=\"#git-status-gst\" class=\"headerlink\" title=\"git status (gst)\"></a>git status (gst)</h4><p>当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。</p>\n<h4 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h4><p>查看本地分支已经存在的分支，当前分支带*。</p>\n<ul>\n<li>-r 查看远程分支</li>\n<li>dev 加分支名，创建分支dev</li>\n<li>-d dev 删除分支dev</li>\n</ul>\n<h4 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h4><ul>\n<li><p>dev 切换到dev分支上，然后更新工作目录。</p>\n</li>\n<li><p>-b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。</p>\n</li>\n<li><p>commitID file<br>查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。</p>\n</li>\n<li><p>commitID<br>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。</p>\n</li>\n<li><p>-b dev origin/dev<br>  将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。</p>\n</li>\n</ul>\n<h4 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h4><p>如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。</p>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><p>将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）</p>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git  revert\"></a>git  revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git  reset\"></a>git  reset</h3><p>这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br><br>如果你加上–hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用域</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git reset</td>\n<td>提交层面</td>\n<td>在私有分支上舍弃一些没有提交的更改</td>\n</tr>\n<tr>\n<td>git reset</td>\n<td></td>\n<td>文件层面</td>\n<td>将文件从缓存区中移除</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>提交层面</td>\n<td>切换分支或查看旧版本</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>文件层面</td>\n<td>舍弃工作目录中的更改</td>\n</tr>\n<tr>\n<td>git revert</td>\n<td>提交层面</td>\n<td>在公共分支上回滚更改</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><a href=\"https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md\" target=\"_blank\" rel=\"noopener\">git好文</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org\" target=\"_blank\" rel=\"noopener\">一个有意思的学习git的网站</a></p>\n</li>\n</ul>"},{"title":"hexo 第一篇博文","date":"2018-01-05T04:05:36.000Z","_content":"这是生成hexo网站的第一篇文章，写一点关于hexo的东西吧。\n\n### 初始\n\n``` bash\nnpm install hexo -g #安装\nnpm update hexo -g #升级\nhexo init #初始化\n```\nMore info: [Writing](https://hexo.io/docs/writing.html)\n<!--more-->\n\n### 简写\n\n``` bash\nhexo n “name” == hexo new \"name\" #新建文章\nhexo p == hexo publish #\nhexo g == hexo generate #生成静态文件\nhexo s == hexo server #启动服务\nhexo d ==hexo deploy #部署到服务器\n```\n\nMore info: [指令](https://hexo.io/zh-cn/docs/commands.html)\n### 服务器\n\n``` bash\nhexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。\nhexo server -s #静态模式\nhexo server -p 5000 #更改端口\nhexo server -i 192.168.1.1 #自定义 IP\n```\n\n### 完成后部署\n\n``` bash\n两个命令的作用是相同的\nhexo generate --deploy\nhexo deploy --generate\n```\n\n### 模版（Scaffold）\n```bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo new [layout] <title>\nhexo new photo \"My Gallery\"\nhexo new \"Hello World\" --lang tw\n\n```\n### 写作\n\n#### 执行命令创建一篇新文章\n```bash\nhexo new page <title>\nhexo new post <title>\n```\n**布局**（Layout）有三种默认布局：post, page, draft，可以自定义布局，自定义布局和post存储位置相同,都在scaffolds文件夹里。\n\n**文件名称**\n默认以主题为文章名称，可以在配置文件中设置new_post_name 参数，改变默认的文件名称。\n:title 标题，类似的内容还有 :year :month : i_month(月份无前导0) :day :i_day\n\n\n| 变量    |   描述    |\n|---------:-----------\n| :title  |   标题    |\n| :year   | 建立的年份|\n| :month  |建立的月份  |\n\n\n\n```bash\nhexo new [layout] <title>\n```\n\n\n#### 添加文章抬头信息\n>&emsp;&emsp;hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。想要修改的话，可以打开D:\\Hexo\\scaffolds\\post.md文件在里面添加。\n\n ```bash\n title:  #文章标题\n date:  #时间，一般不用改\n categories:  #目录分类\n tags:  #标签，格式可以是[Hexo,总结]，中间用英文逗号分开\n keywords:  #文章关键词，多个关键词用英文逗号隔开\n ```\n#### 文章图片的存放\n\n>&emsp;&emsp;想要在文章中插入图片的话，可以按照Markdown语法来插入，格式为 ![图片名称](图片地址)。图片的存放有两种方式：在本地D:\\Hexo\\source\\目录下新建一个存放图片的文件夹，比如images，然后把想要插入的图片放在里面，插入图片的路径；第二种方法是把图片上传到网络，然后插入图片路径。推荐使用第二种。<br>\n　　推荐两个比较好用的:\n\n+ [图床](http://tuchuang.org/);无需注册\n+ [七牛云存储](https://portal.qiniu.com/signup?code=3lglas6pgi2qa)\n\n### 主题\n>&emsp;&emsp;使用Hexo更换主题还算方便，先使用克隆命令安装好主题，然后更改一下博客的配置文件D:\\hexo\\_config.yml里面的主题名称就好了。点击[这里](https://link.jianshu.com/?t=https://hexo.io/themes/)查看更多官方主题\n\n#### 安装主题\n&emsp;&emsp;在博客目录下右键点击Git Bash或使用终端进入文件夹，输入以下命令,以jacman主题为例\n\n```Bash\ngit clone https://github.com/wuchong/jacman.git themes/jacman\n```\n#### 启用主题\n&emsp;&emsp;修改博客目录下的_config.yml中的theme属性，将其设置为jacman。\n\n```bash\ntheme:  jacman\n```\n#### 更新主题\n&emsp;&emsp;在主题更新之前，一定要备份好主题目录下的_config.yml文件，尤其是到后面修改了很多配置之后。\n\n```Bash\ncd themes/jacman\ngit pull origin master\n```\n&emsp;&emsp;更多markdown语法点击[这里](https://www.jianshu.com/p/1e402922ee32/)\n","source":"_posts/hexoml.md","raw":"---\ntitle: hexo 第一篇博文\ndate: 2018-01-05 12:05:36\ntags: Hexo\n---\n这是生成hexo网站的第一篇文章，写一点关于hexo的东西吧。\n\n### 初始\n\n``` bash\nnpm install hexo -g #安装\nnpm update hexo -g #升级\nhexo init #初始化\n```\nMore info: [Writing](https://hexo.io/docs/writing.html)\n<!--more-->\n\n### 简写\n\n``` bash\nhexo n “name” == hexo new \"name\" #新建文章\nhexo p == hexo publish #\nhexo g == hexo generate #生成静态文件\nhexo s == hexo server #启动服务\nhexo d ==hexo deploy #部署到服务器\n```\n\nMore info: [指令](https://hexo.io/zh-cn/docs/commands.html)\n### 服务器\n\n``` bash\nhexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。\nhexo server -s #静态模式\nhexo server -p 5000 #更改端口\nhexo server -i 192.168.1.1 #自定义 IP\n```\n\n### 完成后部署\n\n``` bash\n两个命令的作用是相同的\nhexo generate --deploy\nhexo deploy --generate\n```\n\n### 模版（Scaffold）\n```bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo new [layout] <title>\nhexo new photo \"My Gallery\"\nhexo new \"Hello World\" --lang tw\n\n```\n### 写作\n\n#### 执行命令创建一篇新文章\n```bash\nhexo new page <title>\nhexo new post <title>\n```\n**布局**（Layout）有三种默认布局：post, page, draft，可以自定义布局，自定义布局和post存储位置相同,都在scaffolds文件夹里。\n\n**文件名称**\n默认以主题为文章名称，可以在配置文件中设置new_post_name 参数，改变默认的文件名称。\n:title 标题，类似的内容还有 :year :month : i_month(月份无前导0) :day :i_day\n\n\n| 变量    |   描述    |\n|---------:-----------\n| :title  |   标题    |\n| :year   | 建立的年份|\n| :month  |建立的月份  |\n\n\n\n```bash\nhexo new [layout] <title>\n```\n\n\n#### 添加文章抬头信息\n>&emsp;&emsp;hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。想要修改的话，可以打开D:\\Hexo\\scaffolds\\post.md文件在里面添加。\n\n ```bash\n title:  #文章标题\n date:  #时间，一般不用改\n categories:  #目录分类\n tags:  #标签，格式可以是[Hexo,总结]，中间用英文逗号分开\n keywords:  #文章关键词，多个关键词用英文逗号隔开\n ```\n#### 文章图片的存放\n\n>&emsp;&emsp;想要在文章中插入图片的话，可以按照Markdown语法来插入，格式为 ![图片名称](图片地址)。图片的存放有两种方式：在本地D:\\Hexo\\source\\目录下新建一个存放图片的文件夹，比如images，然后把想要插入的图片放在里面，插入图片的路径；第二种方法是把图片上传到网络，然后插入图片路径。推荐使用第二种。<br>\n　　推荐两个比较好用的:\n\n+ [图床](http://tuchuang.org/);无需注册\n+ [七牛云存储](https://portal.qiniu.com/signup?code=3lglas6pgi2qa)\n\n### 主题\n>&emsp;&emsp;使用Hexo更换主题还算方便，先使用克隆命令安装好主题，然后更改一下博客的配置文件D:\\hexo\\_config.yml里面的主题名称就好了。点击[这里](https://link.jianshu.com/?t=https://hexo.io/themes/)查看更多官方主题\n\n#### 安装主题\n&emsp;&emsp;在博客目录下右键点击Git Bash或使用终端进入文件夹，输入以下命令,以jacman主题为例\n\n```Bash\ngit clone https://github.com/wuchong/jacman.git themes/jacman\n```\n#### 启用主题\n&emsp;&emsp;修改博客目录下的_config.yml中的theme属性，将其设置为jacman。\n\n```bash\ntheme:  jacman\n```\n#### 更新主题\n&emsp;&emsp;在主题更新之前，一定要备份好主题目录下的_config.yml文件，尤其是到后面修改了很多配置之后。\n\n```Bash\ncd themes/jacman\ngit pull origin master\n```\n&emsp;&emsp;更多markdown语法点击[这里](https://www.jianshu.com/p/1e402922ee32/)\n","slug":"hexoml","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrs4000bhvs647ofhpxg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>这是生成hexo网站的第一篇文章，写一点关于hexo的东西吧。</p>\n<h3 id=\"初始\"><a href=\"#初始\" class=\"headerlink\" title=\"初始\"></a>初始</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo -g <span class=\"comment\">#安装</span></span><br><span class=\"line\">npm update hexo -g <span class=\"comment\">#升级</span></span><br><span class=\"line\">hexo init <span class=\"comment\">#初始化</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a><br><a id=\"more\"></a></p>\n<h3 id=\"简写\"><a href=\"#简写\" class=\"headerlink\" title=\"简写\"></a>简写</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n “name” == hexo new <span class=\"string\">\"name\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo p == hexo publish <span class=\"comment\">#</span></span><br><span class=\"line\">hexo g == hexo generate <span class=\"comment\">#生成静态文件</span></span><br><span class=\"line\">hexo s == hexo server <span class=\"comment\">#启动服务</span></span><br><span class=\"line\">hexo d ==hexo deploy <span class=\"comment\">#部署到服务器</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">指令</a></p>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">hexo server -s <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">hexo server -p 5000 <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">hexo server -i 192.168.1.1 <span class=\"comment\">#自定义 IP</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两个命令的作用是相同的</span><br><span class=\"line\">hexo generate --deploy</span><br><span class=\"line\">hexo deploy --generate</span><br></pre></td></tr></table></figure>\n<h3 id=\"模版（Scaffold）\"><a href=\"#模版（Scaffold）\" class=\"headerlink\" title=\"模版（Scaffold）\"></a>模版（Scaffold）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br><span class=\"line\">hexo new photo <span class=\"string\">\"My Gallery\"</span></span><br><span class=\"line\">hexo new <span class=\"string\">\"Hello World\"</span> --lang tw</span><br></pre></td></tr></table></figure>\n<h3 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h3><h4 id=\"执行命令创建一篇新文章\"><a href=\"#执行命令创建一篇新文章\" class=\"headerlink\" title=\"执行命令创建一篇新文章\"></a>执行命令创建一篇新文章</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &lt;title&gt;</span><br><span class=\"line\">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>布局</strong>（Layout）有三种默认布局：post, page, draft，可以自定义布局，自定义布局和post存储位置相同,都在scaffolds文件夹里。</p>\n<p><strong>文件名称</strong><br>默认以主题为文章名称，可以在配置文件中设置new_post_name 参数，改变默认的文件名称。<br>:title 标题，类似的内容还有 :year :month : i_month(月份无前导0) :day :i_day</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>:title</td>\n<td>标题</td>\n</tr>\n<tr>\n<td>:year</td>\n<td>建立的年份</td>\n</tr>\n<tr>\n<td>:month</td>\n<td>建立的月份</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加文章抬头信息\"><a href=\"#添加文章抬头信息\" class=\"headerlink\" title=\"添加文章抬头信息\"></a>添加文章抬头信息</h4><blockquote>\n<p>&emsp;&emsp;hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。想要修改的话，可以打开D:\\Hexo\\scaffolds\\post.md文件在里面添加。</p>\n</blockquote>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title:  <span class=\"comment\">#文章标题</span></span><br><span class=\"line\">date:  <span class=\"comment\">#时间，一般不用改</span></span><br><span class=\"line\">categories:  <span class=\"comment\">#目录分类</span></span><br><span class=\"line\">tags:  <span class=\"comment\">#标签，格式可以是[Hexo,总结]，中间用英文逗号分开</span></span><br><span class=\"line\">keywords:  <span class=\"comment\">#文章关键词，多个关键词用英文逗号隔开</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"文章图片的存放\"><a href=\"#文章图片的存放\" class=\"headerlink\" title=\"文章图片的存放\"></a>文章图片的存放</h4><blockquote>\n<p>&emsp;&emsp;想要在文章中插入图片的话，可以按照Markdown语法来插入，格式为 <img src=\"图片地址\" alt=\"图片名称\">。图片的存放有两种方式：在本地D:\\Hexo\\source\\目录下新建一个存放图片的文件夹，比如images，然后把想要插入的图片放在里面，插入图片的路径；第二种方法是把图片上传到网络，然后插入图片路径。推荐使用第二种。<br><br>　　推荐两个比较好用的:</p>\n</blockquote>\n<ul>\n<li><a href=\"http://tuchuang.org/\" target=\"_blank\" rel=\"noopener\">图床</a>;无需注册</li>\n<li><a href=\"https://portal.qiniu.com/signup?code=3lglas6pgi2qa\" target=\"_blank\" rel=\"noopener\">七牛云存储</a></li>\n</ul>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><blockquote>\n<p>&emsp;&emsp;使用Hexo更换主题还算方便，先使用克隆命令安装好主题，然后更改一下博客的配置文件D:\\hexo_config.yml里面的主题名称就好了。点击<a href=\"https://link.jianshu.com/?t=https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">这里</a>查看更多官方主题</p>\n</blockquote>\n<h4 id=\"安装主题\"><a href=\"#安装主题\" class=\"headerlink\" title=\"安装主题\"></a>安装主题</h4><p>&emsp;&emsp;在博客目录下右键点击Git Bash或使用终端进入文件夹，输入以下命令,以jacman主题为例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/wuchong/jacman.git themes/jacman</span><br></pre></td></tr></table></figure>\n<h4 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h4><p>&emsp;&emsp;修改博客目录下的_config.yml中的theme属性，将其设置为jacman。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme:  jacman</span><br></pre></td></tr></table></figure>\n<h4 id=\"更新主题\"><a href=\"#更新主题\" class=\"headerlink\" title=\"更新主题\"></a>更新主题</h4><p>&emsp;&emsp;在主题更新之前，一定要备份好主题目录下的_config.yml文件，尤其是到后面修改了很多配置之后。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> themes/jacman</span><br><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;更多markdown语法点击<a href=\"https://www.jianshu.com/p/1e402922ee32/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n","site":{"data":{}},"excerpt":"<p>这是生成hexo网站的第一篇文章，写一点关于hexo的东西吧。</p>\n<h3 id=\"初始\"><a href=\"#初始\" class=\"headerlink\" title=\"初始\"></a>初始</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo -g <span class=\"comment\">#安装</span></span><br><span class=\"line\">npm update hexo -g <span class=\"comment\">#升级</span></span><br><span class=\"line\">hexo init <span class=\"comment\">#初始化</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a><br>","more":"</p>\n<h3 id=\"简写\"><a href=\"#简写\" class=\"headerlink\" title=\"简写\"></a>简写</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n “name” == hexo new <span class=\"string\">\"name\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo p == hexo publish <span class=\"comment\">#</span></span><br><span class=\"line\">hexo g == hexo generate <span class=\"comment\">#生成静态文件</span></span><br><span class=\"line\">hexo s == hexo server <span class=\"comment\">#启动服务</span></span><br><span class=\"line\">hexo d ==hexo deploy <span class=\"comment\">#部署到服务器</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">指令</a></p>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">hexo server -s <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">hexo server -p 5000 <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">hexo server -i 192.168.1.1 <span class=\"comment\">#自定义 IP</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两个命令的作用是相同的</span><br><span class=\"line\">hexo generate --deploy</span><br><span class=\"line\">hexo deploy --generate</span><br></pre></td></tr></table></figure>\n<h3 id=\"模版（Scaffold）\"><a href=\"#模版（Scaffold）\" class=\"headerlink\" title=\"模版（Scaffold）\"></a>模版（Scaffold）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br><span class=\"line\">hexo new photo <span class=\"string\">\"My Gallery\"</span></span><br><span class=\"line\">hexo new <span class=\"string\">\"Hello World\"</span> --lang tw</span><br></pre></td></tr></table></figure>\n<h3 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h3><h4 id=\"执行命令创建一篇新文章\"><a href=\"#执行命令创建一篇新文章\" class=\"headerlink\" title=\"执行命令创建一篇新文章\"></a>执行命令创建一篇新文章</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &lt;title&gt;</span><br><span class=\"line\">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>布局</strong>（Layout）有三种默认布局：post, page, draft，可以自定义布局，自定义布局和post存储位置相同,都在scaffolds文件夹里。</p>\n<p><strong>文件名称</strong><br>默认以主题为文章名称，可以在配置文件中设置new_post_name 参数，改变默认的文件名称。<br>:title 标题，类似的内容还有 :year :month : i_month(月份无前导0) :day :i_day</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>:title</td>\n<td>标题</td>\n</tr>\n<tr>\n<td>:year</td>\n<td>建立的年份</td>\n</tr>\n<tr>\n<td>:month</td>\n<td>建立的月份</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加文章抬头信息\"><a href=\"#添加文章抬头信息\" class=\"headerlink\" title=\"添加文章抬头信息\"></a>添加文章抬头信息</h4><blockquote>\n<p>&emsp;&emsp;hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。想要修改的话，可以打开D:\\Hexo\\scaffolds\\post.md文件在里面添加。</p>\n</blockquote>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title:  <span class=\"comment\">#文章标题</span></span><br><span class=\"line\">date:  <span class=\"comment\">#时间，一般不用改</span></span><br><span class=\"line\">categories:  <span class=\"comment\">#目录分类</span></span><br><span class=\"line\">tags:  <span class=\"comment\">#标签，格式可以是[Hexo,总结]，中间用英文逗号分开</span></span><br><span class=\"line\">keywords:  <span class=\"comment\">#文章关键词，多个关键词用英文逗号隔开</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"文章图片的存放\"><a href=\"#文章图片的存放\" class=\"headerlink\" title=\"文章图片的存放\"></a>文章图片的存放</h4><blockquote>\n<p>&emsp;&emsp;想要在文章中插入图片的话，可以按照Markdown语法来插入，格式为 <img src=\"图片地址\" alt=\"图片名称\">。图片的存放有两种方式：在本地D:\\Hexo\\source\\目录下新建一个存放图片的文件夹，比如images，然后把想要插入的图片放在里面，插入图片的路径；第二种方法是把图片上传到网络，然后插入图片路径。推荐使用第二种。<br><br>　　推荐两个比较好用的:</p>\n</blockquote>\n<ul>\n<li><a href=\"http://tuchuang.org/\" target=\"_blank\" rel=\"noopener\">图床</a>;无需注册</li>\n<li><a href=\"https://portal.qiniu.com/signup?code=3lglas6pgi2qa\" target=\"_blank\" rel=\"noopener\">七牛云存储</a></li>\n</ul>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><blockquote>\n<p>&emsp;&emsp;使用Hexo更换主题还算方便，先使用克隆命令安装好主题，然后更改一下博客的配置文件D:\\hexo_config.yml里面的主题名称就好了。点击<a href=\"https://link.jianshu.com/?t=https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">这里</a>查看更多官方主题</p>\n</blockquote>\n<h4 id=\"安装主题\"><a href=\"#安装主题\" class=\"headerlink\" title=\"安装主题\"></a>安装主题</h4><p>&emsp;&emsp;在博客目录下右键点击Git Bash或使用终端进入文件夹，输入以下命令,以jacman主题为例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/wuchong/jacman.git themes/jacman</span><br></pre></td></tr></table></figure>\n<h4 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h4><p>&emsp;&emsp;修改博客目录下的_config.yml中的theme属性，将其设置为jacman。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme:  jacman</span><br></pre></td></tr></table></figure>\n<h4 id=\"更新主题\"><a href=\"#更新主题\" class=\"headerlink\" title=\"更新主题\"></a>更新主题</h4><p>&emsp;&emsp;在主题更新之前，一定要备份好主题目录下的_config.yml文件，尤其是到后面修改了很多配置之后。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> themes/jacman</span><br><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;更多markdown语法点击<a href=\"https://www.jianshu.com/p/1e402922ee32/\" target=\"_blank\" rel=\"noopener\">这里</a></p>"},{"title":"VueComponent（一）","date":"2018-01-12T02:50:15.000Z","_content":"\n>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重\n>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有\n>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。\n\n<!--more-->\n### 组件注册的方式\n\n#### 全局注册\n\n用法如下：\n```Bash\n// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)\n// var MyComponent = Vue.extend({\n// 　template : '<p>我是全局注册组件</p>',\n//     data () {\n//          return {\n//               message: 'hello world'\n//             }\n// })\n// vue.componnet('my-component', MyComponnet)\n\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n```\n\n&emsp;&emsp;全局注册后，任何Vue实例都可以使用。\n#### 局部注册\n\n```Bash\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\nnew Vue({\n  el: '#app',\n  componnets: {\n    child: 'child'\n  }\n})\n```\n\n&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。\n\n### 要求\n\n#### 关于模板\ntemplate的DOM结构必须被一个元素包含。下面的情况是不允许的。\n```bash\ntemplate: `<div>这是一个局部的自定义组件，只能在当前Vue实例中使用</div>\n            <button>hello</button>`,\n```\n#### 组件中的data\n\n可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br>\nJS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br>\n```bash\n<div id=\"app\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 };\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data;\n  }\n});\nnew Vue({\n  el: '#app'\n});\n</script>\n```\n\n\n由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：\n\n```bash\ndata: function () {\n  return {\n    counter: 0\n  }\n}\n```\n\n#### html限制\n\nVue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，\n\n```bash\n<div id=\"app\">\n  <table>\n      <tbody is = \"my-component\"></tbody>\n  </table>\n\n</div>\n```\n```bash\nVue.component('simple-counter', {\n  template: '<div>这里是组件的内容</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n\n```\nt-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br>\n应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：\n\n  + JavaScript 内联模版字符串\n  + .vue 组件\n  + x-template\n\n\n其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。\n\n### Props\n\n在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：\n + 字符串数组\n + 对象\n\n代码如下：\n```bash\nVue.component('mycomponent',{\n    template: '<div>这是一个自定义组件,父组件传给我的内容是：{{myMessage}}</div>',\n    props: ['myMessage'],\n    data () {\n      return {\n        message: 'hello world'\n      }\n    }\n  })\n```\n然后调用该组件\n\n```bash\n<div id=\"app\">\n    <mycomponent my-message=\"hello\"></mycomponent>\n</div>\n```\n由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=\"hello\"。\n<br>\n有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：\n```bash\n<div id=\"app\">\n  <input type=\"text\" v-moddel=\"parentMessage\">\n  <my-component :message=\"parentMessage\"></my-componnet>\n</div>\n<script>\nVue.component('my-componentr', {\n  template: '<div>{{message}}</div>',\n  props:['message']\n});\nnew Vue({\n  el: '#app',\n  data:{\n    parentMessage:''\n  }\n});\n</script>\n```\n这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。\n<br>\n要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。\n","source":"_posts/VueInAction2.md","raw":"---\ntitle: VueComponent（一）\ndate: 2018-01-12 10:50:15\ntags: vue\ncategories: 学习\n---\n\n>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重\n>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有\n>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。\n\n<!--more-->\n### 组件注册的方式\n\n#### 全局注册\n\n用法如下：\n```Bash\n// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)\n// var MyComponent = Vue.extend({\n// 　template : '<p>我是全局注册组件</p>',\n//     data () {\n//          return {\n//               message: 'hello world'\n//             }\n// })\n// vue.componnet('my-component', MyComponnet)\n\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n```\n\n&emsp;&emsp;全局注册后，任何Vue实例都可以使用。\n#### 局部注册\n\n```Bash\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\nnew Vue({\n  el: '#app',\n  componnets: {\n    child: 'child'\n  }\n})\n```\n\n&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。\n\n### 要求\n\n#### 关于模板\ntemplate的DOM结构必须被一个元素包含。下面的情况是不允许的。\n```bash\ntemplate: `<div>这是一个局部的自定义组件，只能在当前Vue实例中使用</div>\n            <button>hello</button>`,\n```\n#### 组件中的data\n\n可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br>\nJS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br>\n```bash\n<div id=\"app\">\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n  <simple-counter></simple-counter>\n</div>\n<script>\nvar data = { counter: 0 };\nVue.component('simple-counter', {\n  template: '<button v-on:click=\"counter += 1\">{{ counter }}</button>',\n  data: function () {\n    return data;\n  }\n});\nnew Vue({\n  el: '#app'\n});\n</script>\n```\n\n\n由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：\n\n```bash\ndata: function () {\n  return {\n    counter: 0\n  }\n}\n```\n\n#### html限制\n\nVue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，\n\n```bash\n<div id=\"app\">\n  <table>\n      <tbody is = \"my-component\"></tbody>\n  </table>\n\n</div>\n```\n```bash\nVue.component('simple-counter', {\n  template: '<div>这里是组件的内容</div>'\n})\n\nnew Vue({\n  el: '#app'\n})\n\n```\nt-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br>\n应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：\n\n  + JavaScript 内联模版字符串\n  + .vue 组件\n  + x-template\n\n\n其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。\n\n### Props\n\n在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：\n + 字符串数组\n + 对象\n\n代码如下：\n```bash\nVue.component('mycomponent',{\n    template: '<div>这是一个自定义组件,父组件传给我的内容是：{{myMessage}}</div>',\n    props: ['myMessage'],\n    data () {\n      return {\n        message: 'hello world'\n      }\n    }\n  })\n```\n然后调用该组件\n\n```bash\n<div id=\"app\">\n    <mycomponent my-message=\"hello\"></mycomponent>\n</div>\n```\n由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=\"hello\"。\n<br>\n有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：\n```bash\n<div id=\"app\">\n  <input type=\"text\" v-moddel=\"parentMessage\">\n  <my-component :message=\"parentMessage\"></my-componnet>\n</div>\n<script>\nVue.component('my-componentr', {\n  template: '<div>{{message}}</div>',\n  props:['message']\n});\nnew Vue({\n  el: '#app',\n  data:{\n    parentMessage:''\n  }\n});\n</script>\n```\n这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。\n<br>\n要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。\n","slug":"VueInAction2","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrs7000chvs68ssmq5zw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重<br>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有<br>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"组件注册的方式\"><a href=\"#组件注册的方式\" class=\"headerlink\" title=\"组件注册的方式\"></a>组件注册的方式</h3><h4 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h4><p>用法如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)</span><br><span class=\"line\">// var MyComponent = Vue.extend(&#123;</span><br><span class=\"line\">// 　template : <span class=\"string\">'&lt;p&gt;我是全局注册组件&lt;/p&gt;'</span>,</span><br><span class=\"line\">//     <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">//          <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">//               message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">//             &#125;</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">// vue.componnet(<span class=\"string\">'my-component'</span>, MyComponnet)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;全局注册后，任何Vue实例都可以使用。</p>\n<h4 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Child = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  componnets: &#123;</span><br><span class=\"line\">    child: <span class=\"string\">'child'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><h4 id=\"关于模板\"><a href=\"#关于模板\" class=\"headerlink\" title=\"关于模板\"></a>关于模板</h4><p>template的DOM结构必须被一个元素包含。下面的情况是不允许的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `&lt;div&gt;这是一个局部的自定义组件，只能在当前Vue实例中使用&lt;/div&gt;</span><br><span class=\"line\">            &lt;button&gt;hello&lt;/button&gt;`,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"组件中的data\"><a href=\"#组件中的data\" class=\"headerlink\" title=\"组件中的data\"></a>组件中的data</h4><p>可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br><br>JS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var data = &#123; counter: 0 &#125;;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">    counter: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"html限制\"><a href=\"#html限制\" class=\"headerlink\" title=\"html限制\"></a>html限制</h4><p>Vue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;table&gt;</span><br><span class=\"line\">      &lt;tbody is = <span class=\"string\">\"my-component\"</span>&gt;&lt;/tbody&gt;</span><br><span class=\"line\">  &lt;/table&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;这里是组件的内容&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>t-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br><br>应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：</p>\n<ul>\n<li>JavaScript 内联模版字符串</li>\n<li>.vue 组件</li>\n<li>x-template</li>\n</ul>\n<p>其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。</p>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p>在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：</p>\n<ul>\n<li>字符串数组</li>\n<li>对象</li>\n</ul>\n<p>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycomponent'</span>,&#123;</span><br><span class=\"line\">    template: <span class=\"string\">'&lt;div&gt;这是一个自定义组件,父组件传给我的内容是：&#123;&#123;myMessage&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">    props: [<span class=\"string\">'myMessage'</span>],</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">        message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>然后调用该组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;mycomponent my-message=<span class=\"string\">\"hello\"</span>&gt;&lt;/mycomponent&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=”hello”。<br><br><br>有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-moddel=<span class=\"string\">\"parentMessage\"</span>&gt;</span><br><span class=\"line\">  &lt;my-component :message=<span class=\"string\">\"parentMessage\"</span>&gt;&lt;/my-componnet&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-componentr'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">  props:[<span class=\"string\">'message'</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    parentMessage:<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。<br><br><br>要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重<br>用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有<br>些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。</p>\n</blockquote>","more":"<h3 id=\"组件注册的方式\"><a href=\"#组件注册的方式\" class=\"headerlink\" title=\"组件注册的方式\"></a>组件注册的方式</h3><h4 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h4><p>用法如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要注册一个全局组件，你可以使用 Vue.component(tagName, options)</span><br><span class=\"line\">// var MyComponent = Vue.extend(&#123;</span><br><span class=\"line\">// 　template : <span class=\"string\">'&lt;p&gt;我是全局注册组件&lt;/p&gt;'</span>,</span><br><span class=\"line\">//     <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">//          <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">//               message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">//             &#125;</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">// vue.componnet(<span class=\"string\">'my-component'</span>, MyComponnet)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;全局注册后，任何Vue实例都可以使用。</p>\n<h4 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Child = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  componnets: &#123;</span><br><span class=\"line\">    child: <span class=\"string\">'child'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用components注册，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件。使组件可以嵌套。</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><h4 id=\"关于模板\"><a href=\"#关于模板\" class=\"headerlink\" title=\"关于模板\"></a>关于模板</h4><p>template的DOM结构必须被一个元素包含。下面的情况是不允许的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `&lt;div&gt;这是一个局部的自定义组件，只能在当前Vue实例中使用&lt;/div&gt;</span><br><span class=\"line\">            &lt;button&gt;hello&lt;/button&gt;`,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"组件中的data\"><a href=\"#组件中的data\" class=\"headerlink\" title=\"组件中的data\"></a>组件中的data</h4><p>可以看出，注册组件时传入的配置和创建Vue实例时差不多，但也有不同，其中一个就是<strong>data</strong>属性必须是一个函数。然后将数据return出去。<br><br>JS对象是引用类型，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方都可以修改它。代码如下：<br><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var data = &#123; counter: 0 &#125;;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>由于这三个组件实例共享了同一个 data 对象，因此递增一个counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">    counter: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"html限制\"><a href=\"#html限制\" class=\"headerlink\" title=\"html限制\"></a>html限制</h4><p>Vue组件的模板在某些情况下，会受到HTML的限制，比如在table内规定只允许td,th等这些表格元素，所以直接在table里直接使用组件是无效的。这种情况下， 特殊的属性来挂载组件，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;table&gt;</span><br><span class=\"line\">      &lt;tbody is = <span class=\"string\">\"my-component\"</span>&gt;&lt;/tbody&gt;</span><br><span class=\"line\">  &lt;/table&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'simple-counter'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;这里是组件的内容&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>t-body在渲染时，会被替代成组件的内容。常见的限制元素还有ul,ol,select。<br><br>应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：</p>\n<ul>\n<li>JavaScript 内联模版字符串</li>\n<li>.vue 组件</li>\n<li>x-template</li>\n</ul>\n<p>其中，前两个模板都不是Vue官方推荐的，所以一般情况下，只有单文件组件.vue可以忽略这种情况。</p>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p>在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是以下两种：</p>\n<ul>\n<li>字符串数组</li>\n<li>对象</li>\n</ul>\n<p>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycomponent'</span>,&#123;</span><br><span class=\"line\">    template: <span class=\"string\">'&lt;div&gt;这是一个自定义组件,父组件传给我的内容是：&#123;&#123;myMessage&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">    props: [<span class=\"string\">'myMessage'</span>],</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">data</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">        message: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>然后调用该组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;mycomponent my-message=<span class=\"string\">\"hello\"</span>&gt;&lt;/mycomponent&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=”hello”。<br><br><br>有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这是可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">  &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-moddel=<span class=\"string\">\"parentMessage\"</span>&gt;</span><br><span class=\"line\">  &lt;my-component :message=<span class=\"string\">\"parentMessage\"</span>&gt;&lt;/my-componnet&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'my-componentr'</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class=\"line\">  props:[<span class=\"string\">'message'</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    parentMessage:<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里的v-model绑定了父级数据parentMessage，当输入框任意输入是，子组件接受的数据会实时响应。<br><br><br>要注意的是：如果要直接传递数字，布尔值，数组，对象，而且不用v-bind，传递的仅仅是字符串。</p>"},{"title":"friendships","date":"2018-05-23T04:03:10.000Z","_content":"\n发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br>\n\n之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。\n<!--more-->\n<div style=\"width:100%;\">\n<div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\">\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n\n</div>\n</div>\n","source":"_posts/friendships.md","raw":"---\ntitle: friendships\ndate: 2018-05-23 12:03:10\ntags: 指弹\ncategories: 指弹\n---\n\n发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br>\n\n之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。\n<!--more-->\n<div style=\"width:100%;\">\n<div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\">\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n\n</div>\n</div>\n","slug":"friendships","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsb000ghvs6n0zwtn9l","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br></p>\n<p>之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。<br><a id=\"more\"></a></p>\n<div style=\"width:100%;\"><br><div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\"><br><div id=\"dplayer0\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br><br></div><br></div>\n","site":{"data":{}},"excerpt":"<p>发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br></p>\n<p>之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。<br>","more":"</p>\n<div style=\"width:100%;\"><br><div style=\"transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;\"><br><div id=\"dplayer0\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br><br></div><br></div>"},{"title":"instanceof","date":"2018-01-16T03:35:29.000Z","_content":"\n>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。\n\n\n<!--more-->\n\n#### 说明\n\n\n是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。\n\n<weight>expression instanceof class</weight><br>expression和class都是必选项。\n\n\n#### 注意\n关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，\n>VM1621:3 Uncaught TypeError: arguments.push is not a function\n\narguments instanceof Array，返回值是false\n这时得知arguments是一个Array-like对象，并不是真的数组。\n\n另外<br>\n\nclass应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得\n\n```bash\nconsole.log(typeof window); //Object\nconsole.log(window instanceof Object); //true\n```\n网上很多文章都说window instanceof Object返回是false，不知为啥。\n\n#### 常规用法\n\n通常用来判断一个实例是否属于某种类型。\n\n```bash\nfunction Foo(){}\nvar foo = new Foo();\nconsole.log(foo instanceof Foo)//true\n```\n更重要的是用来判断继承关系。\n\n```bash\n\nfunction A() {}\nfunction B() {}\n\nB.prototype = new A(); //原型继承\nvar b = new B();\n\nconsole.log(b instanceof B); //true\nconsole.log(b instanceof A); //true\n\n```\n多层继承关系依然适用。\n\n#### 复杂用法\n```bash\n\nconsole.log(Object instanceof Object);//true\nconsole.log(Function instanceof Function);//true\nconsole.log(Number instanceof Number);//false\nconsole.log(String instanceof String);//false\n\nconsole.log(Function instanceof Object);//true\n\nconsole.log(Foo instanceof Function);//true\nconsole.log(Foo instanceof Foo);//false\n\n```\n参考网上的文章，就是[这一篇](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/)，得知要从两个方面着手：\n + 语言规范是怎么定义instanceof的。\n + Javascript原型继承机制。\n\n #### ECMAScript-262 edition 3 中 instanceof 运算符的定义\n\n 定义如下：\n ```bash\n 11.8.6 The instanceof operator\n The production RelationalExpression:\n     RelationalExpression instanceof ShiftExpression is evaluated as follows:\n\n 1. Evaluate RelationalExpression.\n 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)\n 3. Evaluate ShiftExpression.\n 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)\n 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，\n                                                                //抛出异常\n /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，\n在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。\n所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */\n 6. If Result(4) does not have a [[HasInstance]] method,\n   throw a TypeError exception.\n // 相当于这样调用：Result(4).[[HasInstance]](Result(2))\n 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).\n 8. Return Result(7).\n\n // 相关的 HasInstance 方法定义\n 15.3.5.3 [[HasInstance]] (V)\n Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)\n When the [[HasInstance]] method of F is called with value V,\n     the following steps are taken:\n 1. If V is not an object, return false.// 如果 V 不是 object，直接返回 false\n 2. Call the [[Get]] method of F with property name \"prototype\".// 用 [[Get]] 方法取\n                                                                // F 的 prototype 属性\n 3. Let O be Result(2).//O = F.[[Get]](\"prototype\")\n 4. If O is not an object, throw a TypeError exception.\n 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]\n 6. If V is null, return false.\n // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 true；否则，到 Step 8 返回 Step 5 继续循环\n 7. If O and V refer to the same object or if they refer to objects\n   joined to each other (section 13.1.2), return true.\n 8. Go to step 5.\n\n ```\n上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：\n```bash\n\nfunction instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n var O = R.prototype;// 取 R 的显示原型\n L = L.__proto__;// 取 L 的隐式原型\n while (true) {\n   if (L === null)\n     return false;\n   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true\n     return true;\n   L = L.__proto__;\n }\n}\n```\n当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n","source":"_posts/instanceof.md","raw":"---\ntitle: instanceof\ndate: 2018-01-16 11:35:29\ntags: javascript\ncategories: 学习\n---\n\n>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。\n\n\n<!--more-->\n\n#### 说明\n\n\n是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。\n\n<weight>expression instanceof class</weight><br>expression和class都是必选项。\n\n\n#### 注意\n关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，\n>VM1621:3 Uncaught TypeError: arguments.push is not a function\n\narguments instanceof Array，返回值是false\n这时得知arguments是一个Array-like对象，并不是真的数组。\n\n另外<br>\n\nclass应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得\n\n```bash\nconsole.log(typeof window); //Object\nconsole.log(window instanceof Object); //true\n```\n网上很多文章都说window instanceof Object返回是false，不知为啥。\n\n#### 常规用法\n\n通常用来判断一个实例是否属于某种类型。\n\n```bash\nfunction Foo(){}\nvar foo = new Foo();\nconsole.log(foo instanceof Foo)//true\n```\n更重要的是用来判断继承关系。\n\n```bash\n\nfunction A() {}\nfunction B() {}\n\nB.prototype = new A(); //原型继承\nvar b = new B();\n\nconsole.log(b instanceof B); //true\nconsole.log(b instanceof A); //true\n\n```\n多层继承关系依然适用。\n\n#### 复杂用法\n```bash\n\nconsole.log(Object instanceof Object);//true\nconsole.log(Function instanceof Function);//true\nconsole.log(Number instanceof Number);//false\nconsole.log(String instanceof String);//false\n\nconsole.log(Function instanceof Object);//true\n\nconsole.log(Foo instanceof Function);//true\nconsole.log(Foo instanceof Foo);//false\n\n```\n参考网上的文章，就是[这一篇](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/)，得知要从两个方面着手：\n + 语言规范是怎么定义instanceof的。\n + Javascript原型继承机制。\n\n #### ECMAScript-262 edition 3 中 instanceof 运算符的定义\n\n 定义如下：\n ```bash\n 11.8.6 The instanceof operator\n The production RelationalExpression:\n     RelationalExpression instanceof ShiftExpression is evaluated as follows:\n\n 1. Evaluate RelationalExpression.\n 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)\n 3. Evaluate ShiftExpression.\n 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)\n 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，\n                                                                //抛出异常\n /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，\n在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。\n所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */\n 6. If Result(4) does not have a [[HasInstance]] method,\n   throw a TypeError exception.\n // 相当于这样调用：Result(4).[[HasInstance]](Result(2))\n 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).\n 8. Return Result(7).\n\n // 相关的 HasInstance 方法定义\n 15.3.5.3 [[HasInstance]] (V)\n Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)\n When the [[HasInstance]] method of F is called with value V,\n     the following steps are taken:\n 1. If V is not an object, return false.// 如果 V 不是 object，直接返回 false\n 2. Call the [[Get]] method of F with property name \"prototype\".// 用 [[Get]] 方法取\n                                                                // F 的 prototype 属性\n 3. Let O be Result(2).//O = F.[[Get]](\"prototype\")\n 4. If O is not an object, throw a TypeError exception.\n 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]\n 6. If V is null, return false.\n // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 true；否则，到 Step 8 返回 Step 5 继续循环\n 7. If O and V refer to the same object or if they refer to objects\n   joined to each other (section 13.1.2), return true.\n 8. Go to step 5.\n\n ```\n上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：\n```bash\n\nfunction instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n var O = R.prototype;// 取 R 的显示原型\n L = L.__proto__;// 取 L 的隐式原型\n while (true) {\n   if (L === null)\n     return false;\n   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true\n     return true;\n   L = L.__proto__;\n }\n}\n```\n当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n","slug":"instanceof","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsf000jhvs6a608txmu","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。</p>\n<p><weight>expression instanceof class</weight><br>expression和class都是必选项。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，</p>\n<blockquote>\n<p>VM1621:3 Uncaught TypeError: arguments.push is not a function</p>\n</blockquote>\n<p>arguments instanceof Array，返回值是false<br>这时得知arguments是一个Array-like对象，并不是真的数组。</p>\n<p>另外<br></p>\n<p>class应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(typeof window); //Object</span><br><span class=\"line\">console.log(window instanceof Object); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>网上很多文章都说window instanceof Object返回是false，不知为啥。</p>\n<h4 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h4><p>通常用来判断一个实例是否属于某种类型。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">console.log(foo instanceof Foo)//<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>更重要的是用来判断继承关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = new A(); //原型继承</span><br><span class=\"line\">var b = new B();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b instanceof B); //<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(b instanceof A); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>多层继承关系依然适用。</p>\n<h4 id=\"复杂用法\"><a href=\"#复杂用法\" class=\"headerlink\" title=\"复杂用法\"></a>复杂用法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">console.log(Object instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Function instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Number instanceof Number);//<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(String instanceof String);//<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Foo instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Foo instanceof Foo);//<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>参考网上的文章，就是<a href=\"https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\" target=\"_blank\" rel=\"noopener\">这一篇</a>，得知要从两个方面着手：</p>\n<ul>\n<li>语言规范是怎么定义instanceof的。</li>\n<li><p>Javascript原型继承机制。</p>\n<h4 id=\"ECMAScript-262-edition-3-中-instanceof-运算符的定义\"><a href=\"#ECMAScript-262-edition-3-中-instanceof-运算符的定义\" class=\"headerlink\" title=\"ECMAScript-262 edition 3 中 instanceof 运算符的定义\"></a>ECMAScript-262 edition 3 中 instanceof 运算符的定义</h4><p>定义如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 11.8.6 The instanceof operator</span><br><span class=\"line\"> The production RelationalExpression:</span><br><span class=\"line\">     RelationalExpression instanceof ShiftExpression is evaluated as follows:</span><br><span class=\"line\"></span><br><span class=\"line\"> 1. Evaluate RelationalExpression.</span><br><span class=\"line\"> 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)</span><br><span class=\"line\"> 3. Evaluate ShiftExpression.</span><br><span class=\"line\"> 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)</span><br><span class=\"line\"> 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，</span><br><span class=\"line\">                                                                //抛出异常</span><br><span class=\"line\"> /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，</span><br><span class=\"line\">在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。</span><br><span class=\"line\">所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */</span><br><span class=\"line\"> 6. If Result(4) does not have a [[HasInstance]] method,</span><br><span class=\"line\">   throw a TypeError exception.</span><br><span class=\"line\"> // 相当于这样调用：Result(4).[[HasInstance]](Result(2))</span><br><span class=\"line\"> 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).</span><br><span class=\"line\"> 8. Return Result(7).</span><br><span class=\"line\"></span><br><span class=\"line\"> // 相关的 HasInstance 方法定义</span><br><span class=\"line\"> 15.3.5.3 [[HasInstance]] (V)</span><br><span class=\"line\"> Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)</span><br><span class=\"line\"> When the [[HasInstance]] method of F is called with value V,</span><br><span class=\"line\">     the following steps are taken:</span><br><span class=\"line\"> 1. If V is not an object, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.// 如果 V 不是 object，直接返回 <span class=\"literal\">false</span></span><br><span class=\"line\"> 2. Call the [[Get]] method of F with property name <span class=\"string\">\"prototype\"</span>.// 用 [[Get]] 方法取</span><br><span class=\"line\">                                                                // F 的 prototype 属性</span><br><span class=\"line\"> 3. Let O be Result(2).//O = F.[[Get]](<span class=\"string\">\"prototype\"</span>)</span><br><span class=\"line\"> 4. If O is not an object, throw a TypeError exception.</span><br><span class=\"line\"> 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]</span><br><span class=\"line\"> 6. If V is null, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.</span><br><span class=\"line\"> // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 <span class=\"literal\">true</span>；否则，到 Step 8 返回 Step 5 继续循环</span><br><span class=\"line\"> 7. If O and V refer to the same object or <span class=\"keyword\">if</span> they refer to objects</span><br><span class=\"line\">   joined to each other (section 13.1.2), <span class=\"built_in\">return</span> <span class=\"literal\">true</span>.</span><br><span class=\"line\"> 8. Go to step 5.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class=\"line\"> var O = R.prototype;// 取 R 的显示原型</span><br><span class=\"line\"> L = L.__proto__;// 取 L 的隐式原型</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (L === null)</span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (O === L)// 这里重点：当 O 严格等于 L 时，返回 <span class=\"literal\">true</span></span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   L = L.__proto__;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。尽管它的用法不如typeof灵活，但是当typeof返回值是Object时，instanceof还是挺有用的，常用来判断继承关系。</p>\n</blockquote>","more":"<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>是一个二元运算符，返回的是一个Boolean值，指出对象是否是特定类的一个实例。</p>\n<p><weight>expression instanceof class</weight><br>expression和class都是必选项。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>关于function的arguments，一开始以为它是一个数组，因为它可以通过索引arguments[i],来访问参数列表，后来在使用push等方法时发现报错，</p>\n<blockquote>\n<p>VM1621:3 Uncaught TypeError: arguments.push is not a function</p>\n</blockquote>\n<p>arguments instanceof Array，返回值是false<br>这时得知arguments是一个Array-like对象，并不是真的数组。</p>\n<p>另外<br></p>\n<p>class应该是js语法层面的bject，不应该是Dom对象，然而亲自尝试得</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(typeof window); //Object</span><br><span class=\"line\">console.log(window instanceof Object); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>网上很多文章都说window instanceof Object返回是false，不知为啥。</p>\n<h4 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h4><p>通常用来判断一个实例是否属于某种类型。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">console.log(foo instanceof Foo)//<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>更重要的是用来判断继承关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = new A(); //原型继承</span><br><span class=\"line\">var b = new B();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b instanceof B); //<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(b instanceof A); //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>多层继承关系依然适用。</p>\n<h4 id=\"复杂用法\"><a href=\"#复杂用法\" class=\"headerlink\" title=\"复杂用法\"></a>复杂用法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">console.log(Object instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Function instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Number instanceof Number);//<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(String instanceof String);//<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function instanceof Object);//<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Foo instanceof Function);//<span class=\"literal\">true</span></span><br><span class=\"line\">console.log(Foo instanceof Foo);//<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>参考网上的文章，就是<a href=\"https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\" target=\"_blank\" rel=\"noopener\">这一篇</a>，得知要从两个方面着手：</p>\n<ul>\n<li>语言规范是怎么定义instanceof的。</li>\n<li><p>Javascript原型继承机制。</p>\n<h4 id=\"ECMAScript-262-edition-3-中-instanceof-运算符的定义\"><a href=\"#ECMAScript-262-edition-3-中-instanceof-运算符的定义\" class=\"headerlink\" title=\"ECMAScript-262 edition 3 中 instanceof 运算符的定义\"></a>ECMAScript-262 edition 3 中 instanceof 运算符的定义</h4><p>定义如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 11.8.6 The instanceof operator</span><br><span class=\"line\"> The production RelationalExpression:</span><br><span class=\"line\">     RelationalExpression instanceof ShiftExpression is evaluated as follows:</span><br><span class=\"line\"></span><br><span class=\"line\"> 1. Evaluate RelationalExpression.</span><br><span class=\"line\"> 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)</span><br><span class=\"line\"> 3. Evaluate ShiftExpression.</span><br><span class=\"line\"> 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)</span><br><span class=\"line\"> 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，</span><br><span class=\"line\">                                                                //抛出异常</span><br><span class=\"line\"> /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，</span><br><span class=\"line\">在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。</span><br><span class=\"line\">所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */</span><br><span class=\"line\"> 6. If Result(4) does not have a [[HasInstance]] method,</span><br><span class=\"line\">   throw a TypeError exception.</span><br><span class=\"line\"> // 相当于这样调用：Result(4).[[HasInstance]](Result(2))</span><br><span class=\"line\"> 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).</span><br><span class=\"line\"> 8. Return Result(7).</span><br><span class=\"line\"></span><br><span class=\"line\"> // 相关的 HasInstance 方法定义</span><br><span class=\"line\"> 15.3.5.3 [[HasInstance]] (V)</span><br><span class=\"line\"> Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)</span><br><span class=\"line\"> When the [[HasInstance]] method of F is called with value V,</span><br><span class=\"line\">     the following steps are taken:</span><br><span class=\"line\"> 1. If V is not an object, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.// 如果 V 不是 object，直接返回 <span class=\"literal\">false</span></span><br><span class=\"line\"> 2. Call the [[Get]] method of F with property name <span class=\"string\">\"prototype\"</span>.// 用 [[Get]] 方法取</span><br><span class=\"line\">                                                                // F 的 prototype 属性</span><br><span class=\"line\"> 3. Let O be Result(2).//O = F.[[Get]](<span class=\"string\">\"prototype\"</span>)</span><br><span class=\"line\"> 4. If O is not an object, throw a TypeError exception.</span><br><span class=\"line\"> 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]</span><br><span class=\"line\"> 6. If V is null, <span class=\"built_in\">return</span> <span class=\"literal\">false</span>.</span><br><span class=\"line\"> // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 <span class=\"literal\">true</span>；否则，到 Step 8 返回 Step 5 继续循环</span><br><span class=\"line\"> 7. If O and V refer to the same object or <span class=\"keyword\">if</span> they refer to objects</span><br><span class=\"line\">   joined to each other (section 13.1.2), <span class=\"built_in\">return</span> <span class=\"literal\">true</span>.</span><br><span class=\"line\"> 8. Go to step 5.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class=\"line\"> var O = R.prototype;// 取 R 的显示原型</span><br><span class=\"line\"> L = L.__proto__;// 取 L 的隐式原型</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (L === null)</span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (O === L)// 这里重点：当 O 严格等于 L 时，返回 <span class=\"literal\">true</span></span><br><span class=\"line\">     <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   L = L.__proto__;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当当当当，BB一大片，这才是精华。其实判断继承关系，搞懂下面这张图就ok。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt=\"\"></p>"},{"title":"内存管理","date":"2018-03-09T16:24:22.000Z","_content":"\n>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。\n\n\n### 所有之前\n\n```bash\nvar a = {n:1};\nvar b = a;\na.x = a ={n:2};\nconsole.log(a.x);\nconsole.log(b.x);\n```\n\n<!--more-->\n在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。\n众所周知，js在微观上(以代码块为单位)是先定义，再执行的。\n+ 第一行，将{n:1}对象所在的内存地址，存到变量a；\n+ 第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。\n+ 第三行，比较麻烦，js有意思的地方(坑)就在这。\n    + 按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。\n    + 接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。\n    + a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。\n+ 于是乎，结果就是undefined  {n:2}。\n\n之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。\nok，开始BB....\n### 内存模型\njs中内存空间，大致分为三类：\n+ 常量池：保存着诸如数字，字符的常量。\n+ 栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。\n### 内存生命周期\njs(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：\n#### 1.分配内存\n分配内存往往意味着新的'值(包括变量，数字，字符，对象等)'的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：\n```bash\nvar a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里\n\nvar b = 'laalal'; //给字符串分配内存\n\nvar obj ={\n  n:1,\n  x:2\n};//给对象分配内存\n\nfunction C(){\n  console.log(a);\n} //给函数(可调用对象)分配内存\n\nvar a = new C();//函数调用的的结果会分配内存\n```\n思考一段非常简单的代码:\n```bash\nvar a ={n:1};\nvar b=a;\na = {n:2};\nconsole.log(b); //{n:1}\n```\n从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的'值'的产生往往意味着新的内存被开辟。\n#### 2.调用内存\n使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。\n\n#### 3.内存回收\n全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br>\n而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。\n来来来，再看一段代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n}\nA();\n```\n当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br>\n但是如果稍微改变一下代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n  return obj;\n}\nvar a = A();\n```\n函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。\n 闭包以后再说。\n","source":"_posts/jsMemoryManagent.md","raw":"---\ntitle: 内存管理\ndate: 2018-03-10 00:24:22\ntags: javascript\ncategories: 学习\n---\n\n>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。\n\n\n### 所有之前\n\n```bash\nvar a = {n:1};\nvar b = a;\na.x = a ={n:2};\nconsole.log(a.x);\nconsole.log(b.x);\n```\n\n<!--more-->\n在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。\n众所周知，js在微观上(以代码块为单位)是先定义，再执行的。\n+ 第一行，将{n:1}对象所在的内存地址，存到变量a；\n+ 第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。\n+ 第三行，比较麻烦，js有意思的地方(坑)就在这。\n    + 按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。\n    + 接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。\n    + a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。\n+ 于是乎，结果就是undefined  {n:2}。\n\n之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。\nok，开始BB....\n### 内存模型\njs中内存空间，大致分为三类：\n+ 常量池：保存着诸如数字，字符的常量。\n+ 栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。\n### 内存生命周期\njs(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：\n#### 1.分配内存\n分配内存往往意味着新的'值(包括变量，数字，字符，对象等)'的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：\n```bash\nvar a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里\n\nvar b = 'laalal'; //给字符串分配内存\n\nvar obj ={\n  n:1,\n  x:2\n};//给对象分配内存\n\nfunction C(){\n  console.log(a);\n} //给函数(可调用对象)分配内存\n\nvar a = new C();//函数调用的的结果会分配内存\n```\n思考一段非常简单的代码:\n```bash\nvar a ={n:1};\nvar b=a;\na = {n:2};\nconsole.log(b); //{n:1}\n```\n从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的'值'的产生往往意味着新的内存被开辟。\n#### 2.调用内存\n使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。\n\n#### 3.内存回收\n全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br>\n而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。\n来来来，再看一段代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n}\nA();\n```\n当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br>\n但是如果稍微改变一下代码\n```bash\nfunction A(){\n  var obj = {n:1};\n  console.log(obj);\n  return obj;\n}\nvar a = A();\n```\n函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。\n 闭包以后再说。\n","slug":"jsMemoryManagent","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsj000ohvs6620vt17i","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。</p>\n</blockquote>\n<h3 id=\"所有之前\"><a href=\"#所有之前\" class=\"headerlink\" title=\"所有之前\"></a>所有之前</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;n:1&#125;;</span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">a.x = a =&#123;n:2&#125;;</span><br><span class=\"line\">console.log(a.x);</span><br><span class=\"line\">console.log(b.x);</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。<br>众所周知，js在微观上(以代码块为单位)是先定义，再执行的。</p>\n<ul>\n<li>第一行，将{n:1}对象所在的内存地址，存到变量a；</li>\n<li>第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。</li>\n<li>第三行，比较麻烦，js有意思的地方(坑)就在这。<ul>\n<li>按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。</li>\n<li>接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。</li>\n<li>a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。</li>\n</ul>\n</li>\n<li>于是乎，结果就是undefined  {n:2}。</li>\n</ul>\n<p>之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。<br>ok，开始BB….</p>\n<h3 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h3><p>js中内存空间，大致分为三类：</p>\n<ul>\n<li>常量池：保存着诸如数字，字符的常量。</li>\n<li>栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。<h3 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h3>js(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：<h4 id=\"1-分配内存\"><a href=\"#1-分配内存\" class=\"headerlink\" title=\"1.分配内存\"></a>1.分配内存</h4>分配内存往往意味着新的’值(包括变量，数字，字符，对象等)’的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里</span><br><span class=\"line\"></span><br><span class=\"line\">var b = <span class=\"string\">'laalal'</span>; //给字符串分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var obj =&#123;</span><br><span class=\"line\">  n:1,</span><br><span class=\"line\">  x:2</span><br><span class=\"line\">&#125;;//给对象分配内存</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">C</span></span>()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125; //给函数(可调用对象)分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var a = new C();//函数调用的的结果会分配内存</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>思考一段非常简单的代码:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a =&#123;n:1&#125;;</span><br><span class=\"line\">var b=a;</span><br><span class=\"line\">a = &#123;n:2&#125;;</span><br><span class=\"line\">console.log(b); //&#123;n:1&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的’值’的产生往往意味着新的内存被开辟。</p>\n<h4 id=\"2-调用内存\"><a href=\"#2-调用内存\" class=\"headerlink\" title=\"2.调用内存\"></a>2.调用内存</h4><p>使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。</p>\n<h4 id=\"3-内存回收\"><a href=\"#3-内存回收\" class=\"headerlink\" title=\"3.内存回收\"></a>3.内存回收</h4><p>全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br><br>而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。<br>来来来，再看一段代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();</span><br></pre></td></tr></table></figure></p>\n<p>当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br><br>但是如果稍微改变一下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = A();</span><br></pre></td></tr></table></figure></p>\n<p>函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。<br> 闭包以后再说。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。</p>\n</blockquote>\n<h3 id=\"所有之前\"><a href=\"#所有之前\" class=\"headerlink\" title=\"所有之前\"></a>所有之前</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;n:1&#125;;</span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">a.x = a =&#123;n:2&#125;;</span><br><span class=\"line\">console.log(a.x);</span><br><span class=\"line\">console.log(b.x);</span><br></pre></td></tr></table></figure>","more":"<p>在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。<br>众所周知，js在微观上(以代码块为单位)是先定义，再执行的。</p>\n<ul>\n<li>第一行，将{n:1}对象所在的内存地址，存到变量a；</li>\n<li>第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。</li>\n<li>第三行，比较麻烦，js有意思的地方(坑)就在这。<ul>\n<li>按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。</li>\n<li>接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。</li>\n<li>a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。</li>\n</ul>\n</li>\n<li>于是乎，结果就是undefined  {n:2}。</li>\n</ul>\n<p>之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。<br>ok，开始BB….</p>\n<h3 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h3><p>js中内存空间，大致分为三类：</p>\n<ul>\n<li>常量池：保存着诸如数字，字符的常量。</li>\n<li>栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。<h3 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h3>js(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：<h4 id=\"1-分配内存\"><a href=\"#1-分配内存\" class=\"headerlink\" title=\"1.分配内存\"></a>1.分配内存</h4>分配内存往往意味着新的’值(包括变量，数字，字符，对象等)’的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里</span><br><span class=\"line\"></span><br><span class=\"line\">var b = <span class=\"string\">'laalal'</span>; //给字符串分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var obj =&#123;</span><br><span class=\"line\">  n:1,</span><br><span class=\"line\">  x:2</span><br><span class=\"line\">&#125;;//给对象分配内存</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">C</span></span>()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125; //给函数(可调用对象)分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">var a = new C();//函数调用的的结果会分配内存</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>思考一段非常简单的代码:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a =&#123;n:1&#125;;</span><br><span class=\"line\">var b=a;</span><br><span class=\"line\">a = &#123;n:2&#125;;</span><br><span class=\"line\">console.log(b); //&#123;n:1&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的’值’的产生往往意味着新的内存被开辟。</p>\n<h4 id=\"2-调用内存\"><a href=\"#2-调用内存\" class=\"headerlink\" title=\"2.调用内存\"></a>2.调用内存</h4><p>使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。</p>\n<h4 id=\"3-内存回收\"><a href=\"#3-内存回收\" class=\"headerlink\" title=\"3.内存回收\"></a>3.内存回收</h4><p>全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br><br>而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。<br>来来来，再看一段代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();</span><br></pre></td></tr></table></figure></p>\n<p>当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br><br>但是如果稍微改变一下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  var obj = &#123;n:1&#125;;</span><br><span class=\"line\">  console.log(obj);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = A();</span><br></pre></td></tr></table></figure></p>\n<p>函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。<br> 闭包以后再说。</p>"},{"title":"prototype","date":"2018-01-18T03:35:52.000Z","_content":"\n>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。\n> 就当是重新学一遍。\n\n<!--more-->\n\n### 原型和原型链\n>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，\n>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.\\_\\_proto\\_\\_ ===null，这便是原型链的顶端。\n\n举个例子：\n首先定义一个构造器函数\n```bash\nfunction Person(name, age, gender){\n  this.name = name;\n  this.age = age;\n  this.gender = gender;\n}\n\n```\n然后通过此方法创建实例\n\n```bash\nvar person = new Person('xyl', 18, '男');\n```\n然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况\n\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\">\n这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在\\_\\_proto\\_\\_里，我们依然可以调用这些方法，就是因为原型链的存在。\n举个栗子：\n当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：\n+ js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。\n+ 解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。\n+ 解释器会在Person.prototype.\\_\\_proto\\_\\_也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.\\_\\_proto\\_\\_ ===null，因此没有再往上查找的必要。\n\n\n### “继承”\n原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：\n```bash\n//声明两个构造函数\nfunction A(){}\nfunction B(){}\n//改变原型链的指向\nB.prototype = new A();//原型“继承”\nlet b = new B();\n```\n这就是“继承”的方式，通过改变\\_\\_proto\\_\\_的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的\\_\\_proto\\_\\_是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-> B.prototype ->Object.prototype，现在确是 对象本身-> B.prototype ->A.prototype ->Object.prototype。\n<br>\n\n另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是\\_\\_proto\\_\\_（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。\n\n\n\n### prototype和\\_\\_proto\\_\\_\n\n原型分两种，隐式原型(\\_\\_proto\\_\\_)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。\n<br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。\n咳咳，这个时候，就要放出珍藏已久的图喽。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n来两到测试题\n```bash\n# 测试题1\nfunction A(){}\nA.prototype.n=1;\nvar b= new A();\n\nA.prototype ={\n  n:2,\n  m:3\n}\nvar c = new A();\n\nconsole.log(b.n,b.m,c.n,c.m);\n\n```\n答案是1 undefined 2 3。\n其实现在倒觉得一个对象的__proto__指向它的构造函数的prototype有点不准确，他们俩的关系其实就是\n```bash\nvar a={};\n\nvar b = a;\n\n\n```\n如果a改变了，指向一个新对象，然而b指向的依然是原来的内存\n### constructor\n\n```bash\n   function Foo(){}\n   Foo.prototype.constructor === Foo; //true\n   let foo = new Foo();\n   foo.constructor === Foo; //true\n```\n一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。\n举个例子：\n\n```bash\nfunction Foo(){}\nfunction Bar(){}\nFoo.prototype = new Bar();\nlet f = new Foo();\nf.constructor === Foo; //false\nf.constructor === Object; //true\n\n```\n\n将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br>\nf并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。\n```bash\nObject.defineProperty(Foo.prototype, \"constructor\", {\n  enumerable :false,\n  writable:true,\n  configurable:true,\n  value:Foo  //让constructor指向Foo\n})\n\n```\n","source":"_posts/prototype.md","raw":"---\ntitle: prototype\ndate: 2018-01-18 11:35:52\ntags: javascript\ncategories: 学习\n---\n\n>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。\n> 就当是重新学一遍。\n\n<!--more-->\n\n### 原型和原型链\n>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，\n>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.\\_\\_proto\\_\\_ ===null，这便是原型链的顶端。\n\n举个例子：\n首先定义一个构造器函数\n```bash\nfunction Person(name, age, gender){\n  this.name = name;\n  this.age = age;\n  this.gender = gender;\n}\n\n```\n然后通过此方法创建实例\n\n```bash\nvar person = new Person('xyl', 18, '男');\n```\n然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况\n\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\">\n这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在\\_\\_proto\\_\\_里，我们依然可以调用这些方法，就是因为原型链的存在。\n举个栗子：\n当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：\n+ js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。\n+ 解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。\n+ 解释器会在Person.prototype.\\_\\_proto\\_\\_也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.\\_\\_proto\\_\\_ ===null，因此没有再往上查找的必要。\n\n\n### “继承”\n原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：\n```bash\n//声明两个构造函数\nfunction A(){}\nfunction B(){}\n//改变原型链的指向\nB.prototype = new A();//原型“继承”\nlet b = new B();\n```\n这就是“继承”的方式，通过改变\\_\\_proto\\_\\_的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的\\_\\_proto\\_\\_是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-> B.prototype ->Object.prototype，现在确是 对象本身-> B.prototype ->A.prototype ->Object.prototype。\n<br>\n\n另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是\\_\\_proto\\_\\_（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。\n\n\n\n### prototype和\\_\\_proto\\_\\_\n\n原型分两种，隐式原型(\\_\\_proto\\_\\_)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。\n<br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。\n咳咳，这个时候，就要放出珍藏已久的图喽。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg)\n来两到测试题\n```bash\n# 测试题1\nfunction A(){}\nA.prototype.n=1;\nvar b= new A();\n\nA.prototype ={\n  n:2,\n  m:3\n}\nvar c = new A();\n\nconsole.log(b.n,b.m,c.n,c.m);\n\n```\n答案是1 undefined 2 3。\n其实现在倒觉得一个对象的__proto__指向它的构造函数的prototype有点不准确，他们俩的关系其实就是\n```bash\nvar a={};\n\nvar b = a;\n\n\n```\n如果a改变了，指向一个新对象，然而b指向的依然是原来的内存\n### constructor\n\n```bash\n   function Foo(){}\n   Foo.prototype.constructor === Foo; //true\n   let foo = new Foo();\n   foo.constructor === Foo; //true\n```\n一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。\n举个例子：\n\n```bash\nfunction Foo(){}\nfunction Bar(){}\nFoo.prototype = new Bar();\nlet f = new Foo();\nf.constructor === Foo; //false\nf.constructor === Object; //true\n\n```\n\n将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br>\nf并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。\n```bash\nObject.defineProperty(Foo.prototype, \"constructor\", {\n  enumerable :false,\n  writable:true,\n  configurable:true,\n  value:Foo  //让constructor指向Foo\n})\n\n```\n","slug":"prototype","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsl000rhvs602ygwqbe","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。<br>就当是重新学一遍。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a>原型和原型链</h3><blockquote>\n<p>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，<br>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.__proto__ ===null，这便是原型链的顶端。</p>\n</blockquote>\n<p>举个例子：<br>首先定义一个构造器函数<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Person(name, age, gender)&#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  this.gender = gender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过此方法创建实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = new Person(<span class=\"string\">'xyl'</span>, 18, <span class=\"string\">'男'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\"><br>这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在__proto__里，我们依然可以调用这些方法，就是因为原型链的存在。<br>举个栗子：<br>当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：</p>\n<ul>\n<li>js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。</li>\n<li>解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。</li>\n<li>解释器会在Person.prototype.__proto__也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.__proto__ ===null，因此没有再往上查找的必要。</li>\n</ul>\n<h3 id=\"“继承”\"><a href=\"#“继承”\" class=\"headerlink\" title=\"“继承”\"></a>“继承”</h3><p>原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明两个构造函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>()&#123;&#125;</span><br><span class=\"line\">//改变原型链的指向</span><br><span class=\"line\">B.prototype = new A();//原型“继承”</span><br><span class=\"line\"><span class=\"built_in\">let</span> b = new B();</span><br></pre></td></tr></table></figure></p>\n<p>这就是“继承”的方式，通过改变__proto__的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的__proto__是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-&gt; B.prototype -&gt;Object.prototype，现在确是 对象本身-&gt; B.prototype -&gt;A.prototype -&gt;Object.prototype。<br><br></p>\n<p>另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是__proto__（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。</p>\n<h3 id=\"prototype和-proto\"><a href=\"#prototype和-proto\" class=\"headerlink\" title=\"prototype和__proto__\"></a>prototype和__proto__</h3><p>原型分两种，隐式原型(__proto__)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。<br><br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。<br>咳咳，这个时候，就要放出珍藏已久的图喽。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt=\"\"><br>来两到测试题<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试题1</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\">A.prototype.n=1;</span><br><span class=\"line\">var b= new A();</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype =&#123;</span><br><span class=\"line\">  n:2,</span><br><span class=\"line\">  m:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var c = new A();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.n,b.m,c.n,c.m);</span><br></pre></td></tr></table></figure></p>\n<p>答案是1 undefined 2 3。<br>其实现在倒觉得一个对象的<strong>proto</strong>指向它的构造函数的prototype有点不准确，他们俩的关系其实就是<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br></pre></td></tr></table></figure></p>\n<p>如果a改变了，指向一个新对象，然而b指向的依然是原来的内存</p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype.constructor === Foo; //<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> foo = new Foo();</span><br><span class=\"line\">foo.constructor === Foo; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。<br>举个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Bar</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype = new Bar();</span><br><span class=\"line\"><span class=\"built_in\">let</span> f = new Foo();</span><br><span class=\"line\">f.constructor === Foo; //<span class=\"literal\">false</span></span><br><span class=\"line\">f.constructor === Object; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br><br>f并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Foo.prototype, <span class=\"string\">\"constructor\"</span>, &#123;</span><br><span class=\"line\">  enumerable :<span class=\"literal\">false</span>,</span><br><span class=\"line\">  writable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  configurable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  value:Foo  //让constructor指向Foo</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>原型和原型链一直是JavaScript的重中之重，一直学的很模糊，今天做一下总结。<br>就当是重新学一遍。</p>\n</blockquote>","more":"<h3 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a>原型和原型链</h3><blockquote>\n<p>javascript常被描述为一种基于原型的语言即每个对象都拥有一个原型对象，<br>对象以其原型对象为模板，从原型“继承”方法和属性，一层一层，以此递推。这种关系成为原型链，当我们通过点操作符去调用对象的方法和属性时，如果实例化的对象本身没有该方法或属性，js解释器就会沿着原型链网上查找，直到Object.prototype，如果Object.prototype也没有，就会报错。因为Object.prototype.__proto__ ===null，这便是原型链的顶端。</p>\n</blockquote>\n<p>举个例子：<br>首先定义一个构造器函数<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Person(name, age, gender)&#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  this.gender = gender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过此方法创建实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = new Person(<span class=\"string\">'xyl'</span>, 18, <span class=\"string\">'男'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后将这两行代码复制到浏览器的console环境下，输入person按回车可以看到下面的情况</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype1.png\" width=\"800\"><br>这张图片里name，age，gender是定义在构造器Person里的，但是isPrototypeOf等方法，确是在__proto__里，我们依然可以调用这些方法，就是因为原型链的存在。<br>举个栗子：<br>当我们调用那些原型上的的方法比如valueOf()时，发生了如下过程(z这个方法会返回调用该方法的对象的本身，但不会检索原型，也没有必要)：</p>\n<ul>\n<li>js解释器首先在person这个对象上查找valueOf()这个方法。如果没有，进行下一步。</li>\n<li>解释器检查person的构造函数的原型对象即(Person.prototype)是否有该方法，如果也没有进行下一步。</li>\n<li>解释器会在Person.prototype.__proto__也就是Object.prototype上是否有可用的方法，如果有，会被调用，如果没有，报错，前面提到Object.prototype.__proto__ ===null，因此没有再往上查找的必要。</li>\n</ul>\n<h3 id=\"“继承”\"><a href=\"#“继承”\" class=\"headerlink\" title=\"“继承”\"></a>“继承”</h3><p>原型是用来做什么用的呢？那当然就是“继承”啊，其实“继承”也有点不准确，“继承”意味着复制，js确是创建一个关联或者说是引用，浏览器就可以通过上面的方法去检索属性和函数了，举个例子：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明两个构造函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">B</span></span>()&#123;&#125;</span><br><span class=\"line\">//改变原型链的指向</span><br><span class=\"line\">B.prototype = new A();//原型“继承”</span><br><span class=\"line\"><span class=\"built_in\">let</span> b = new B();</span><br></pre></td></tr></table></figure></p>\n<p>这就是“继承”的方式，通过改变__proto__的指向来实现，为什么说是改变呢，去掉原型“继承”那行代码，在浏览器可以看到 b的__proto__是Object，现在是A。原来通过new B()实例化的对象在调用方法和属性时，浏览器是从对象本身-&gt; B.prototype -&gt;Object.prototype，现在确是 对象本身-&gt; B.prototype -&gt;A.prototype -&gt;Object.prototype。<br><br></p>\n<p>另外，值得一提的是，<font color=\"blue\">原型“继承”时，原型上的对象和方法，并没有复制给实例对象，而是给了它一个引用，</font>就是__proto__（大多数浏览器可以看到这个东东，但是官方文档给的是[[prototype]]），这个引用指向的是拥有那些方法和函数的对象，这个对象是作为一个属性存在的，因此，个人觉得，prototype这个对象并没有特殊的，就是一个普通对象。</p>\n<h3 id=\"prototype和-proto\"><a href=\"#prototype和-proto\" class=\"headerlink\" title=\"prototype和__proto__\"></a>prototype和__proto__</h3><p>原型分两种，隐式原型(__proto__)和显式原型(prototype)。所有的对像都会有隐式原型，但是只有构造函数才会有显式原型。<br><br>当然二者存在一定的关系，一个对象的隐式原型是该对象的的构造函数的显式原型，如果该对象本身是一个构造函数，那么它的隐式原型就是Function.prototype,因为构造函数 的构造函数就是Function，另外 Function和Object的构造函数也是Function。<br>咳咳，这个时候，就要放出珍藏已久的图喽。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/prototype.jpg\" alt=\"\"><br>来两到测试题<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试题1</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;&#125;</span><br><span class=\"line\">A.prototype.n=1;</span><br><span class=\"line\">var b= new A();</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype =&#123;</span><br><span class=\"line\">  n:2,</span><br><span class=\"line\">  m:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var c = new A();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.n,b.m,c.n,c.m);</span><br></pre></td></tr></table></figure></p>\n<p>答案是1 undefined 2 3。<br>其实现在倒觉得一个对象的<strong>proto</strong>指向它的构造函数的prototype有点不准确，他们俩的关系其实就是<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br></pre></td></tr></table></figure></p>\n<p>如果a改变了，指向一个新对象，然而b指向的依然是原来的内存</p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype.constructor === Foo; //<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> foo = new Foo();</span><br><span class=\"line\">foo.constructor === Foo; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>一开始，我觉得constructor指向的是该对象的构造函数，看起来foo.constructor===Foo 为真意味着a确实有一个指向Foo的.constructor属性，其实并不是这样的，.constructor引用只是被委托给了Foo和Foo.prototype，而Foo.prototype.constructor默认指向Foo，foo.constructor默认指向Foo。这种默认属性当你创建一个新对象并替换prototype对象时，新对象便不会自动获得.constructor属性。<br>举个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Foo</span></span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Bar</span></span>()&#123;&#125;</span><br><span class=\"line\">Foo.prototype = new Bar();</span><br><span class=\"line\"><span class=\"built_in\">let</span> f = new Foo();</span><br><span class=\"line\">f.constructor === Foo; //<span class=\"literal\">false</span></span><br><span class=\"line\">f.constructor === Object; //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>将上述代码复制到浏览器环境下，可以看到f.constructor === Foo;返回false。<br><br>f并没有constructor属性，所以它会委托原型链的Foo.prototype。但是这个对象也没有这个属性，直到原型链顶端Object.prototype。这个对象有，便指向 Object这个函数。一般会手动修改这个属性的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Foo.prototype, <span class=\"string\">\"constructor\"</span>, &#123;</span><br><span class=\"line\">  enumerable :<span class=\"literal\">false</span>,</span><br><span class=\"line\">  writable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  configurable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  value:Foo  //让constructor指向Foo</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>"},{"title":"react的setState","date":"2019-01-04T10:04:57.000Z","_content":"\n> 记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。\n\n<!--more-->\n\n### 目的\n\n看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？\n\n### setState关键点\n\n+ setState不会立刻改变React组件中state的值\n+ 多次setState函数调用产生的效果会合并。\n+ setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：\n    - shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）\n    - componentWillUpdate（被调用时this.state没有更新）\n    - render（被调用时this.state得到更新）\n    - componentDidUpdate\n\n首先举个🌰，修改了《深入react技术栈》中的代码：\n\n```bash  \nclass App extends Component {\n  state = {\n    num:0\n  };\n  componentDidMount(){\n    this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n     this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n\n     setTimeout(() => {\n      this.setState({ \n        num:this.state.num+1\n       })\n       console.log('timeout', this.state.num);\n        this.setState({ \n          num:this.state.num+1\n         })\n         console.log('timeout', this.state.num);\n        })\n  }\n\n  componentDidUpdate(){\n    // console.log('update',this.state.num);\n\n  }\n  render() {\n    console.log('rendering', this.state.num)\n    return (\n      <div className=\"App\">\n        <p>{this.state.num}</p>\n      </div>\n    );\n  }\n}\n```\n\n输出是这样的\n\n```bash  \nrendering 0\n0\n0\nrendering 1\nrendering 2\ntimeout 2\nrendering 3\ntimeout 3\n```\n\n看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。\n\n```function enqueueUpdate(component) {  // ...  if (!batchingStrategy.isBatchingUpdates) {    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  }  dirtyComponents.push(component);}\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n```\n\nreact在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。\n\n<strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。\n\n### setState另一个用法\n\nsetState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。\n\n### 渲染\n\nseState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。\n\n\n\n\n\n","source":"_posts/react的setState.md","raw":"---\ntitle: react的setState\ndate: 2019-01-04 18:04:57\ntags: react\n---\n\n> 记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。\n\n<!--more-->\n\n### 目的\n\n看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？\n\n### setState关键点\n\n+ setState不会立刻改变React组件中state的值\n+ 多次setState函数调用产生的效果会合并。\n+ setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：\n    - shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）\n    - componentWillUpdate（被调用时this.state没有更新）\n    - render（被调用时this.state得到更新）\n    - componentDidUpdate\n\n首先举个🌰，修改了《深入react技术栈》中的代码：\n\n```bash  \nclass App extends Component {\n  state = {\n    num:0\n  };\n  componentDidMount(){\n    this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n     this.setState({ \n      num: this.state.num+1\n     });\n     console.log(this.state.num);\n\n     setTimeout(() => {\n      this.setState({ \n        num:this.state.num+1\n       })\n       console.log('timeout', this.state.num);\n        this.setState({ \n          num:this.state.num+1\n         })\n         console.log('timeout', this.state.num);\n        })\n  }\n\n  componentDidUpdate(){\n    // console.log('update',this.state.num);\n\n  }\n  render() {\n    console.log('rendering', this.state.num)\n    return (\n      <div className=\"App\">\n        <p>{this.state.num}</p>\n      </div>\n    );\n  }\n}\n```\n\n输出是这样的\n\n```bash  \nrendering 0\n0\n0\nrendering 1\nrendering 2\ntimeout 2\nrendering 3\ntimeout 3\n```\n\n看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。\n\n```function enqueueUpdate(component) {  // ...  if (!batchingStrategy.isBatchingUpdates) {    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  }  dirtyComponents.push(component);}\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n```\n\nreact在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。\n\n<strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。\n\n### setState另一个用法\n\nsetState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。\n\n### 渲染\n\nseState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。\n\n\n\n\n\n","slug":"react的setState","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsn000vhvs6y6wip0tu","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？</p>\n<h3 id=\"setState关键点\"><a href=\"#setState关键点\" class=\"headerlink\" title=\"setState关键点\"></a>setState关键点</h3><ul>\n<li>setState不会立刻改变React组件中state的值</li>\n<li>多次setState函数调用产生的效果会合并。</li>\n<li>setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：<ul>\n<li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li>\n<li>componentWillUpdate（被调用时this.state没有更新）</li>\n<li>render（被调用时this.state得到更新）</li>\n<li>componentDidUpdate</li>\n</ul>\n</li>\n</ul>\n<p>首先举个🌰，修改了《深入react技术栈》中的代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    num:0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span></span>()&#123;</span><br><span class=\"line\">    this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\">     this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">     setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123; </span><br><span class=\"line\">        num:this.state.num+1</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">       console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        this.setState(&#123; </span><br><span class=\"line\">          num:this.state.num+1</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">         console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span></span>()&#123;</span><br><span class=\"line\">    // console.log(<span class=\"string\">'update'</span>,this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span></span>() &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'rendering'</span>, this.state.num)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出是这样的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rendering 0</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">rendering 1</span><br><span class=\"line\">rendering 2</span><br><span class=\"line\">timeout 2</span><br><span class=\"line\">rendering 3</span><br><span class=\"line\">timeout 3</span><br></pre></td></tr></table></figure>\n<p>看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。</p>\n<figure class=\"highlight plain\"><figcaption><span>enqueueUpdate(component) &#123;</span><a href=\"//\">...  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  dirtyComponents.push(component);&#125;</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function enqueueUpdate(component) &#123;</span><br><span class=\"line\">  ensureInjected();</span><br><span class=\"line\"></span><br><span class=\"line\">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class=\"line\">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class=\"line\">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class=\"line\">  // function, like setProps, setState, forceUpdate, etc.; creation and</span><br><span class=\"line\">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class=\"line\"></span><br><span class=\"line\">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dirtyComponents.push(component);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>react在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。</p>\n<p><strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。</p>\n<h3 id=\"setState另一个用法\"><a href=\"#setState另一个用法\" class=\"headerlink\" title=\"setState另一个用法\"></a>setState另一个用法</h3><p>setState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。</p>\n<h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><p>seState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。</p>\n</blockquote>","more":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？</p>\n<h3 id=\"setState关键点\"><a href=\"#setState关键点\" class=\"headerlink\" title=\"setState关键点\"></a>setState关键点</h3><ul>\n<li>setState不会立刻改变React组件中state的值</li>\n<li>多次setState函数调用产生的效果会合并。</li>\n<li>setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：<ul>\n<li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li>\n<li>componentWillUpdate（被调用时this.state没有更新）</li>\n<li>render（被调用时this.state得到更新）</li>\n<li>componentDidUpdate</li>\n</ul>\n</li>\n</ul>\n<p>首先举个🌰，修改了《深入react技术栈》中的代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    num:0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span></span>()&#123;</span><br><span class=\"line\">    this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\">     this.setState(&#123; </span><br><span class=\"line\">      num: this.state.num+1</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">     console.log(this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">     setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123; </span><br><span class=\"line\">        num:this.state.num+1</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">       console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        this.setState(&#123; </span><br><span class=\"line\">          num:this.state.num+1</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">         console.log(<span class=\"string\">'timeout'</span>, this.state.num);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span></span>()&#123;</span><br><span class=\"line\">    // console.log(<span class=\"string\">'update'</span>,this.state.num);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span></span>() &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'rendering'</span>, this.state.num)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出是这样的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rendering 0</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">rendering 1</span><br><span class=\"line\">rendering 2</span><br><span class=\"line\">timeout 2</span><br><span class=\"line\">rendering 3</span><br><span class=\"line\">timeout 3</span><br></pre></td></tr></table></figure>\n<p>看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。</p>\n<figure class=\"highlight plain\"><figcaption><span>enqueueUpdate(component) &#123;</span><a href=\"//\">...  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  dirtyComponents.push(component);&#125;</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function enqueueUpdate(component) &#123;</span><br><span class=\"line\">  ensureInjected();</span><br><span class=\"line\"></span><br><span class=\"line\">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class=\"line\">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class=\"line\">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class=\"line\">  // function, like setProps, setState, forceUpdate, etc.; creation and</span><br><span class=\"line\">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class=\"line\"></span><br><span class=\"line\">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dirtyComponents.push(component);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>react在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。</p>\n<p><strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。</p>\n<h3 id=\"setState另一个用法\"><a href=\"#setState另一个用法\" class=\"headerlink\" title=\"setState另一个用法\"></a>setState另一个用法</h3><p>setState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。</p>\n<h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><p>seState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。</p>"},{"title":"time travel","date":"2018-04-29T12:50:28.000Z","_content":"\n>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。\n\n<!--more-->\n\n喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。\n(录得效果不好)\n\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"  \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","source":"_posts/timetravel.md","raw":"---\ntitle: time travel\ndate: 2018-04-29 20:50:28\ntags: 指弹\ncategories: 指弹\n---\n\n>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。\n\n<!--more-->\n\n喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。\n(录得效果不好)\n\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"  \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","slug":"timetravel","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrso000yhvs6whn19dpy","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。<br>(录得效果不好)</p>\n<div id=\"dplayer1\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。</p>\n</blockquote>","more":"<p>喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。<br>(录得效果不好)</p>\n<div id=\"dplayer1\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>"},{"title":"selfPromise","date":"2018-12-30T16:34:38.000Z","_content":"\n> 把之前手写过的promise在梳理一遍\n\n<!--more-->\n\n###  代码\n\n```bash \nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction myPromise(fn) {\n    var state = PENDING;\n    var value = null;\n    var handlers = [];\n    var e =null;\n\n    function resolve(val) {\n        if (val instanceof myPromise) {\n            try{\n                val.then(resolve);\n            }catch(e){\n                reject(e)\n            }\n            return;\n        }\n        state = FULFILLED;\n        value = val;\n        setTimeout(function () {\n            handlers.map(function (handler) {\n                handle(handler)\n            })\n        }, 0)\n    }\n\n    function reject(err) {\n        state = REJECTED;\n        e = err\n    }\n\n    function handle(handler) {\n        if (state === PENDING) {\n            handlers.push(handler);\n            return;\n        }\n        try{\n            if (state === FULFILLED && typeof handler.onFulfilled === 'function') {\n                let ret = handler.onFulfilled(value);\n                handler.resolve(ret);\n            }\n        }catch(e){\n            reject(e)\n        }\n    }\n\n\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略\n    this.then = function (onFulfilled, onRejected) {\n        return new myPromise(function (resolve, reject) {\n            handle({\n                onFulfilled,\n                resolve,\n            })\n        })\n    }\n\n    fn(resolve, reject);\n}\n\n```\n\nPS：状态切换就不说了，很显然。\n\nthen函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。\n\n```bash  \nnew myPromise(function(resolve){\n    GET(url, function(data1){\n        resolve(data1)\n    })\n}).then(function(data1){\n\tconst toChainPoromise = new myPromise(function(resolve){\n    \tPOST(url, function(data2){\n             resolve(data1+data2)\n    \t})\n    });\n    return toChainPoromise;\n}).then(function(data){\n    console.log(data)\n})\n```\n\n为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。\n\n\n\n","source":"_posts/selfPromise.md","raw":"---\ntitle: selfPromise\ndate: 2018-12-31 00:34:38\ntags: 学习\n\n---\n\n> 把之前手写过的promise在梳理一遍\n\n<!--more-->\n\n###  代码\n\n```bash \nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction myPromise(fn) {\n    var state = PENDING;\n    var value = null;\n    var handlers = [];\n    var e =null;\n\n    function resolve(val) {\n        if (val instanceof myPromise) {\n            try{\n                val.then(resolve);\n            }catch(e){\n                reject(e)\n            }\n            return;\n        }\n        state = FULFILLED;\n        value = val;\n        setTimeout(function () {\n            handlers.map(function (handler) {\n                handle(handler)\n            })\n        }, 0)\n    }\n\n    function reject(err) {\n        state = REJECTED;\n        e = err\n    }\n\n    function handle(handler) {\n        if (state === PENDING) {\n            handlers.push(handler);\n            return;\n        }\n        try{\n            if (state === FULFILLED && typeof handler.onFulfilled === 'function') {\n                let ret = handler.onFulfilled(value);\n                handler.resolve(ret);\n            }\n        }catch(e){\n            reject(e)\n        }\n    }\n\n\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略\n    this.then = function (onFulfilled, onRejected) {\n        return new myPromise(function (resolve, reject) {\n            handle({\n                onFulfilled,\n                resolve,\n            })\n        })\n    }\n\n    fn(resolve, reject);\n}\n\n```\n\nPS：状态切换就不说了，很显然。\n\nthen函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。\n\n```bash  \nnew myPromise(function(resolve){\n    GET(url, function(data1){\n        resolve(data1)\n    })\n}).then(function(data1){\n\tconst toChainPoromise = new myPromise(function(resolve){\n    \tPOST(url, function(data2){\n             resolve(data1+data2)\n    \t})\n    });\n    return toChainPoromise;\n}).then(function(data){\n    console.log(data)\n})\n```\n\n为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。\n\n\n\n","slug":"selfPromise","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsq0012hvs6prq6kpx4","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>把之前手写过的promise在梳理一遍</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var PENDING = 0;</span><br><span class=\"line\">var FULFILLED = 1;</span><br><span class=\"line\">var REJECTED = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> myPromise(fn) &#123;</span><br><span class=\"line\">    var state = PENDING;</span><br><span class=\"line\">    var value = null;</span><br><span class=\"line\">    var handlers = [];</span><br><span class=\"line\">    var e =null;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> resolve(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val instanceof myPromise) &#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                val.then(resolve);</span><br><span class=\"line\">            &#125;catch(e)&#123;</span><br><span class=\"line\">                reject(e)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = FULFILLED;</span><br><span class=\"line\">        value = val;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            handlers.map(<span class=\"keyword\">function</span> (handler) &#123;</span><br><span class=\"line\">                handle(handler)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> reject(err) &#123;</span><br><span class=\"line\">        state = REJECTED;</span><br><span class=\"line\">        e = err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> handle(handler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">            handlers.push(handler);</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">let</span> ret = handler.onFulfilled(value);</span><br><span class=\"line\">                handler.resolve(ret);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;catch(e)&#123;</span><br><span class=\"line\">            reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略</span><br><span class=\"line\">    this.then = <span class=\"keyword\">function</span> (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new myPromise(<span class=\"keyword\">function</span> (resolve, reject) &#123;</span><br><span class=\"line\">            handle(&#123;</span><br><span class=\"line\">                onFulfilled,</span><br><span class=\"line\">                resolve,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS：状态切换就不说了，很显然。</p>\n<p>then函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    GET(url, <span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">        resolve(data1)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">\tconst toChainPoromise = new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    \tPOST(url, <span class=\"keyword\">function</span>(data2)&#123;</span><br><span class=\"line\">             resolve(data1+data2)</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> toChainPoromise;</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data)&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>把之前手写过的promise在梳理一遍</p>\n</blockquote>","more":"<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var PENDING = 0;</span><br><span class=\"line\">var FULFILLED = 1;</span><br><span class=\"line\">var REJECTED = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> myPromise(fn) &#123;</span><br><span class=\"line\">    var state = PENDING;</span><br><span class=\"line\">    var value = null;</span><br><span class=\"line\">    var handlers = [];</span><br><span class=\"line\">    var e =null;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> resolve(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val instanceof myPromise) &#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                val.then(resolve);</span><br><span class=\"line\">            &#125;catch(e)&#123;</span><br><span class=\"line\">                reject(e)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = FULFILLED;</span><br><span class=\"line\">        value = val;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            handlers.map(<span class=\"keyword\">function</span> (handler) &#123;</span><br><span class=\"line\">                handle(handler)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> reject(err) &#123;</span><br><span class=\"line\">        state = REJECTED;</span><br><span class=\"line\">        e = err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> handle(handler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">            handlers.push(handler);</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">let</span> ret = handler.onFulfilled(value);</span><br><span class=\"line\">                handler.resolve(ret);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;catch(e)&#123;</span><br><span class=\"line\">            reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//onFulfilled, onRejected是可选参数，如果不是函数可以忽略</span><br><span class=\"line\">    this.then = <span class=\"keyword\">function</span> (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new myPromise(<span class=\"keyword\">function</span> (resolve, reject) &#123;</span><br><span class=\"line\">            handle(&#123;</span><br><span class=\"line\">                onFulfilled,</span><br><span class=\"line\">                resolve,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS：状态切换就不说了，很显然。</p>\n<p>then函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    GET(url, <span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">        resolve(data1)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data1)&#123;</span><br><span class=\"line\">\tconst toChainPoromise = new myPromise(<span class=\"keyword\">function</span>(resolve)&#123;</span><br><span class=\"line\">    \tPOST(url, <span class=\"keyword\">function</span>(data2)&#123;</span><br><span class=\"line\">             resolve(data1+data2)</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> toChainPoromise;</span><br><span class=\"line\">&#125;).<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span>(data)&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。</p>"},{"title":"template","date":"2018-04-18T03:38:08.000Z","_content":"\n>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？\n<!--more-->\n\ncompile编译主要分为parse、optimize与generate三个阶段，最终得到render function。\n\n### parse\n\nparse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。\n形如：\n```bash\n<div :class=\"c\" class=\"demo\" v-if=\"isShow\">\n    <span v-for=\"item in sz\">{{item}}</span>\n</div>\n\n\n\n\n{\n    /* 标签属性的map，记录了标签上属性 */\n    'attrsMap': {\n        ':class': 'c',\n        'class': 'demo',\n        'v-if': 'isShow'\n    },\n    /* 解析得到的:class */\n    'classBinding': 'c',\n    /* 标签属性v-if */\n    'if': 'isShow',\n    /* v-if的条件 */\n    'ifConditions': [\n        'exp': 'isShow'\n    ],\n    /* 标签属性class */\n    'staticClass': 'demo',\n    /* 标签的tag */\n    'tag': 'div',\n    /* 子标签数组 */\n    'children': [\n        {\n            'attrsMap': {\n                'v-for': \"item in sz\"\n            },\n            /* for循环的参数 */\n            'alias': \"item\",\n            /* for循环的对象 */\n            'for': 'sz',\n            /* for循环是否已经被处理的标记位 */\n            'forProcessed': true,\n            'tag': 'span',\n            'children': [\n                {\n                    /* 表达式，_s是一个转字符串的函数 */\n                    'expression': '_s(item)',\n                    'text': '{{item}}'\n                }\n            ]\n        }\n    ]\n}\n```\n### optimize\noptimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是\n来标记静态节点的。\n经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。\n\n\n### generate\n\ngenerate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。\n\n### VNode\n\nrender function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。\n浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，\n\n这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，\n\nVue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。\n\nVue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React\n那样有利用setState合并状态的过程。\n\n### nextTick\n\n其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。\n\n```bash\n//订阅者\nclass Dep{\n    constructor(){\n        //用来存放watcher对象的数组\n        this.subs = [];\n    }\n\n    //在subs中添加一个watcher对象\n    addSub(sub){\n        this.subs.push(sub);\n    }\n    //通知watcher对象更新视图\n    notify(){\n        this.subs.forEach((sub)=>{\n            sub.update();\n        })\n    }\n}\n//观察者\n\nclass watcher{\n    constructor(){\n        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。\n        Dep.target  =this;\n        console.log(this)\n    }\n    //更新视图的方法\n    update(){\n        console.log('view change')\n    }\n}\n\n```\n好吧！  把Vue和之前提到的双向绑定的也贴上吧\n\n```bash\n\nfunction cb() {\n//    简陋的视图更新函数\n    console.log('视图更新了')\n}\n\nfunction defineReactive(obj, key, val) {\n    const dep = new Dep();\n    Object.defineProperty(obj,key,{\n        enumerable:true,   //属性可枚举\n        configurable:true, //属性可被删除或修改\n        get:function reactiveGetter(){\n\n            dep.addSub(Dep.target);\n            return val;\n        },\n        set:function reactiveSetter(newVal){\n            if(newVal===val) return;\n            //通知watcher对象更新视图\n            val = newVal\n            dep.notify();\n        }\n    })\n}\n\nfunction observer(value){\n    if(!value||(typeof value !== 'object')){\n        return;\n    }\n\n    Object.keys(value).forEach((key)=>{\n        defineReactive(value,key,value[key]);\n    })\n}\n\nclass Vue {\n    constructor(options){\n        this._data = options.data;\n        observer(this._data);\n        //new一个观察者对象，这时候Dep.target会指向这个watcher\n        new watcher();\n        //模拟render过程，为了触发test属性的get函数\n        console.log('render',this._data.test);\n    }\n}\n\n```\n\n依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会\n被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列\n（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。\n","source":"_posts/template.md","raw":"---\ntitle: template\ndate: 2018-04-18 11:38:08\ntags: vue\ncategories: 学习\n---\n\n>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？\n<!--more-->\n\ncompile编译主要分为parse、optimize与generate三个阶段，最终得到render function。\n\n### parse\n\nparse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。\n形如：\n```bash\n<div :class=\"c\" class=\"demo\" v-if=\"isShow\">\n    <span v-for=\"item in sz\">{{item}}</span>\n</div>\n\n\n\n\n{\n    /* 标签属性的map，记录了标签上属性 */\n    'attrsMap': {\n        ':class': 'c',\n        'class': 'demo',\n        'v-if': 'isShow'\n    },\n    /* 解析得到的:class */\n    'classBinding': 'c',\n    /* 标签属性v-if */\n    'if': 'isShow',\n    /* v-if的条件 */\n    'ifConditions': [\n        'exp': 'isShow'\n    ],\n    /* 标签属性class */\n    'staticClass': 'demo',\n    /* 标签的tag */\n    'tag': 'div',\n    /* 子标签数组 */\n    'children': [\n        {\n            'attrsMap': {\n                'v-for': \"item in sz\"\n            },\n            /* for循环的参数 */\n            'alias': \"item\",\n            /* for循环的对象 */\n            'for': 'sz',\n            /* for循环是否已经被处理的标记位 */\n            'forProcessed': true,\n            'tag': 'span',\n            'children': [\n                {\n                    /* 表达式，_s是一个转字符串的函数 */\n                    'expression': '_s(item)',\n                    'text': '{{item}}'\n                }\n            ]\n        }\n    ]\n}\n```\n### optimize\noptimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是\n来标记静态节点的。\n经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。\n\n\n### generate\n\ngenerate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。\n\n### VNode\n\nrender function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。\n浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，\n\n这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，\n\nVue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。\n\nVue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React\n那样有利用setState合并状态的过程。\n\n### nextTick\n\n其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。\n\n```bash\n//订阅者\nclass Dep{\n    constructor(){\n        //用来存放watcher对象的数组\n        this.subs = [];\n    }\n\n    //在subs中添加一个watcher对象\n    addSub(sub){\n        this.subs.push(sub);\n    }\n    //通知watcher对象更新视图\n    notify(){\n        this.subs.forEach((sub)=>{\n            sub.update();\n        })\n    }\n}\n//观察者\n\nclass watcher{\n    constructor(){\n        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。\n        Dep.target  =this;\n        console.log(this)\n    }\n    //更新视图的方法\n    update(){\n        console.log('view change')\n    }\n}\n\n```\n好吧！  把Vue和之前提到的双向绑定的也贴上吧\n\n```bash\n\nfunction cb() {\n//    简陋的视图更新函数\n    console.log('视图更新了')\n}\n\nfunction defineReactive(obj, key, val) {\n    const dep = new Dep();\n    Object.defineProperty(obj,key,{\n        enumerable:true,   //属性可枚举\n        configurable:true, //属性可被删除或修改\n        get:function reactiveGetter(){\n\n            dep.addSub(Dep.target);\n            return val;\n        },\n        set:function reactiveSetter(newVal){\n            if(newVal===val) return;\n            //通知watcher对象更新视图\n            val = newVal\n            dep.notify();\n        }\n    })\n}\n\nfunction observer(value){\n    if(!value||(typeof value !== 'object')){\n        return;\n    }\n\n    Object.keys(value).forEach((key)=>{\n        defineReactive(value,key,value[key]);\n    })\n}\n\nclass Vue {\n    constructor(options){\n        this._data = options.data;\n        observer(this._data);\n        //new一个观察者对象，这时候Dep.target会指向这个watcher\n        new watcher();\n        //模拟render过程，为了触发test属性的get函数\n        console.log('render',this._data.test);\n    }\n}\n\n```\n\n依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会\n被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列\n（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。\n","slug":"template","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsr0015hvs6dogyypyq","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？<br><a id=\"more\"></a></p>\n</blockquote>\n<p>compile编译主要分为parse、optimize与generate三个阶段，最终得到render function。</p>\n<h3 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h3><p>parse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。<br>形如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :class=<span class=\"string\">\"c\"</span> class=<span class=\"string\">\"demo\"</span> v-if=<span class=\"string\">\"isShow\"</span>&gt;</span><br><span class=\"line\">    &lt;span v-for=<span class=\"string\">\"item in sz\"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 标签属性的map，记录了标签上属性 */</span><br><span class=\"line\">    <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">':class'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">        <span class=\"string\">'class'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">        <span class=\"string\">'v-if'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 解析得到的:class */</span><br><span class=\"line\">    <span class=\"string\">'classBinding'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    /* 标签属性v-if */</span><br><span class=\"line\">    <span class=\"string\">'if'</span>: <span class=\"string\">'isShow'</span>,</span><br><span class=\"line\">    /* v-if的条件 */</span><br><span class=\"line\">    <span class=\"string\">'ifConditions'</span>: [</span><br><span class=\"line\">        <span class=\"string\">'exp'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    /* 标签属性class */</span><br><span class=\"line\">    <span class=\"string\">'staticClass'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    /* 标签的tag */</span><br><span class=\"line\">    <span class=\"string\">'tag'</span>: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    /* 子标签数组 */</span><br><span class=\"line\">    <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">'v-for'</span>: <span class=\"string\">\"item in sz\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的参数 */</span><br><span class=\"line\">            <span class=\"string\">'alias'</span>: <span class=\"string\">\"item\"</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的对象 */</span><br><span class=\"line\">            <span class=\"string\">'for'</span>: <span class=\"string\">'sz'</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环是否已经被处理的标记位 */</span><br><span class=\"line\">            <span class=\"string\">'forProcessed'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">'tag'</span>: <span class=\"string\">'span'</span>,</span><br><span class=\"line\">            <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    /* 表达式，_s是一个转字符串的函数 */</span><br><span class=\"line\">                    <span class=\"string\">'expression'</span>: <span class=\"string\">'_s(item)'</span>,</span><br><span class=\"line\">                    <span class=\"string\">'text'</span>: <span class=\"string\">'&#123;&#123;item&#125;&#125;'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"optimize\"><a href=\"#optimize\" class=\"headerlink\" title=\"optimize\"></a>optimize</h3><p>optimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是<br>来标记静态节点的。<br>经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。</p>\n<h3 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h3><p>generate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p>\n<h3 id=\"VNode\"><a href=\"#VNode\" class=\"headerlink\" title=\"VNode\"></a>VNode</h3><p>render function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。<br>浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，</p>\n<p>这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，</p>\n<p>Vue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p>\n<p>Vue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React<br>那样有利用setState合并状态的过程。</p>\n<h3 id=\"nextTick\"><a href=\"#nextTick\" class=\"headerlink\" title=\"nextTick\"></a>nextTick</h3><p>其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//订阅者</span><br><span class=\"line\">class Dep&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //用来存放watcher对象的数组</span><br><span class=\"line\">        this.subs = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //在subs中添加一个watcher对象</span><br><span class=\"line\">    addSub(sub)&#123;</span><br><span class=\"line\">        this.subs.push(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //通知watcher对象更新视图</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">notify</span></span>()&#123;</span><br><span class=\"line\">        this.subs.forEach((sub)=&gt;&#123;</span><br><span class=\"line\">            sub.update();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//观察者</span><br><span class=\"line\"></span><br><span class=\"line\">class watcher&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。</span><br><span class=\"line\">        Dep.target  =this;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //更新视图的方法</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">update</span></span>()&#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'view change'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好吧！  把Vue和之前提到的双向绑定的也贴上吧</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">cb</span></span>() &#123;</span><br><span class=\"line\">//    简陋的视图更新函数</span><br><span class=\"line\">    console.log(<span class=\"string\">'视图更新了'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> defineReactive(obj, key, val) &#123;</span><br><span class=\"line\">    const dep = new Dep();</span><br><span class=\"line\">    Object.defineProperty(obj,key,&#123;</span><br><span class=\"line\">        enumerable:<span class=\"literal\">true</span>,   //属性可枚举</span><br><span class=\"line\">        configurable:<span class=\"literal\">true</span>, //属性可被删除或修改</span><br><span class=\"line\">        get:<span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">reactiveGetter</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            dep.addSub(Dep.target);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"built_in\">set</span>:<span class=\"keyword\">function</span> reactiveSetter(newVal)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(newVal===val) <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            //通知watcher对象更新视图</span><br><span class=\"line\">            val = newVal</span><br><span class=\"line\">            dep.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> observer(value)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!value||(typeof value !== <span class=\"string\">'object'</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object.keys(value).forEach((key)=&gt;&#123;</span><br><span class=\"line\">        defineReactive(value,key,value[key]);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Vue &#123;</span><br><span class=\"line\">    constructor(options)&#123;</span><br><span class=\"line\">        this._data = options.data;</span><br><span class=\"line\">        observer(this._data);</span><br><span class=\"line\">        //new一个观察者对象，这时候Dep.target会指向这个watcher</span><br><span class=\"line\">        new watcher();</span><br><span class=\"line\">        //模拟render过程，为了触发<span class=\"built_in\">test</span>属性的get函数</span><br><span class=\"line\">        console.log(<span class=\"string\">'render'</span>,this._data.test);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会<br>被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列<br>（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？<br>","more":"</p>\n</blockquote>\n<p>compile编译主要分为parse、optimize与generate三个阶段，最终得到render function。</p>\n<h3 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h3><p>parse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。<br>形如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :class=<span class=\"string\">\"c\"</span> class=<span class=\"string\">\"demo\"</span> v-if=<span class=\"string\">\"isShow\"</span>&gt;</span><br><span class=\"line\">    &lt;span v-for=<span class=\"string\">\"item in sz\"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 标签属性的map，记录了标签上属性 */</span><br><span class=\"line\">    <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">':class'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">        <span class=\"string\">'class'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">        <span class=\"string\">'v-if'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 解析得到的:class */</span><br><span class=\"line\">    <span class=\"string\">'classBinding'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    /* 标签属性v-if */</span><br><span class=\"line\">    <span class=\"string\">'if'</span>: <span class=\"string\">'isShow'</span>,</span><br><span class=\"line\">    /* v-if的条件 */</span><br><span class=\"line\">    <span class=\"string\">'ifConditions'</span>: [</span><br><span class=\"line\">        <span class=\"string\">'exp'</span>: <span class=\"string\">'isShow'</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    /* 标签属性class */</span><br><span class=\"line\">    <span class=\"string\">'staticClass'</span>: <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    /* 标签的tag */</span><br><span class=\"line\">    <span class=\"string\">'tag'</span>: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    /* 子标签数组 */</span><br><span class=\"line\">    <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">'v-for'</span>: <span class=\"string\">\"item in sz\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的参数 */</span><br><span class=\"line\">            <span class=\"string\">'alias'</span>: <span class=\"string\">\"item\"</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环的对象 */</span><br><span class=\"line\">            <span class=\"string\">'for'</span>: <span class=\"string\">'sz'</span>,</span><br><span class=\"line\">            /* <span class=\"keyword\">for</span>循环是否已经被处理的标记位 */</span><br><span class=\"line\">            <span class=\"string\">'forProcessed'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">'tag'</span>: <span class=\"string\">'span'</span>,</span><br><span class=\"line\">            <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    /* 表达式，_s是一个转字符串的函数 */</span><br><span class=\"line\">                    <span class=\"string\">'expression'</span>: <span class=\"string\">'_s(item)'</span>,</span><br><span class=\"line\">                    <span class=\"string\">'text'</span>: <span class=\"string\">'&#123;&#123;item&#125;&#125;'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"optimize\"><a href=\"#optimize\" class=\"headerlink\" title=\"optimize\"></a>optimize</h3><p>optimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是<br>来标记静态节点的。<br>经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。</p>\n<h3 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h3><p>generate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p>\n<h3 id=\"VNode\"><a href=\"#VNode\" class=\"headerlink\" title=\"VNode\"></a>VNode</h3><p>render function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。<br>浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，</p>\n<p>这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，</p>\n<p>Vue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p>\n<p>Vue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React<br>那样有利用setState合并状态的过程。</p>\n<h3 id=\"nextTick\"><a href=\"#nextTick\" class=\"headerlink\" title=\"nextTick\"></a>nextTick</h3><p>其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//订阅者</span><br><span class=\"line\">class Dep&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //用来存放watcher对象的数组</span><br><span class=\"line\">        this.subs = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //在subs中添加一个watcher对象</span><br><span class=\"line\">    addSub(sub)&#123;</span><br><span class=\"line\">        this.subs.push(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //通知watcher对象更新视图</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">notify</span></span>()&#123;</span><br><span class=\"line\">        this.subs.forEach((sub)=&gt;&#123;</span><br><span class=\"line\">            sub.update();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//观察者</span><br><span class=\"line\"></span><br><span class=\"line\">class watcher&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span></span>()&#123;</span><br><span class=\"line\">        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。</span><br><span class=\"line\">        Dep.target  =this;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //更新视图的方法</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">update</span></span>()&#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'view change'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好吧！  把Vue和之前提到的双向绑定的也贴上吧</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">cb</span></span>() &#123;</span><br><span class=\"line\">//    简陋的视图更新函数</span><br><span class=\"line\">    console.log(<span class=\"string\">'视图更新了'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> defineReactive(obj, key, val) &#123;</span><br><span class=\"line\">    const dep = new Dep();</span><br><span class=\"line\">    Object.defineProperty(obj,key,&#123;</span><br><span class=\"line\">        enumerable:<span class=\"literal\">true</span>,   //属性可枚举</span><br><span class=\"line\">        configurable:<span class=\"literal\">true</span>, //属性可被删除或修改</span><br><span class=\"line\">        get:<span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">reactiveGetter</span></span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            dep.addSub(Dep.target);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"built_in\">set</span>:<span class=\"keyword\">function</span> reactiveSetter(newVal)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(newVal===val) <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            //通知watcher对象更新视图</span><br><span class=\"line\">            val = newVal</span><br><span class=\"line\">            dep.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> observer(value)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!value||(typeof value !== <span class=\"string\">'object'</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object.keys(value).forEach((key)=&gt;&#123;</span><br><span class=\"line\">        defineReactive(value,key,value[key]);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Vue &#123;</span><br><span class=\"line\">    constructor(options)&#123;</span><br><span class=\"line\">        this._data = options.data;</span><br><span class=\"line\">        observer(this._data);</span><br><span class=\"line\">        //new一个观察者对象，这时候Dep.target会指向这个watcher</span><br><span class=\"line\">        new watcher();</span><br><span class=\"line\">        //模拟render过程，为了触发<span class=\"built_in\">test</span>属性的get函数</span><br><span class=\"line\">        console.log(<span class=\"string\">'render'</span>,this._data.test);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会<br>被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列<br>（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。</p>"},{"title":"这个this啊","date":"2018-03-07T03:56:13.000Z","_content":">当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。\n\n<!--more-->\n### 默认绑定\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a)\n}\nA();  //2\n```\n上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。\n像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。\n### 隐式绑定\n话不多说，先上代码\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nobj.A();  //3\n```\n在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，_隐式绑定规则_将this绑定到了obj上，所以this.a就是obj.a。\n接下来稍微改一下代码：\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nfunction B(fn){\n  fn()\n}\nvar obj = {\n  a:3,\n  A:A\n}\nB(obj.A);   //2\n```\n在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在_fn()_，此时的fn是没有函数修饰的，上述代码相当于\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nvar C=obj.A;  //敲重点\nC();    //2\n\n```\n其实参数传递相当于_隐式赋值_，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为_隐式丢失_。\n最近在刷题时，有看到这么几段代码：\n```bash\nvar a = 1;\nsetTimeout(function(){\n  var a = 2;\n  console.log(this.a);\n},1000);\n//otherthing\n```\n当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。\n由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，\n```bash\n//Action为第三方封装的函数\nAction(function(){\n  //....\n  console.log(this);//这一行是自己意淫的\n},selector);\n\n```\n这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：\n```bash\nfunction Action(callback , arg){\n    //...\n    callback()\n}\n```\n无可厚非，this绑定的是全局对象，但是如果：\n\n```bash\nfunction Action(callback , selector){\n    //...\n    var dom  = document.queryselector(selector);\n    dom.callback();\n}\n```\n那么此时的this无疑就是dom。\n后来逛掘金时，又看到这段代码：\n```bash\nvar a = 1;\n\nvar obj = {\n  a: 2,\n  B: function(){\n    var a = 3;\n    (function(){\n      var a = 4；\n      console.log(this.a);\n    }\n    )();\n  }\n}\n\nobj.B();\n\n```\n在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时_默认绑定规则_(我好像该写在上一个篇幅，嘤嘤嘤（'qAq'）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。\n\n### 显式绑定\n\n#### 硬绑定\n在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。\n+ apply\n\n此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。\n```bash\nvar n = 2;\nvar obj = {\n  n:1\n}\nfunction getN(){\n  console.log(this.n);\n}\ngetN.apply(obj);\n```\n+ call\n\n\n此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply\n一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如\nfun.call(obj,arg1,arg2,arg3...)\n\n+ bind\n\n\n此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。\n方法比较简单就不再举例。\n#### new\n\n如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。\n构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值\n```bash\nfunction A(){\n    this.a = 2;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n\n如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果\n\n```bash\nfunction A(){\n    this.a = 2;\n    return;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象\n\n\n```bash\nvar obj = {a:1};\nfunction A(){\n    this.a = 2;\n    return obj;\n}\nvar test = new A();\nconsole.log(test);//{a:1}\n\n```\n尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o\n\n\n```bash\nvar obj = {\n    a: function(){\n        return this;\n    }\n}\nvar o = new obj.a();\nconsole.log(o === obj) //false\nconsole.log(o.constructor === obj.a)  //true\n\n```\n\n### 优先级\n","source":"_posts/this.md","raw":"---\ntitle: 这个this啊\ndate: 2018-03-07 11:56:13\ntags: javascript\ncategories: 学习\n---\n>当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。\n\n<!--more-->\n### 默认绑定\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a)\n}\nA();  //2\n```\n上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。\n像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。\n### 隐式绑定\n话不多说，先上代码\n```bash\nvar a = 2;\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nobj.A();  //3\n```\n在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，_隐式绑定规则_将this绑定到了obj上，所以this.a就是obj.a。\n接下来稍微改一下代码：\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nfunction B(fn){\n  fn()\n}\nvar obj = {\n  a:3,\n  A:A\n}\nB(obj.A);   //2\n```\n在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在_fn()_，此时的fn是没有函数修饰的，上述代码相当于\n```bash\nvar a = 2;\n\nfunction A(){\n  console.log(this.a);\n}\n\nvar obj = {\n  a:3,\n  A:A\n}\nvar C=obj.A;  //敲重点\nC();    //2\n\n```\n其实参数传递相当于_隐式赋值_，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为_隐式丢失_。\n最近在刷题时，有看到这么几段代码：\n```bash\nvar a = 1;\nsetTimeout(function(){\n  var a = 2;\n  console.log(this.a);\n},1000);\n//otherthing\n```\n当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。\n由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，\n```bash\n//Action为第三方封装的函数\nAction(function(){\n  //....\n  console.log(this);//这一行是自己意淫的\n},selector);\n\n```\n这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：\n```bash\nfunction Action(callback , arg){\n    //...\n    callback()\n}\n```\n无可厚非，this绑定的是全局对象，但是如果：\n\n```bash\nfunction Action(callback , selector){\n    //...\n    var dom  = document.queryselector(selector);\n    dom.callback();\n}\n```\n那么此时的this无疑就是dom。\n后来逛掘金时，又看到这段代码：\n```bash\nvar a = 1;\n\nvar obj = {\n  a: 2,\n  B: function(){\n    var a = 3;\n    (function(){\n      var a = 4；\n      console.log(this.a);\n    }\n    )();\n  }\n}\n\nobj.B();\n\n```\n在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时_默认绑定规则_(我好像该写在上一个篇幅，嘤嘤嘤（'qAq'）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。\n\n### 显式绑定\n\n#### 硬绑定\n在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。\n+ apply\n\n此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。\n```bash\nvar n = 2;\nvar obj = {\n  n:1\n}\nfunction getN(){\n  console.log(this.n);\n}\ngetN.apply(obj);\n```\n+ call\n\n\n此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply\n一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如\nfun.call(obj,arg1,arg2,arg3...)\n\n+ bind\n\n\n此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。\n方法比较简单就不再举例。\n#### new\n\n如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。\n构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值\n```bash\nfunction A(){\n    this.a = 2;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n\n如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果\n\n```bash\nfunction A(){\n    this.a = 2;\n    return;\n}\nvar test = new A();\nconsole.log(test);//{a:2}\n```\n如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象\n\n\n```bash\nvar obj = {a:1};\nfunction A(){\n    this.a = 2;\n    return obj;\n}\nvar test = new A();\nconsole.log(test);//{a:1}\n\n```\n尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o\n\n\n```bash\nvar obj = {\n    a: function(){\n        return this;\n    }\n}\nvar o = new obj.a();\nconsole.log(o === obj) //false\nconsole.log(o.constructor === obj.a)  //true\n\n```\n\n### 优先级\n","slug":"this","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrss0017hvs6y2c6c3s9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();  //2</span><br></pre></td></tr></table></figure>\n<p>上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。<br>像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。</p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>话不多说，先上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.A();  //3</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，<em>隐式绑定规则</em>将this绑定到了obj上，所以this.a就是obj.a。<br>接下来稍微改一下代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> B(fn)&#123;</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B(obj.A);   //2</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在<em>fn()</em>，此时的fn是没有函数修饰的，上述代码相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var C=obj.A;  //敲重点</span><br><span class=\"line\">C();    //2</span><br></pre></td></tr></table></figure></p>\n<p>其实参数传递相当于<em>隐式赋值</em>，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为<em>隐式丢失</em>。<br>最近在刷题时，有看到这么几段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;,1000);</span><br><span class=\"line\">//otherthing</span><br></pre></td></tr></table></figure></p>\n<p>当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。<br>由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Action为第三方封装的函数</span><br><span class=\"line\">Action(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  //....</span><br><span class=\"line\">  console.log(this);//这一行是自己意淫的</span><br><span class=\"line\">&#125;,selector);</span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , arg)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>无可厚非，this绑定的是全局对象，但是如果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , selector)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    var dom  = document.queryselector(selector);</span><br><span class=\"line\">    dom.callback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么此时的this无疑就是dom。<br>后来逛掘金时，又看到这段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 2,</span><br><span class=\"line\">  B: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">      var a = 4；</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    )();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.B();</span><br></pre></td></tr></table></figure></p>\n<p>在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时<em>默认绑定规则</em>(我好像该写在上一个篇幅，嘤嘤嘤（’qAq’）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。</p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><h4 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h4><p>在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。</p>\n<ul>\n<li>apply</li>\n</ul>\n<p>此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var n = 2;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  n:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getN</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getN.apply(obj);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>call</li>\n</ul>\n<p>此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply<br>一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如<br>fun.call(obj,arg1,arg2,arg3…)</p>\n<ul>\n<li>bind</li>\n</ul>\n<p>此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。<br>方法比较简单就不再举例。</p>\n<h4 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h4><p>如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。<br>构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure>\n<p>如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a:1&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:1&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o = new obj.a();</span><br><span class=\"line\">console.log(o === obj) //<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(o.constructor === obj.a)  //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3>","site":{"data":{}},"excerpt":"<blockquote>\n<p>当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会包含调用栈，函数的调用方法，传入的参数等信息。this就是记录的其中一个属性，会在函数调用时用到。因此this是在运行时进行绑定的，并不在编写时绑定，他的上下文取决于函数调用时的各种条件。</p>\n</blockquote>","more":"<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A();  //2</span><br></pre></td></tr></table></figure>\n<p>上述代码中foo()不带任何修饰函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。<br>像这种独立函数调用是最常见的方式。值得一提的是在严格模式下，全局对象无法使用默认绑定，this绑定的是undefined。</p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>话不多说，先上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.A();  //3</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，函数A被作为obj的A属性的值，严格来说，obj并不包含A函数，但是它保有对A函数的引用，当obj调用A方法时，<em>隐式绑定规则</em>将this绑定到了obj上，所以this.a就是obj.a。<br>接下来稍微改一下代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> B(fn)&#123;</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B(obj.A);   //2</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，obj.A作为参数传递给了函数B，其实函数A最终被调用的位置是在<em>fn()</em>，此时的fn是没有函数修饰的，上述代码相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a:3,</span><br><span class=\"line\">  A:A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var C=obj.A;  //敲重点</span><br><span class=\"line\">C();    //2</span><br></pre></td></tr></table></figure></p>\n<p>其实参数传递相当于<em>隐式赋值</em>，C保存的是对函数A的引用，这其实跟obj没什么关系。这种情况常被称作为<em>隐式丢失</em>。<br>最近在刷题时，有看到这么几段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\">  console.log(this.a);</span><br><span class=\"line\">&#125;,1000);</span><br><span class=\"line\">//otherthing</span><br></pre></td></tr></table></figure></p>\n<p>当时看到这段代码，立即想到了eventLoop，当执行到setTimeout时，先将回调函数注册，1000ms后将函数推入事件队列，然后检查主线程即调用栈是否为空，如果为空，将队列里的函数按照先入先出原则push到调用栈，想了这么多呢，我发现我确实想多了，this在回调里，ojbk，输出1。<br>由此想到开发时遇到的情况，在使用第三方库的时候偶尔会用到此类函数，<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Action为第三方封装的函数</span><br><span class=\"line\">Action(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  //....</span><br><span class=\"line\">  console.log(this);//这一行是自己意淫的</span><br><span class=\"line\">&#125;,selector);</span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，this又绑定的是谁呢？我不禁这样问自己。/吐口水 /吐口水，其实前面说回调里的this绑定的全局对象，有点武断，文章刚开始，就说了，这取决于函数调用时的各种条件。如果Action是这么封装的：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , arg)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>无可厚非，this绑定的是全局对象，但是如果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Action(callback , selector)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    var dom  = document.queryselector(selector);</span><br><span class=\"line\">    dom.callback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么此时的this无疑就是dom。<br>后来逛掘金时，又看到这段代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 2,</span><br><span class=\"line\">  B: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">      var a = 4；</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    )();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.B();</span><br></pre></td></tr></table></figure></p>\n<p>在这段代码里，其实匿名自执行函数和回调函数this绑定的都是全局对象(非严格模式)，因为它们都是不加修饰的函数调用，应用的时<em>默认绑定规则</em>(我好像该写在上一个篇幅，嘤嘤嘤（’qAq’）)，想当初我还沿着作用域链去查找this绑定的是谁呢，不得不说《你不知道的javascript》，真不愧是神书。</p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><h4 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h4><p>在js中，可以通过一些方法来改变this的指向，在《你不知道的js》里被称为硬绑定，这些方法有apply，call，bind。</p>\n<ul>\n<li>apply</li>\n</ul>\n<p>此方法会执行函数。apply方法只能接受两个参数，一个是this指向的上下文对象，另一个是传递给函数的参数列表(可选)，这个参数列表是以数组的形式。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var n = 2;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  n:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getN</span></span>()&#123;</span><br><span class=\"line\">  console.log(this.n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getN.apply(obj);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>call</li>\n</ul>\n<p>此方法会执行函数。call方法和apply方法的使用唯一的差别就是参数的差别，call第一个参数和apply<br>一样是this指向的上下文对象，但是要传给函数的参数，是单个传过去的，形如<br>fun.call(obj,arg1,arg2,arg3…)</p>\n<ul>\n<li>bind</li>\n</ul>\n<p>此方法不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数。<br>方法比较简单就不再举例。</p>\n<h4 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h4><p>如果函数或者方法调用之前带有关键字new，它就构成构造函数调用，也就是new绑定。<br>构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果构造函数使用return语句但没有指定返回值，或者返回一个原始类型的值，那么这时将忽略返回值，同时使用这个新对象作为调用结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:2&#125;</span><br></pre></td></tr></table></figure>\n<p>如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a:1&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">    this.a = 2;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"built_in\">test</span> = new A();</span><br><span class=\"line\">console.log(<span class=\"built_in\">test</span>);//&#123;a:1&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，在表达式new o.m()中，this并不是o</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o = new obj.a();</span><br><span class=\"line\">console.log(o === obj) //<span class=\"literal\">false</span></span><br><span class=\"line\">console.log(o.constructor === obj.a)  //<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3>"},{"title":"Vue学习笔记之v-model指令","date":"2018-01-08T04:05:36.000Z","_content":"\n\n&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。\n\n<!--more-->\n\n### 表单控件绑定\n----------------\n\n#### 基础语法\n\n+ v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型\n自动选取正确的方法来更新元素。\n+ v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。\n\n##### 简单示例\n\n```bash\n<!--单行-->\n<!--直接绑定变量,这个变量需要在vue实例里面的-->\n<div id=\"aa\">\n    <input v-model=\"message\" placeholder=\"edit me\">\n    <p>Message is: {{ message }}</p>\n</div>\n```\n\n```Bash\n<script src=\"js/vue.js\"></script> //引用vue\n<script>\n    new Vue({\n        el: '#aa', //挂载vue实例\n        data: {\n            message: '' //需要有一个做双向绑定的变量\n        }\n    })\n</script>\n```\n\n##### textarea\n\n```bash\n<!--多行textarea,其实类似单行-->\n<span>Multiline message is:</span>\n<p style=\"white-space: pre\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n##### radio\n\n```bash\n<!--单选,类似单行,不过需要注意的是他们使用同一个v-model-->\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n```bash\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            picked:'One'\n        }\n    })\n</script>\n```\n&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。\n#### checkbox\n&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。\n组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：\n```bash\n<div id=\"app\">\n    <input type=\"text\" v-model=\"text\">\n    {{text}}\n    <input type=\"radio\" :checked=\"picked\"><br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"html\" id=\"checked\">\n    <label for=\"html\">HTML</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"js\" id=\"js\">\n    <label for=\"js\">JS</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"css\" id=\"css\">\n    <label for=\"css\">CSS</label>\n    <br>\n    <p>选择的是{{checked}}</p>\n</div>\n```\n```Bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            text:'',\n            picked:true,\n            checked:['html','css']\n        }\n    })\n</script>\n```\n##### select\n\n```bash\n<!--选择列表,类似单行-->\n<select v-model=\"selected\">\n  <option>A</option>\n  <option value='b'>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。\n<em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em>\n\n### v-model的背后\n-----------------\n\n&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：\n   1. v-bind绑定一个value值\n   2. v-on指令绑定一个input事件或者说是change事件\n&emsp;&emsp;举个栗子：\n#### 在原生表单中\n```Bash\n<input v-model='message'>\n```\n\n相当于\n\n```bash\n<input v-bind:value='message' @input='message = $event.target.value'>\n```\n &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素\n\n#### 在自定义组件中\n\n```Bash\n<my-component v-model='message' ></my-component>\n```\n相当于\n```Bash\n<my-component :value='message' @input='message = arguments[0]' ></my-component>\n```\n&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。\n```Bash\nthis.$emit('input',value);\n```\n\n### 修饰符\n---------\n\n与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。\n\n#### .lazy\n\n&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。\n\n```bash\n<div id=\"app\">\n    <input type='text' v-model.lazy='message' >\n    <p>{{message}}</p>\n</div>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n这时，message并不是实时更新的，而是在在失焦或按回车时才更新。\n\n#### .number\n&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"number\" v-model.number='message' value=\"\">\n    <p>{{typeof message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n\n#### .trim\n修饰符.trim会自动过滤输入的首尾空格，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"text\" v-model.trim='message' value=\"\">\n    <p>{{message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n","source":"_posts/v-model.md","raw":"---\ntitle: Vue学习笔记之v-model指令\ndate: 2018-01-08 12:05:36\ntags: vue\ncategories: 学习\n---\n\n\n&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。\n\n<!--more-->\n\n### 表单控件绑定\n----------------\n\n#### 基础语法\n\n+ v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型\n自动选取正确的方法来更新元素。\n+ v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。\n\n##### 简单示例\n\n```bash\n<!--单行-->\n<!--直接绑定变量,这个变量需要在vue实例里面的-->\n<div id=\"aa\">\n    <input v-model=\"message\" placeholder=\"edit me\">\n    <p>Message is: {{ message }}</p>\n</div>\n```\n\n```Bash\n<script src=\"js/vue.js\"></script> //引用vue\n<script>\n    new Vue({\n        el: '#aa', //挂载vue实例\n        data: {\n            message: '' //需要有一个做双向绑定的变量\n        }\n    })\n</script>\n```\n\n##### textarea\n\n```bash\n<!--多行textarea,其实类似单行-->\n<span>Multiline message is:</span>\n<p style=\"white-space: pre\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n##### radio\n\n```bash\n<!--单选,类似单行,不过需要注意的是他们使用同一个v-model-->\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n```bash\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            picked:'One'\n        }\n    })\n</script>\n```\n&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。\n#### checkbox\n&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。\n组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：\n```bash\n<div id=\"app\">\n    <input type=\"text\" v-model=\"text\">\n    {{text}}\n    <input type=\"radio\" :checked=\"picked\"><br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"html\" id=\"checked\">\n    <label for=\"html\">HTML</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"js\" id=\"js\">\n    <label for=\"js\">JS</label>\n    <br>\n    <input type=\"checkbox\" v-model=\"checked\" value=\"css\" id=\"css\">\n    <label for=\"css\">CSS</label>\n    <br>\n    <p>选择的是{{checked}}</p>\n</div>\n```\n```Bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            text:'',\n            picked:true,\n            checked:['html','css']\n        }\n    })\n</script>\n```\n##### select\n\n```bash\n<!--选择列表,类似单行-->\n<select v-model=\"selected\">\n  <option>A</option>\n  <option value='b'>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。\n<em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em>\n\n### v-model的背后\n-----------------\n\n&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：\n   1. v-bind绑定一个value值\n   2. v-on指令绑定一个input事件或者说是change事件\n&emsp;&emsp;举个栗子：\n#### 在原生表单中\n```Bash\n<input v-model='message'>\n```\n\n相当于\n\n```bash\n<input v-bind:value='message' @input='message = $event.target.value'>\n```\n &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素\n\n#### 在自定义组件中\n\n```Bash\n<my-component v-model='message' ></my-component>\n```\n相当于\n```Bash\n<my-component :value='message' @input='message = arguments[0]' ></my-component>\n```\n&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。\n```Bash\nthis.$emit('input',value);\n```\n\n### 修饰符\n---------\n\n与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。\n\n#### .lazy\n\n&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。\n\n```bash\n<div id=\"app\">\n    <input type='text' v-model.lazy='message' >\n    <p>{{message}}</p>\n</div>\n```\n```bash\n<script>\n    var app = new Vue({\n        el:\"#app\",\n        data:{\n            selected:'A'\n        }\n    })\n</script>\n```\n这时，message并不是实时更新的，而是在在失焦或按回车时才更新。\n\n#### .number\n&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"number\" v-model.number='message' value=\"\">\n    <p>{{typeof message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n\n#### .trim\n修饰符.trim会自动过滤输入的首尾空格，代码如下：\n\n```bash\n<div id=\"app\" >\n    <input type=\"text\" v-model.trim='message' value=\"\">\n    <p>{{message}}</p>\n\n</div>\n<script src=\"vue.js\"></script>\n<script>\n    var app = new Vue({\n        el:'#app',\n        data:{\n            message:0\n        }\n    })\n</script>\n```\n","slug":"v-model","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsu001bhvs66ypitors","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。</p>\n<a id=\"more\"></a>\n<h3 id=\"表单控件绑定\"><a href=\"#表单控件绑定\" class=\"headerlink\" title=\"表单控件绑定\"></a>表单控件绑定</h3><hr>\n<h4 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h4><ul>\n<li>v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型<br>自动选取正确的方法来更新元素。</li>\n<li>v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。</li>\n</ul>\n<h5 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单行--&gt;</span><br><span class=\"line\">&lt;!--直接绑定变量,这个变量需要在vue实例里面的--&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"aa\"</span>&gt;</span><br><span class=\"line\">    &lt;input v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"edit me\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"js/vue.js\"</span>&gt;&lt;/script&gt; //引用vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#aa'</span>, //挂载vue实例</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            message: <span class=\"string\">''</span> //需要有一个做双向绑定的变量</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"textarea\"><a href=\"#textarea\" class=\"headerlink\" title=\"textarea\"></a>textarea</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--多行textarea,其实类似单行--&gt;</span><br><span class=\"line\">&lt;span&gt;Multiline message is:&lt;/span&gt;</span><br><span class=\"line\">&lt;p style=<span class=\"string\">\"white-space: pre\"</span>&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;textarea v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"add multiple lines\"</span>&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"radio\"><a href=\"#radio\" class=\"headerlink\" title=\"radio\"></a>radio</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单选,类似单行,不过需要注意的是他们使用同一个v-model--&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"one\"</span> value=<span class=\"string\">\"One\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"one\"</span>&gt;One&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"two\"</span> value=<span class=\"string\">\"Two\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"two\"</span>&gt;Two&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            picked:<span class=\"string\">'One'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。</p>\n<h4 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h4><p>&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。<br>组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"text\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123;text&#125;&#125;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> :checked=<span class=\"string\">\"picked\"</span>&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"html\"</span> id=<span class=\"string\">\"checked\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"html\"</span>&gt;HTML&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"js\"</span> id=<span class=\"string\">\"js\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"js\"</span>&gt;JS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"css\"</span> id=<span class=\"string\">\"css\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"css\"</span>&gt;CSS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;p&gt;选择的是&#123;&#123;checked&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            text:<span class=\"string\">''</span>,</span><br><span class=\"line\">            picked:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            checked:[<span class=\"string\">'html'</span>,<span class=\"string\">'css'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--选择列表,类似单行--&gt;</span><br><span class=\"line\">&lt;select v-model=<span class=\"string\">\"selected\"</span>&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option value=<span class=\"string\">'b'</span>&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。<br><em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em></option></p>\n<h3 id=\"v-model的背后\"><a href=\"#v-model的背后\" class=\"headerlink\" title=\"v-model的背后\"></a>v-model的背后</h3><hr>\n<p>&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：</p>\n<ol>\n<li>v-bind绑定一个value值</li>\n<li>v-on指令绑定一个input事件或者说是change事件<br>&emsp;&emsp;举个栗子：<h4 id=\"在原生表单中\"><a href=\"#在原生表单中\" class=\"headerlink\" title=\"在原生表单中\"></a>在原生表单中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=<span class=\"string\">'message'</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>相当于</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-bind:value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = $event.target.value'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p> &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素</p>\n<h4 id=\"在自定义组件中\"><a href=\"#在自定义组件中\" class=\"headerlink\" title=\"在自定义组件中\"></a>在自定义组件中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component v-model=<span class=\"string\">'message'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>\n<p>相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component :value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = arguments[0]'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$emit</span>(<span class=\"string\">'input'</span>,value);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><hr>\n<p>与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。</p>\n<h4 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h4><p>&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">'text'</span> v-model.lazy=<span class=\"string\">'message'</span> &gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这时，message并不是实时更新的，而是在在失焦或按回车时才更新。</p>\n<h4 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h4><p>&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"number\"</span> v-model.number=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;typeof message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h4><p>修饰符.trim会自动过滤输入的首尾空格，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model.trim=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;在Vue.js中，经常使用v-model实现表单的双向绑定，，最近阅读的vue.js实战里有一章节专门讲的v-model。</p>","more":"<h3 id=\"表单控件绑定\"><a href=\"#表单控件绑定\" class=\"headerlink\" title=\"表单控件绑定\"></a>表单控件绑定</h3><hr>\n<h4 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h4><ul>\n<li>v-model指令在表单元素控件上创建双向数据绑定。他会根据控件类型<br>自动选取正确的方法来更新元素。</li>\n<li>v-model并不关心表单控件初始化所生成的值。因为他会选择Vue实例数据来作为具体的值。</li>\n</ul>\n<h5 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单行--&gt;</span><br><span class=\"line\">&lt;!--直接绑定变量,这个变量需要在vue实例里面的--&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"aa\"</span>&gt;</span><br><span class=\"line\">    &lt;input v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"edit me\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"js/vue.js\"</span>&gt;&lt;/script&gt; //引用vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#aa'</span>, //挂载vue实例</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            message: <span class=\"string\">''</span> //需要有一个做双向绑定的变量</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"textarea\"><a href=\"#textarea\" class=\"headerlink\" title=\"textarea\"></a>textarea</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--多行textarea,其实类似单行--&gt;</span><br><span class=\"line\">&lt;span&gt;Multiline message is:&lt;/span&gt;</span><br><span class=\"line\">&lt;p style=<span class=\"string\">\"white-space: pre\"</span>&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;textarea v-model=<span class=\"string\">\"message\"</span> placeholder=<span class=\"string\">\"add multiple lines\"</span>&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"radio\"><a href=\"#radio\" class=\"headerlink\" title=\"radio\"></a>radio</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--单选,类似单行,不过需要注意的是他们使用同一个v-model--&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"one\"</span> value=<span class=\"string\">\"One\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"one\"</span>&gt;One&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> id=<span class=\"string\">\"two\"</span> value=<span class=\"string\">\"Two\"</span> v-model=<span class=\"string\">\"picked\"</span>&gt;</span><br><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"two\"</span>&gt;Two&lt;/label&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            picked:<span class=\"string\">'One'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;如果是像上面这种组合模式实现单选状态，就需要v-model配合value来实现互斥效果。数据picked的值与单选按钮的值一致时，就选中该项，所以当前选中的是One。通过点击radio会改变picked的值，同时通过动态的改变picked的值，视图也会重新渲染。</p>\n<h4 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h4><p>&emsp;&emsp;复选框也分单独和组合模式，单独情况比较简单，就是用v-model绑定一个布尔值，就不说了。<br>组合使用时，也是v-model和value一起，多个勾选框都绑定到同一个数组类型的数据，value的值再输组当中，就会选中这一项。这个过程也是双向的，在勾选时，value也会push到数组里，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"text\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123;text&#125;&#125;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"radio\"</span> :checked=<span class=\"string\">\"picked\"</span>&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"html\"</span> id=<span class=\"string\">\"checked\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"html\"</span>&gt;HTML&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"js\"</span> id=<span class=\"string\">\"js\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"js\"</span>&gt;JS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"checkbox\"</span> v-model=<span class=\"string\">\"checked\"</span> value=<span class=\"string\">\"css\"</span> id=<span class=\"string\">\"css\"</span>&gt;</span><br><span class=\"line\">    &lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"css\"</span>&gt;CSS&lt;/label&gt;</span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">    &lt;p&gt;选择的是&#123;&#123;checked&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            text:<span class=\"string\">''</span>,</span><br><span class=\"line\">            picked:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            checked:[<span class=\"string\">'html'</span>,<span class=\"string\">'css'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--选择列表,类似单行--&gt;</span><br><span class=\"line\">&lt;select v-model=<span class=\"string\">\"selected\"</span>&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option value=<span class=\"string\">'b'</span>&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<option>是备选项，如果含有value属性，v-model就回优先匹配value的值；如果没有，就会直接匹配option的text，比如选中的是第二项，selected的值是b，而不是B。<br><em>&emsp;&emsp;PS:给selected添加属性multiple就可以多选了，此时selected绑定的是一个数组。</em></option></p>\n<h3 id=\"v-model的背后\"><a href=\"#v-model的背后\" class=\"headerlink\" title=\"v-model的背后\"></a>v-model的背后</h3><hr>\n<p>&emsp;&emsp;使用v-model指令，常与表单组件联系起来，而它本身其实是一个语法糖，背后做了两个操作：</p>\n<ol>\n<li>v-bind绑定一个value值</li>\n<li>v-on指令绑定一个input事件或者说是change事件<br>&emsp;&emsp;举个栗子：<h4 id=\"在原生表单中\"><a href=\"#在原生表单中\" class=\"headerlink\" title=\"在原生表单中\"></a>在原生表单中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=<span class=\"string\">'message'</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>相当于</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-bind:value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = $event.target.value'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p> &emsp;&emsp;当input接收到新的输入就会触发input事件，将事件目标value值赋值给新的元素</p>\n<h4 id=\"在自定义组件中\"><a href=\"#在自定义组件中\" class=\"headerlink\" title=\"在自定义组件中\"></a>在自定义组件中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component v-model=<span class=\"string\">'message'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>\n<p>相当于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component :value=<span class=\"string\">'message'</span> @input=<span class=\"string\">'message = arguments[0]'</span> &gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在自定义组件中，message接受的值就是input事件接受的第一个参数(此时的input时间需要去自定义)，在自定义组件中，还需要用$emit事件去定义一个事件，并触发。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$emit</span>(<span class=\"string\">'input'</span>,value);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><hr>\n<p>与事件的修饰符类似，v-model也是有修饰符的，用于控制数据同步的时机。</p>\n<h4 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h4><p>&emsp;&emsp;在输入框中，v-model默认是在input事件同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">'text'</span> v-model.lazy=<span class=\"string\">'message'</span> &gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            selected:<span class=\"string\">'A'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这时，message并不是实时更新的，而是在在失焦或按回车时才更新。</p>\n<h4 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h4><p>&emsp;&emsp; 使用.number可以将输入类型转化为Number类型，否则虽然输入的时数字，但它的类型是String，在数字输入框下会比较有用，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"number\"</span> v-model.number=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;typeof message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h4><p>修饰符.trim会自动过滤输入的首尾空格，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> &gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model.trim=<span class=\"string\">'message'</span> value=<span class=\"string\">\"\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var app = new Vue(&#123;</span><br><span class=\"line\">        el:<span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            message:0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>"},{"title":"流行的云","date":"2018-05-20T08:41:37.000Z","_content":"\n又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。\n\n<!--more-->\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","source":"_posts/流行的云.md","raw":"---\ntitle: 流行的云\ndate: 2018-05-20 16:41:37\ntags: 指弹\ncategories: 指弹\n---\n\n又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。\n\n<!--more-->\n{% dplayer \"url=https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"   \"loop=yes\" \"theme=#FADFA3\"  \"token=tokendemo\" %}\n","slug":"流行的云","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsv001dhvs6gl20t86m","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。</p>\n<a id=\"more\"></a>\n<div id=\"dplayer2\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>\n","site":{"data":{}},"excerpt":"<p>又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。</p>","more":"<div id=\"dplayer2\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>"},{"title":"toLittleCute","date":"2018-03-28T09:25:45.000Z","_content":">作为一位即将离开的老学长，临走之前还是有些话要和学弟学妹们说的。\n\n<!--more-->\n\n### 感触\n学前端有两年了，一个人摸摸索索走了很多弯路，回顾自己学习的时光，可惜的一点是，没有找到\n和自己一样搞前端，互补的人。所以，我觉得16级的你们可以跟部门里的同学结伴，互补互足。之前开会时我说，\n分小程序，框架，node，就是要你们在后面互相学习对方熟悉的部分，进步会快一点。\n\n### 技术路线\n\n目前，H5和CSS3还有ES6已经不是新技术了，是要必须列入学习的计划的。\n\n从最基础的开始：<br>\n\nHTML和css ：元素和api是看就能会用的，但是页面的布局（两列圣杯，弹性盒模型），元素之间（块级，内联，替代，非替代）的特点，定位，堆叠次序，BFC等，这些是基础，有必要深究的，一两个月的时间差不多，时间不能再多了。\n\n前端的重头戏始终在js上面，tc-39颁布的有es5，es6，es7（尚不稳定），有必要了解一下。\n重点在this，原型，闭包，内存分配,深浅拷贝，执行机制（异步，同步，执行队列，宏任务，微任务，定时器，promise等）\nthis，原型，闭包这些在《你不知道的js》这本书里讲的很完美。\n内存分配和执行机制可以在掘金里逛逛。<br>\n内存分配：\n[点我看看](https://juejin.im/post/597c5b71f265da3e3d122a3b)\n<br>\n深浅拷贝：\n[](https://github.com/Wscats/Good-text-Share/issues/57)\n<br>\n贴两篇关于执行机制的文章：可以参考一下\n[执行机制1](https://juejin.im/post/59e85eebf265da430d571f89)\n[执行机制2](https://juejin.im/post/5a61a6786fb9a01cc026522c)\n\n小程序目前和[快应用](https://quick.cn)‘打’成一片，有兴趣的可以了解一番，\n跟Vue长的差不多\n三大框架：<br>\n\n目前正在学习angular和react，vue搁置了一段时间，三大框架给我的感觉，react是最复杂的（都学过才知道angular是看起来复杂，实际上并不难操作），当然指得是上手。\n<br><br>\nVue是国产，市面上貌似有捧Vue的趋势，建议先从Vue入手，然后React，React Native可以写app，如果想早点接触移动端app，可以先学React，angular你看心情。\n<br><br>\n最近在刷面试题时，也会看到一些算法的题目，虽然前端对算法要求没有后台要求高，但是建议从现在开始，刷一些算法题，或尝试用js实现一些数据结构。实现可以看看[这篇文章](https://blog.csdn.net/haoshidai/article/details/52263191)\n\n\n最后，last but not least  前端最重要的还是js，原生js玩的熟，框架都是纸老虎\n------来自渣渣学长的建议\n","source":"_posts/toLittleCute.md","raw":"---\ntitle: toLittleCute\ndate: 2018-03-28 17:25:45\ntags: 不知道归为哪一列系列\ncategories: 生活\n---\n>作为一位即将离开的老学长，临走之前还是有些话要和学弟学妹们说的。\n\n<!--more-->\n\n### 感触\n学前端有两年了，一个人摸摸索索走了很多弯路，回顾自己学习的时光，可惜的一点是，没有找到\n和自己一样搞前端，互补的人。所以，我觉得16级的你们可以跟部门里的同学结伴，互补互足。之前开会时我说，\n分小程序，框架，node，就是要你们在后面互相学习对方熟悉的部分，进步会快一点。\n\n### 技术路线\n\n目前，H5和CSS3还有ES6已经不是新技术了，是要必须列入学习的计划的。\n\n从最基础的开始：<br>\n\nHTML和css ：元素和api是看就能会用的，但是页面的布局（两列圣杯，弹性盒模型），元素之间（块级，内联，替代，非替代）的特点，定位，堆叠次序，BFC等，这些是基础，有必要深究的，一两个月的时间差不多，时间不能再多了。\n\n前端的重头戏始终在js上面，tc-39颁布的有es5，es6，es7（尚不稳定），有必要了解一下。\n重点在this，原型，闭包，内存分配,深浅拷贝，执行机制（异步，同步，执行队列，宏任务，微任务，定时器，promise等）\nthis，原型，闭包这些在《你不知道的js》这本书里讲的很完美。\n内存分配和执行机制可以在掘金里逛逛。<br>\n内存分配：\n[点我看看](https://juejin.im/post/597c5b71f265da3e3d122a3b)\n<br>\n深浅拷贝：\n[](https://github.com/Wscats/Good-text-Share/issues/57)\n<br>\n贴两篇关于执行机制的文章：可以参考一下\n[执行机制1](https://juejin.im/post/59e85eebf265da430d571f89)\n[执行机制2](https://juejin.im/post/5a61a6786fb9a01cc026522c)\n\n小程序目前和[快应用](https://quick.cn)‘打’成一片，有兴趣的可以了解一番，\n跟Vue长的差不多\n三大框架：<br>\n\n目前正在学习angular和react，vue搁置了一段时间，三大框架给我的感觉，react是最复杂的（都学过才知道angular是看起来复杂，实际上并不难操作），当然指得是上手。\n<br><br>\nVue是国产，市面上貌似有捧Vue的趋势，建议先从Vue入手，然后React，React Native可以写app，如果想早点接触移动端app，可以先学React，angular你看心情。\n<br><br>\n最近在刷面试题时，也会看到一些算法的题目，虽然前端对算法要求没有后台要求高，但是建议从现在开始，刷一些算法题，或尝试用js实现一些数据结构。实现可以看看[这篇文章](https://blog.csdn.net/haoshidai/article/details/52263191)\n\n\n最后，last but not least  前端最重要的还是js，原生js玩的熟，框架都是纸老虎\n------来自渣渣学长的建议\n","slug":"toLittleCute","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsx001hhvs6sg8esgwr","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>作为一位即将离开的老学长，临走之前还是有些话要和学弟学妹们说的。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"感触\"><a href=\"#感触\" class=\"headerlink\" title=\"感触\"></a>感触</h3><p>学前端有两年了，一个人摸摸索索走了很多弯路，回顾自己学习的时光，可惜的一点是，没有找到<br>和自己一样搞前端，互补的人。所以，我觉得16级的你们可以跟部门里的同学结伴，互补互足。之前开会时我说，<br>分小程序，框架，node，就是要你们在后面互相学习对方熟悉的部分，进步会快一点。</p>\n<h3 id=\"技术路线\"><a href=\"#技术路线\" class=\"headerlink\" title=\"技术路线\"></a>技术路线</h3><p>目前，H5和CSS3还有ES6已经不是新技术了，是要必须列入学习的计划的。</p>\n<p>从最基础的开始：<br></p>\n<p>HTML和css ：元素和api是看就能会用的，但是页面的布局（两列圣杯，弹性盒模型），元素之间（块级，内联，替代，非替代）的特点，定位，堆叠次序，BFC等，这些是基础，有必要深究的，一两个月的时间差不多，时间不能再多了。</p>\n<p>前端的重头戏始终在js上面，tc-39颁布的有es5，es6，es7（尚不稳定），有必要了解一下。<br>重点在this，原型，闭包，内存分配,深浅拷贝，执行机制（异步，同步，执行队列，宏任务，微任务，定时器，promise等）<br>this，原型，闭包这些在《你不知道的js》这本书里讲的很完美。<br>内存分配和执行机制可以在掘金里逛逛。<br><br>内存分配：<br><a href=\"https://juejin.im/post/597c5b71f265da3e3d122a3b\" target=\"_blank\" rel=\"noopener\">点我看看</a><br><br><br>深浅拷贝：<br><a href=\"https://github.com/Wscats/Good-text-Share/issues/57\" target=\"_blank\" rel=\"noopener\"></a><br><br><br>贴两篇关于执行机制的文章：可以参考一下<br><a href=\"https://juejin.im/post/59e85eebf265da430d571f89\" target=\"_blank\" rel=\"noopener\">执行机制1</a><br><a href=\"https://juejin.im/post/5a61a6786fb9a01cc026522c\" target=\"_blank\" rel=\"noopener\">执行机制2</a></p>\n<p>小程序目前和<a href=\"https://quick.cn\" target=\"_blank\" rel=\"noopener\">快应用</a>‘打’成一片，有兴趣的可以了解一番，<br>跟Vue长的差不多<br>三大框架：<br></p>\n<p>目前正在学习angular和react，vue搁置了一段时间，三大框架给我的感觉，react是最复杂的（都学过才知道angular是看起来复杂，实际上并不难操作），当然指得是上手。<br><br><br><br>Vue是国产，市面上貌似有捧Vue的趋势，建议先从Vue入手，然后React，React Native可以写app，如果想早点接触移动端app，可以先学React，angular你看心情。<br><br><br><br>最近在刷面试题时，也会看到一些算法的题目，虽然前端对算法要求没有后台要求高，但是建议从现在开始，刷一些算法题，或尝试用js实现一些数据结构。实现可以看看<a href=\"https://blog.csdn.net/haoshidai/article/details/52263191\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n<p>最后，last but not least  前端最重要的还是js，原生js玩的熟，框架都是纸老虎<br>——来自渣渣学长的建议</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>作为一位即将离开的老学长，临走之前还是有些话要和学弟学妹们说的。</p>\n</blockquote>","more":"<h3 id=\"感触\"><a href=\"#感触\" class=\"headerlink\" title=\"感触\"></a>感触</h3><p>学前端有两年了，一个人摸摸索索走了很多弯路，回顾自己学习的时光，可惜的一点是，没有找到<br>和自己一样搞前端，互补的人。所以，我觉得16级的你们可以跟部门里的同学结伴，互补互足。之前开会时我说，<br>分小程序，框架，node，就是要你们在后面互相学习对方熟悉的部分，进步会快一点。</p>\n<h3 id=\"技术路线\"><a href=\"#技术路线\" class=\"headerlink\" title=\"技术路线\"></a>技术路线</h3><p>目前，H5和CSS3还有ES6已经不是新技术了，是要必须列入学习的计划的。</p>\n<p>从最基础的开始：<br></p>\n<p>HTML和css ：元素和api是看就能会用的，但是页面的布局（两列圣杯，弹性盒模型），元素之间（块级，内联，替代，非替代）的特点，定位，堆叠次序，BFC等，这些是基础，有必要深究的，一两个月的时间差不多，时间不能再多了。</p>\n<p>前端的重头戏始终在js上面，tc-39颁布的有es5，es6，es7（尚不稳定），有必要了解一下。<br>重点在this，原型，闭包，内存分配,深浅拷贝，执行机制（异步，同步，执行队列，宏任务，微任务，定时器，promise等）<br>this，原型，闭包这些在《你不知道的js》这本书里讲的很完美。<br>内存分配和执行机制可以在掘金里逛逛。<br><br>内存分配：<br><a href=\"https://juejin.im/post/597c5b71f265da3e3d122a3b\" target=\"_blank\" rel=\"noopener\">点我看看</a><br><br><br>深浅拷贝：<br><a href=\"https://github.com/Wscats/Good-text-Share/issues/57\" target=\"_blank\" rel=\"noopener\"></a><br><br><br>贴两篇关于执行机制的文章：可以参考一下<br><a href=\"https://juejin.im/post/59e85eebf265da430d571f89\" target=\"_blank\" rel=\"noopener\">执行机制1</a><br><a href=\"https://juejin.im/post/5a61a6786fb9a01cc026522c\" target=\"_blank\" rel=\"noopener\">执行机制2</a></p>\n<p>小程序目前和<a href=\"https://quick.cn\" target=\"_blank\" rel=\"noopener\">快应用</a>‘打’成一片，有兴趣的可以了解一番，<br>跟Vue长的差不多<br>三大框架：<br></p>\n<p>目前正在学习angular和react，vue搁置了一段时间，三大框架给我的感觉，react是最复杂的（都学过才知道angular是看起来复杂，实际上并不难操作），当然指得是上手。<br><br><br><br>Vue是国产，市面上貌似有捧Vue的趋势，建议先从Vue入手，然后React，React Native可以写app，如果想早点接触移动端app，可以先学React，angular你看心情。<br><br><br><br>最近在刷面试题时，也会看到一些算法的题目，虽然前端对算法要求没有后台要求高，但是建议从现在开始，刷一些算法题，或尝试用js实现一些数据结构。实现可以看看<a href=\"https://blog.csdn.net/haoshidai/article/details/52263191\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n<p>最后，last but not least  前端最重要的还是js，原生js玩的熟，框架都是纸老虎<br>——来自渣渣学长的建议</p>"},{"title":"封培总结","date":"2019-07-22T02:44:48.000Z","_content":">正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’\n\n<!--more-->\n\n此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。\n\n+ 难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。\n\n### 优点:\n+ 帮助另外非react技术栈的同学开发。\n+ 能够为遇到的问题提供合适的解决方案。\n+ 开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。\n\n### 不足：\n+ 在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。\n+ 功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。\n+ 前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。\n+ 部分接口缺少mock。\n\t\n\n### 收获以及感悟：\n+ 在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。\n+ 功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。\n+ 在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。\n\n\n此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。","source":"_posts/封培总结.md","raw":"---\ntitle: 封培总结\ndate: 2019-07-22 10:44:48\ntags: \ncategories:\n---\n>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’\n\n<!--more-->\n\n此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。\n\n+ 难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。\n\n### 优点:\n+ 帮助另外非react技术栈的同学开发。\n+ 能够为遇到的问题提供合适的解决方案。\n+ 开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。\n\n### 不足：\n+ 在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。\n+ 功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。\n+ 前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。\n+ 部分接口缺少mock。\n\t\n\n### 收获以及感悟：\n+ 在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。\n+ 功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。\n+ 在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。\n\n\n此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。","slug":"封培总结","published":1,"updated":"2019-07-22T02:49:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrsy001khvs6ob0rphue","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。</p>\n<ul>\n<li>难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>帮助另外非react技术栈的同学开发。</li>\n<li>能够为遇到的问题提供合适的解决方案。</li>\n<li>开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。</li>\n</ul>\n<h3 id=\"不足：\"><a href=\"#不足：\" class=\"headerlink\" title=\"不足：\"></a>不足：</h3><ul>\n<li>在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。</li>\n<li>功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。</li>\n<li>前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。</li>\n<li>部分接口缺少mock。</li>\n</ul>\n<h3 id=\"收获以及感悟：\"><a href=\"#收获以及感悟：\" class=\"headerlink\" title=\"收获以及感悟：\"></a>收获以及感悟：</h3><ul>\n<li>在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。</li>\n<li>功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。</li>\n<li>在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。</li>\n</ul>\n<p>此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’</p>\n</blockquote>","more":"<p>此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。</p>\n<ul>\n<li>难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>帮助另外非react技术栈的同学开发。</li>\n<li>能够为遇到的问题提供合适的解决方案。</li>\n<li>开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。</li>\n</ul>\n<h3 id=\"不足：\"><a href=\"#不足：\" class=\"headerlink\" title=\"不足：\"></a>不足：</h3><ul>\n<li>在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。</li>\n<li>功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。</li>\n<li>前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。</li>\n<li>部分接口缺少mock。</li>\n</ul>\n<h3 id=\"收获以及感悟：\"><a href=\"#收获以及感悟：\" class=\"headerlink\" title=\"收获以及感悟：\"></a>收获以及感悟：</h3><ul>\n<li>在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。</li>\n<li>功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。</li>\n<li>在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。</li>\n</ul>\n<p>此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。</p>"},{"title":"Array","date":"2018-01-13T06:30:15.000Z","_content":"\n>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。\n\n<!--more-->\n\n### Array.length\nlength是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br>\n它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：\n```bash\nvar a=[1,,3];\nconsole.log(a[0]);//1\n\nconsole.log(a[2]);//3\n\nconsole.log(a.length);//长度为3\n\n```\n如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。\n代码如下：\n```bash\nvar a=[1,2,3];\na[-1]='c';\n\nconsole.log(a.length);//3\nconsole.log(a[-1]);//c\nconsole.log(a);//[1, 2, 3, -1: \"c\"]\n\n```\n<strong>故length有时并不能体现一个数组的真实长度</strong>\n另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。\n```bash\n\nvar a1=[1,2,3];\nvar a2=a1;\na1.length=0;//清空数组，是对对象本身的操作\nconsole.log(a2) //[]\n\nvar a3=[4,5,6];\nvar a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，\na3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值\nconsole.log(a4)//[4,5,6]\n\n```\n### Array.method\n\n#### push\n该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。\n```bash\nvar a=[1,2,3];\na.push(4); //a [1,2,3,4]\n\na.push(5,6);//a [1,2,3,4,5,6]\n\nvar b= a.push(7) ;\nconsole.log(b); //b=7\n```\n\n#### pop\n与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素\n```bash\nvar a=[1,2,3];\na.pop(); //a [1,2]\n\n```\n#### shift\n该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。\n与push方法常用来解决约瑟夫环的问题。代码如下：\n```Bash\nvar a=[1,2,3,4,5,6,7,8];\nfunction circle(arr,flag){\n  var count = 0;\n  while(arr.length>1){\n      var e =arr.shift();\n    if(++count == flag){\n      count=0;\n      continue;\n    }\n    arr.push(e);\n  }\n  console.log(arr);\n}\ncircle(a,3);\n//[ 7 ]\n\n```\n#### unshift\n与shift相反的是unshift，往数组头部添加一个元素。\n\n\n#### delete\n与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。\n```bash\nvar a=[1,2,3];\ndelete a[0];\nconsole.log(a);//[2, 3]\nconsole.log(a.length); //3\n```\n#### forEach\n该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。\n<em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em>\n```bash\nvar a=[1,,3];\n\na[-1]='c';\n\na.forEach(function(item,index){\n  console.log(index,item);\n  //输出为\n  //0 1\n  //2 3\n})\n```\n#### every\n语法：array.every(function(currentValue,index,arr), thisValue)\n在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。\n换个浅显的解释：\n```bash\nvar a=[{name:'Jack',age:15},{name:'Tom',age:13}];\na.every(function(value,index){\n  此时value和index是一一对应的\n  当index==0时，value代表{name:'Jack',age:15}\n  当index==1时，value代表{name:'Tom',age:13}\n});\n\n```\n<br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。\n```bash\nfunction isEven(num){\n  return num%2===0;\n}\nvar nums = [2,4,6,8];\nvar even = nums.every(isEven);\nif(even){\n  console.log('所有元素均为偶数');\n}else{\n  ocnsole.log('并不是所有的数字皆为偶数');\n}\n```\n\n\n#### map\n该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。\n```Bash\nvar m=['a',,'c'];\nvar n=m.map(function(e){\n    return e = e+'z';\n  })\n  console.log(n);\n//[ 'az', <1 empty item>, 'cz' ]\n\n```\n<em>ps:关于数组遍历函数的比较有张图描述的特别好<em>\n​\n![](http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png)\n\n#### sort\n该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color='blue'>而是按首字符（多为数字按第一位）<font>。代码如下：\n```Bash\n//数字\nvar a=[1,3,4,7,2,5,13,30];\n\na.sort();\n\nconsole.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]\n\n```\n示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。\n\n#### reverse\n该方法会反转数组，会改变原数组，返回的是反转后的数组。\n```Bash\nvar a=[1,3,4,7,2,5,13,30];\n\nconsole.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n\nconsole.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n```\n\n#### splice\n该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br>\n参数一：截取的起始索引。<br>\n参数二：截取的长度。<br>\n参数三：删除截取后要添加进去数组的元素（可以是个数组）。\n```bash\n\nvar nums = [1,2,3,7,8,9];\nvar newElements = [4,5,6];\nnums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)\nconsole.log(nums); // 1,2,3,4,5,6,7,8,9\n```\n#### find\n该方法返回通过函数内判断的数组的第一个元素的值。\n```bash\nvar ages = [3, 10, 18, 20];\nfunction checkAdult(age) {\n    return age >= 18;\n}\nfunction myFunction() {\n    document.getElementById(\"demo\").innerHTML = ages.find(checkAdult);\n}\n```\n### 类数组\n除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy...方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br>\n类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。\n","source":"_posts/Array.md","raw":"---\ntitle: Array\ndate: 2018-01-13 14:30:15\ntags: javascript\ncategories: 学习\n---\n\n>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。\n\n<!--more-->\n\n### Array.length\nlength是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br>\n它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：\n```bash\nvar a=[1,,3];\nconsole.log(a[0]);//1\n\nconsole.log(a[2]);//3\n\nconsole.log(a.length);//长度为3\n\n```\n如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。\n代码如下：\n```bash\nvar a=[1,2,3];\na[-1]='c';\n\nconsole.log(a.length);//3\nconsole.log(a[-1]);//c\nconsole.log(a);//[1, 2, 3, -1: \"c\"]\n\n```\n<strong>故length有时并不能体现一个数组的真实长度</strong>\n另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。\n```bash\n\nvar a1=[1,2,3];\nvar a2=a1;\na1.length=0;//清空数组，是对对象本身的操作\nconsole.log(a2) //[]\n\nvar a3=[4,5,6];\nvar a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，\na3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值\nconsole.log(a4)//[4,5,6]\n\n```\n### Array.method\n\n#### push\n该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。\n```bash\nvar a=[1,2,3];\na.push(4); //a [1,2,3,4]\n\na.push(5,6);//a [1,2,3,4,5,6]\n\nvar b= a.push(7) ;\nconsole.log(b); //b=7\n```\n\n#### pop\n与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素\n```bash\nvar a=[1,2,3];\na.pop(); //a [1,2]\n\n```\n#### shift\n该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。\n与push方法常用来解决约瑟夫环的问题。代码如下：\n```Bash\nvar a=[1,2,3,4,5,6,7,8];\nfunction circle(arr,flag){\n  var count = 0;\n  while(arr.length>1){\n      var e =arr.shift();\n    if(++count == flag){\n      count=0;\n      continue;\n    }\n    arr.push(e);\n  }\n  console.log(arr);\n}\ncircle(a,3);\n//[ 7 ]\n\n```\n#### unshift\n与shift相反的是unshift，往数组头部添加一个元素。\n\n\n#### delete\n与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。\n```bash\nvar a=[1,2,3];\ndelete a[0];\nconsole.log(a);//[2, 3]\nconsole.log(a.length); //3\n```\n#### forEach\n该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。\n<em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em>\n```bash\nvar a=[1,,3];\n\na[-1]='c';\n\na.forEach(function(item,index){\n  console.log(index,item);\n  //输出为\n  //0 1\n  //2 3\n})\n```\n#### every\n语法：array.every(function(currentValue,index,arr), thisValue)\n在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。\n换个浅显的解释：\n```bash\nvar a=[{name:'Jack',age:15},{name:'Tom',age:13}];\na.every(function(value,index){\n  此时value和index是一一对应的\n  当index==0时，value代表{name:'Jack',age:15}\n  当index==1时，value代表{name:'Tom',age:13}\n});\n\n```\n<br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。\n```bash\nfunction isEven(num){\n  return num%2===0;\n}\nvar nums = [2,4,6,8];\nvar even = nums.every(isEven);\nif(even){\n  console.log('所有元素均为偶数');\n}else{\n  ocnsole.log('并不是所有的数字皆为偶数');\n}\n```\n\n\n#### map\n该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。\n```Bash\nvar m=['a',,'c'];\nvar n=m.map(function(e){\n    return e = e+'z';\n  })\n  console.log(n);\n//[ 'az', <1 empty item>, 'cz' ]\n\n```\n<em>ps:关于数组遍历函数的比较有张图描述的特别好<em>\n​\n![](http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png)\n\n#### sort\n该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color='blue'>而是按首字符（多为数字按第一位）<font>。代码如下：\n```Bash\n//数字\nvar a=[1,3,4,7,2,5,13,30];\n\na.sort();\n\nconsole.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]\n\n```\n示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。\n\n#### reverse\n该方法会反转数组，会改变原数组，返回的是反转后的数组。\n```Bash\nvar a=[1,3,4,7,2,5,13,30];\n\nconsole.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n\nconsole.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]\n```\n\n#### splice\n该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br>\n参数一：截取的起始索引。<br>\n参数二：截取的长度。<br>\n参数三：删除截取后要添加进去数组的元素（可以是个数组）。\n```bash\n\nvar nums = [1,2,3,7,8,9];\nvar newElements = [4,5,6];\nnums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)\nconsole.log(nums); // 1,2,3,4,5,6,7,8,9\n```\n#### find\n该方法返回通过函数内判断的数组的第一个元素的值。\n```bash\nvar ages = [3, 10, 18, 20];\nfunction checkAdult(age) {\n    return age >= 18;\n}\nfunction myFunction() {\n    document.getElementById(\"demo\").innerHTML = ages.find(checkAdult);\n}\n```\n### 类数组\n除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy...方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br>\n类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。\n","slug":"Array","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskrt0001phvs6vr5hmf2j","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Array-length\"><a href=\"#Array-length\" class=\"headerlink\" title=\"Array.length\"></a>Array.length</h3><p>length是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br><br>它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\">console.log(a[0]);//1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a[2]);//3</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//长度为3</span><br></pre></td></tr></table></figure></p>\n<p>如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。<br>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//3</span><br><span class=\"line\">console.log(a[-1]);//c</span><br><span class=\"line\">console.log(a);//[1, 2, 3, -1: <span class=\"string\">\"c\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p><strong>故length有时并不能体现一个数组的真实长度</strong><br>另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var a1=[1,2,3];</span><br><span class=\"line\">var a2=a1;</span><br><span class=\"line\">a1.length=0;//清空数组，是对对象本身的操作</span><br><span class=\"line\">console.log(a2) //[]</span><br><span class=\"line\"></span><br><span class=\"line\">var a3=[4,5,6];</span><br><span class=\"line\">var a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，</span><br><span class=\"line\">a3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值</span><br><span class=\"line\">console.log(a4)//[4,5,6]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-method\"><a href=\"#Array-method\" class=\"headerlink\" title=\"Array.method\"></a>Array.method</h3><h4 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h4><p>该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.push(4); //a [1,2,3,4]</span><br><span class=\"line\"></span><br><span class=\"line\">a.push(5,6);//a [1,2,3,4,5,6]</span><br><span class=\"line\"></span><br><span class=\"line\">var b= a.push(7) ;</span><br><span class=\"line\">console.log(b); //b=7</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h4><p>与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.pop(); //a [1,2]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h4><p>该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。<br>与push方法常用来解决约瑟夫环的问题。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3,4,5,6,7,8];</span><br><span class=\"line\"><span class=\"keyword\">function</span> circle(arr,flag)&#123;</span><br><span class=\"line\">  var count = 0;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.length&gt;1)&#123;</span><br><span class=\"line\">      var e =arr.shift();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(++count == flag)&#123;</span><br><span class=\"line\">      count=0;</span><br><span class=\"line\">      <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr.push(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">circle(a,3);</span><br><span class=\"line\">//[ 7 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h4><p>与shift相反的是unshift，往数组头部添加一个元素。</p>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h4><p>与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">delete a[0];</span><br><span class=\"line\">console.log(a);//[2, 3]</span><br><span class=\"line\">console.log(a.length); //3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h4><p>该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。<br><em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\"></span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a.forEach(<span class=\"keyword\">function</span>(item,index)&#123;</span><br><span class=\"line\">  console.log(index,item);</span><br><span class=\"line\">  //输出为</span><br><span class=\"line\">  //0 1</span><br><span class=\"line\">  //2 3</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h4><p>语法：array.every(function(currentValue,index,arr), thisValue)<br>在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。<br>换个浅显的解释：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;,&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;];</span><br><span class=\"line\">a.every(<span class=\"keyword\">function</span>(value,index)&#123;</span><br><span class=\"line\">  此时value和index是一一对应的</span><br><span class=\"line\">  当index==0时，value代表&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;</span><br><span class=\"line\">  当index==1时，value代表&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> isEven(num)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> num%2===0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var nums = [2,4,6,8];</span><br><span class=\"line\">var even = nums.every(isEven);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(even)&#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">'所有元素均为偶数'</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  ocnsole.log(<span class=\"string\">'并不是所有的数字皆为偶数'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var m=[<span class=\"string\">'a'</span>,,<span class=\"string\">'c'</span>];</span><br><span class=\"line\">var n=m.map(<span class=\"keyword\">function</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> e = e+<span class=\"string\">'z'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  console.log(n);</span><br><span class=\"line\">//[ <span class=\"string\">'az'</span>, &lt;1 empty item&gt;, <span class=\"string\">'cz'</span> ]</span><br></pre></td></tr></table></figure></p>\n<p><em>ps:关于数组遍历函数的比较有张图描述的特别好<em><br>​<br><img src=\"http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png\" alt=\"\"></em></em></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color=\"blue\">而是按首字符（多为数字按第一位）<font>。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数字</span><br><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">a.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]</span><br></pre></td></tr></table></figure></font></font></p>\n<p>示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>该方法会反转数组，会改变原数组，返回的是反转后的数组。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p>该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br><br>参数一：截取的起始索引。<br><br>参数二：截取的长度。<br><br>参数三：删除截取后要添加进去数组的元素（可以是个数组）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var nums = [1,2,3,7,8,9];</span><br><span class=\"line\">var newElements = [4,5,6];</span><br><span class=\"line\">nums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)</span><br><span class=\"line\">console.log(nums); // 1,2,3,4,5,6,7,8,9</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h4><p>该方法返回通过函数内判断的数组的第一个元素的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ages = [3, 10, 18, 20];</span><br><span class=\"line\"><span class=\"keyword\">function</span> checkAdult(age) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> age &gt;= 18;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">myFunction</span></span>() &#123;</span><br><span class=\"line\">    document.getElementById(<span class=\"string\">\"demo\"</span>).innerHTML = ages.find(checkAdult);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><p>除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy…方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br><br>类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>javascript数组和Function一样，继承自Object，是引用类型，<em>不是</em>javascript基本类型。关于数组有很多要注意的地方。</p>\n</blockquote>","more":"<h3 id=\"Array-length\"><a href=\"#Array-length\" class=\"headerlink\" title=\"Array.length\"></a>Array.length</h3><p>length是数组的属性，指的是数组的长度，但是有一些要注意的地方。<br><br>它会把空元素计算进去，但是通过索引不会找到该元素》代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\">console.log(a[0]);//1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a[2]);//3</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//长度为3</span><br></pre></td></tr></table></figure></p>\n<p>如果把映射填充到数组里，length不会计算他的长度。但是通过索引key可以找的到。<br>代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.length);//3</span><br><span class=\"line\">console.log(a[-1]);//c</span><br><span class=\"line\">console.log(a);//[1, 2, 3, -1: <span class=\"string\">\"c\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p><strong>故length有时并不能体现一个数组的真实长度</strong><br>另外清空数组时，经常用的两种方法arr.length=0与arr=[]是有区别的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var a1=[1,2,3];</span><br><span class=\"line\">var a2=a1;</span><br><span class=\"line\">a1.length=0;//清空数组，是对对象本身的操作</span><br><span class=\"line\">console.log(a2) //[]</span><br><span class=\"line\"></span><br><span class=\"line\">var a3=[4,5,6];</span><br><span class=\"line\">var a4=a3;//a3  a4  是两个引用，指向的是同一个对象，同一个地址，</span><br><span class=\"line\">a3=[];  //清空数组，不会影响a4，是对引用的操作，是重新赋值</span><br><span class=\"line\">console.log(a4)//[4,5,6]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-method\"><a href=\"#Array-method\" class=\"headerlink\" title=\"Array.method\"></a>Array.method</h3><h4 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h4><p>该方法会将参数填充到数组的最后面，参数可以是一个，也可以是多个，返回值是数组的长度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.push(4); //a [1,2,3,4]</span><br><span class=\"line\"></span><br><span class=\"line\">a.push(5,6);//a [1,2,3,4,5,6]</span><br><span class=\"line\"></span><br><span class=\"line\">var b= a.push(7) ;</span><br><span class=\"line\">console.log(b); //b=7</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h4><p>与push方法相反的是pop方法，该方法会将数组最后一位删除，数组长度减一，返回的是被删除的元素<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">a.pop(); //a [1,2]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h4><p>该方法是用来删除数组的第一个元素，返回的是被删除的元素，原数组会发生改变。<br>与push方法常用来解决约瑟夫环的问题。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3,4,5,6,7,8];</span><br><span class=\"line\"><span class=\"keyword\">function</span> circle(arr,flag)&#123;</span><br><span class=\"line\">  var count = 0;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.length&gt;1)&#123;</span><br><span class=\"line\">      var e =arr.shift();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(++count == flag)&#123;</span><br><span class=\"line\">      count=0;</span><br><span class=\"line\">      <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr.push(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">circle(a,3);</span><br><span class=\"line\">//[ 7 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h4><p>与shift相反的是unshift，往数组头部添加一个元素。</p>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h4><p>与pop相似的方法有delete，delete像一个操作符，该方法不会影响数组长度，删除后的元素变为空,原来的位置会被后面的顶替。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">delete a[0];</span><br><span class=\"line\">console.log(a);//[2, 3]</span><br><span class=\"line\">console.log(a.length); //3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h4><p>该方法会对数组进行遍历，参数是一个回调函数，函数的第一个参数是value，第二个参数是索引。<br><em>该方法不会遍历空的元素，也不会遍历映射，似乎没有什么办法让函数停止遍历。若有需求，推荐使用every方法。</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,,3];</span><br><span class=\"line\"></span><br><span class=\"line\">a[-1]=<span class=\"string\">'c'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a.forEach(<span class=\"keyword\">function</span>(item,index)&#123;</span><br><span class=\"line\">  console.log(index,item);</span><br><span class=\"line\">  //输出为</span><br><span class=\"line\">  //0 1</span><br><span class=\"line\">  //2 3</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h4><p>语法：array.every(function(currentValue,index,arr), thisValue)<br>在every的回调里可以通过return  false;来终止遍历。而return true;可以终止本次遍历，这个函数在写业务代码时，用到的几率挺大的。<br>换个浅显的解释：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;,&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;];</span><br><span class=\"line\">a.every(<span class=\"keyword\">function</span>(value,index)&#123;</span><br><span class=\"line\">  此时value和index是一一对应的</span><br><span class=\"line\">  当index==0时，value代表&#123;name:<span class=\"string\">'Jack'</span>,age:15&#125;</span><br><span class=\"line\">  当index==1时，value代表&#123;name:<span class=\"string\">'Tom'</span>,age:13&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><br> 另外如果对于所有的元素，该函数均返回 true， 则该方法返回 true。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> isEven(num)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> num%2===0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var nums = [2,4,6,8];</span><br><span class=\"line\">var even = nums.every(isEven);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(even)&#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">'所有元素均为偶数'</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  ocnsole.log(<span class=\"string\">'并不是所有的数字皆为偶数'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>该方法也会对数组进行遍历，遍历时会跳过空元素，参数是一个回调函数，回调函数的参数是数组的单个元素,map返回的是一个新的数组，新数组的元素是原始数组的元素应用该回调函数的结果。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var m=[<span class=\"string\">'a'</span>,,<span class=\"string\">'c'</span>];</span><br><span class=\"line\">var n=m.map(<span class=\"keyword\">function</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> e = e+<span class=\"string\">'z'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  console.log(n);</span><br><span class=\"line\">//[ <span class=\"string\">'az'</span>, &lt;1 empty item&gt;, <span class=\"string\">'cz'</span> ]</span><br></pre></td></tr></table></figure></p>\n<p><em>ps:关于数组遍历函数的比较有张图描述的特别好<em><br>​<br><img src=\"http://xuyonglinblog.oss-cn-beijing.aliyuncs.com/array.png\" alt=\"\"></em></em></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>该方法会对数组进行排序，要注意的是，它并不是按大小从大往小排序的，<font color=\"blue\">而是按首字符（多为数字按第一位）<font>。代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数字</span><br><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">a.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 1, 13, 2, 3, 30, 4, 5, 7 ]</span><br></pre></td></tr></table></figure></font></font></p>\n<p>示例只是以数字为例，如果数组里是字符串，则按首字符排序，如果含有数字和字符，则先排数字，再排字符。</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>该方法会反转数组，会改变原数组，返回的是反转后的数组。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,3,4,7,2,5,13,30];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.reverse());//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);//[ 30, 13, 5, 2, 7, 4, 3, 1 ]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p>该方法对现有数组进行截取，返回新生出的数组，且原数组发生改变，就是生成的数组。<br><br>参数一：截取的起始索引。<br><br>参数二：截取的长度。<br><br>参数三：删除截取后要添加进去数组的元素（可以是个数组）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var nums = [1,2,3,7,8,9];</span><br><span class=\"line\">var newElements = [4,5,6];</span><br><span class=\"line\">nums.splice(3,0,newElements);//也可以nums.splice(3,0,4,5,6)</span><br><span class=\"line\">console.log(nums); // 1,2,3,4,5,6,7,8,9</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h4><p>该方法返回通过函数内判断的数组的第一个元素的值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ages = [3, 10, 18, 20];</span><br><span class=\"line\"><span class=\"keyword\">function</span> checkAdult(age) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> age &gt;= 18;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">myFunction</span></span>() &#123;</span><br><span class=\"line\">    document.getElementById(<span class=\"string\">\"demo\"</span>).innerHTML = ages.find(checkAdult);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><p>除了数组以外，我们还会经常碰到一些类数组(array-like),比如arguments,通过document.getElementsBy…方法得到的HTMLCollection以及通过querySelector方法得到的NodeList，包括jquery对象，其实都是类数组。<br><br>类数组不是数组，最明显的区别就是，不能使用pop，push等方法，nodelist能使用forEach是因为nodelist的原型上有这个方法，但是HTMLCollection没有。</p>"},{"title":"JSX","date":"2018-04-05T04:25:14.000Z","_content":"\n>学了React有差不多俩星期了，做个总结。\n\n### 什么是JSX\n\nJSX=JavaScriptXml<br>\nJSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。\n\n<!--more-->\n\n### javascript表达式\n\n要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（\"\"）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。\n\n### 关于用法和注意事项\n\n官网有一篇深入JSX[点击这里](https://doc.react-china.org/docs/jsx-in-depth.html)\n\n###  组件是啥\n```bash\nconsole.log(<App/>)\n```\n如图所示：\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png)\n\nas  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。\n接下来\n```bash\nconsole.log(<ToDoList name={'todo'} onClick={()=>{console.log('ss')}}/>)<br>\n```\n\n在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png);\n可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。\n可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开[在线Babel编译器](https://babeljs.io/repl)，输入\n```bash\nfunction hello(){\n  return (<div>hello</div>)\n}\n```\n可以看到![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png)\nbabel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。\n那么这个函数是干嘛使得呢？o98k，接下来好好看看。\n\n### createElemnt\n首先把React源码的地址贴上，[REACT源码](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js)，有兴趣的小伙伴可以复制下来看看。\n在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。\n\n在源码的481行，可以找到这个函数，他有三个参数：\n+ type 标签名\n+ config 配置信息className，事件啥的，没有则为null\n+ children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是'hello'，有意思的时当里面的元素是嵌套了一层的话，比如\n```bash\nreturn (<div><p>sss</p></div>)\n```\n那么children对应的值就是React.createElement的返回结果。\n这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件\n\n\n```bash\nfunction TodoItem(){\n  reutn (<div className=\"foo\"  onClick={()=>{cconsole.log('sss')}} >\n           <p>sss</p>\n        </div>)\n}\n\n\n<TodoItem />\n```\n在右边可以看到如下代码\n```bash\n\"use strict\";\n\nfunction TodoItem() {\n  reutn(React.createElement(\n    \"div\",\n    { className: \"foo\", onClick: function onClick() {\n        cconsole.log('sss');\n      } },\n    React.createElement(\n      \"p\",\n      null,\n      \"sss\"\n    )\n  ));\n}\n\nReact.createElement(TodoItem, null);\n\n```\n\n可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。\n\ncreateElement源码：\n\n```bash\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName;\n\n  // 内置静态变量，作为参数传递给ReactElement方法\n\n  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n    //todo self 和 source 都是通过 props 传入的\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source\n        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n\n  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  //todo 把组件的默认属性值赋予组件的实例上\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n```\n\n看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。\n但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。\n\n### ReactElement\n先看参数\n+ type: 使用 React.createElement创建的 React 组件\n+ key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能\n+ ref: 这个 ReactElement 的 ref，真实DOM的引用\n+ props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)\n+ self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。\n+ source: 中包含了一些文件名称，行号等信息。\n+ owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。\nReactElement 这个函数只是将以上参数放入一个对象，并返回。\n源码如下：\n```bash\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    //作为ReactElement的标识，运用ES6的Symbol\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n\n    element._store = {};\n\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n```\n该方法在其他方法中也经常被调用，结果被return。\n\n### React.Component\n\n我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。\n```bash\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n```\n贴张图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png)\n","source":"_posts/JSX.md","raw":"---\ntitle: JSX\ndate: 2018-04-05 12:25:14\ntags: react\ncategories: 学习\n---\n\n>学了React有差不多俩星期了，做个总结。\n\n### 什么是JSX\n\nJSX=JavaScriptXml<br>\nJSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。\n\n<!--more-->\n\n### javascript表达式\n\n要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（\"\"）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。\n\n### 关于用法和注意事项\n\n官网有一篇深入JSX[点击这里](https://doc.react-china.org/docs/jsx-in-depth.html)\n\n###  组件是啥\n```bash\nconsole.log(<App/>)\n```\n如图所示：\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png)\n\nas  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。\n接下来\n```bash\nconsole.log(<ToDoList name={'todo'} onClick={()=>{console.log('ss')}}/>)<br>\n```\n\n在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png);\n可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。\n可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开[在线Babel编译器](https://babeljs.io/repl)，输入\n```bash\nfunction hello(){\n  return (<div>hello</div>)\n}\n```\n可以看到![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png)\nbabel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。\n那么这个函数是干嘛使得呢？o98k，接下来好好看看。\n\n### createElemnt\n首先把React源码的地址贴上，[REACT源码](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js)，有兴趣的小伙伴可以复制下来看看。\n在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。\n\n在源码的481行，可以找到这个函数，他有三个参数：\n+ type 标签名\n+ config 配置信息className，事件啥的，没有则为null\n+ children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是'hello'，有意思的时当里面的元素是嵌套了一层的话，比如\n```bash\nreturn (<div><p>sss</p></div>)\n```\n那么children对应的值就是React.createElement的返回结果。\n这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件\n\n\n```bash\nfunction TodoItem(){\n  reutn (<div className=\"foo\"  onClick={()=>{cconsole.log('sss')}} >\n           <p>sss</p>\n        </div>)\n}\n\n\n<TodoItem />\n```\n在右边可以看到如下代码\n```bash\n\"use strict\";\n\nfunction TodoItem() {\n  reutn(React.createElement(\n    \"div\",\n    { className: \"foo\", onClick: function onClick() {\n        cconsole.log('sss');\n      } },\n    React.createElement(\n      \"p\",\n      null,\n      \"sss\"\n    )\n  ));\n}\n\nReact.createElement(TodoItem, null);\n\n```\n\n可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。\n\ncreateElement源码：\n\n```bash\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName;\n\n  // 内置静态变量，作为参数传递给ReactElement方法\n\n  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n    //todo self 和 source 都是通过 props 传入的\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source\n        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n\n  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  //todo 把组件的默认属性值赋予组件的实例上\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n```\n\n看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。\n但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。\n\n### ReactElement\n先看参数\n+ type: 使用 React.createElement创建的 React 组件\n+ key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能\n+ ref: 这个 ReactElement 的 ref，真实DOM的引用\n+ props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)\n+ self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。\n+ source: 中包含了一些文件名称，行号等信息。\n+ owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。\nReactElement 这个函数只是将以上参数放入一个对象，并返回。\n源码如下：\n```bash\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    //作为ReactElement的标识，运用ES6的Symbol\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n\n    element._store = {};\n\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n```\n该方法在其他方法中也经常被调用，结果被return。\n\n### React.Component\n\n我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。\n```bash\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n```\n贴张图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png)\n","slug":"JSX","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskst60023hvs6uruyhyh3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>学了React有差不多俩星期了，做个总结。</p>\n</blockquote>\n<h3 id=\"什么是JSX\"><a href=\"#什么是JSX\" class=\"headerlink\" title=\"什么是JSX\"></a>什么是JSX</h3><p>JSX=JavaScriptXml<br><br>JSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。</p>\n<a id=\"more\"></a>\n<h3 id=\"javascript表达式\"><a href=\"#javascript表达式\" class=\"headerlink\" title=\"javascript表达式\"></a>javascript表达式</h3><p>要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（””）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。</p>\n<h3 id=\"关于用法和注意事项\"><a href=\"#关于用法和注意事项\" class=\"headerlink\" title=\"关于用法和注意事项\"></a>关于用法和注意事项</h3><p>官网有一篇深入JSX<a href=\"https://doc.react-china.org/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h3 id=\"组件是啥\"><a href=\"#组件是啥\" class=\"headerlink\" title=\"组件是啥\"></a>组件是啥</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;App/&gt;)</span><br></pre></td></tr></table></figure>\n<p>如图所示：<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png\" alt=\"\"></p>\n<p>as  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。<br>接下来<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;ToDoList name=&#123;<span class=\"string\">'todo'</span>&#125; onClick=&#123;()=&gt;&#123;console.log(<span class=\"string\">'ss'</span>)&#125;&#125;/&gt;)&lt;br&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png\" alt=\"\">;<br>可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。<br>可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开<a href=\"https://babeljs.io/repl\" target=\"_blank\" rel=\"noopener\">在线Babel编译器</a>，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">hello</span></span>()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (&lt;div&gt;hello&lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png\" alt=\"\"><br>babel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。<br>那么这个函数是干嘛使得呢？o98k，接下来好好看看。</p>\n<h3 id=\"createElemnt\"><a href=\"#createElemnt\" class=\"headerlink\" title=\"createElemnt\"></a>createElemnt</h3><p>首先把React源码的地址贴上，<a href=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js\" target=\"_blank\" rel=\"noopener\">REACT源码</a>，有兴趣的小伙伴可以复制下来看看。<br>在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。</p>\n<p>在源码的481行，可以找到这个函数，他有三个参数：</p>\n<ul>\n<li>type 标签名</li>\n<li>config 配置信息className，事件啥的，没有则为null</li>\n<li>children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是’hello’，有意思的时当里面的元素是嵌套了一层的话，比如<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">return</span> (&lt;div&gt;&lt;p&gt;sss&lt;/p&gt;&lt;/div&gt;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>那么children对应的值就是React.createElement的返回结果。<br>这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>()&#123;</span><br><span class=\"line\">  reutn (&lt;div className=<span class=\"string\">\"foo\"</span>  onClick=&#123;()=&gt;&#123;cconsole.log(<span class=\"string\">'sss'</span>)&#125;&#125; &gt;</span><br><span class=\"line\">           &lt;p&gt;sss&lt;/p&gt;</span><br><span class=\"line\">        &lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;TodoItem /&gt;</span><br></pre></td></tr></table></figure>\n<p>在右边可以看到如下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>() &#123;</span><br><span class=\"line\">  reutn(React.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    &#123; className: <span class=\"string\">\"foo\"</span>, onClick: <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">onClick</span></span>() &#123;</span><br><span class=\"line\">        cconsole.log(<span class=\"string\">'sss'</span>);</span><br><span class=\"line\">      &#125; &#125;,</span><br><span class=\"line\">    React.createElement(</span><br><span class=\"line\">      <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">      null,</span><br><span class=\"line\">      <span class=\"string\">\"sss\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  ));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">React.createElement(TodoItem, null);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。</p>\n<p>createElement源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Create and <span class=\"built_in\">return</span> a new ReactElement of the given <span class=\"built_in\">type</span>.</span><br><span class=\"line\"> * See https://reactjs.org/docs/react-api.html<span class=\"comment\">#createelement</span></span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> createElement(<span class=\"built_in\">type</span>, config, children) &#123;</span><br><span class=\"line\">  var propName;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 内置静态变量，作为参数传递给ReactElement方法</span><br><span class=\"line\"></span><br><span class=\"line\">  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性</span><br><span class=\"line\">  var props = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var key = null;</span><br><span class=\"line\">  var ref = null;</span><br><span class=\"line\">  var self = null;</span><br><span class=\"line\">  var <span class=\"built_in\">source</span> = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config != null) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"string\">''</span> + config.key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //todo self 和 <span class=\"built_in\">source</span> 都是通过 props 传入的</span><br><span class=\"line\">    self = config.__self === undefined ? null : config.__self;</span><br><span class=\"line\">    <span class=\"built_in\">source</span> = config.__source === undefined ? null : config.__source;</span><br><span class=\"line\">    // Remaining properties are added to a new props object</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> config) &#123;</span><br><span class=\"line\">        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class=\"line\">        props[propName] = config[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。</span><br><span class=\"line\">  var childrenLength = arguments.length - 2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childrenLength === 1) &#123;</span><br><span class=\"line\">    props.children = children;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenLength &gt; 1) &#123;</span><br><span class=\"line\">    var childArray = Array(childrenLength);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class=\"line\">      childArray[i] = arguments[i + 2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">        Object.freeze(childArray);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    props.children = childArray;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //todo 把组件的默认属性值赋予组件的实例上</span><br><span class=\"line\">  // Resolve default props</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">type</span> &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    var defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> defaultProps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (props[propName] === undefined) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key || ref) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (typeof props.$<span class=\"variable\">$typeof</span> === <span class=\"string\">'undefined'</span> || props.$<span class=\"variable\">$typeof</span> !== REACT_ELEMENT_TYPE) &#123;</span><br><span class=\"line\">        var displayName = typeof <span class=\"built_in\">type</span> === <span class=\"string\">'function'</span> ? type.displayName || type.name || <span class=\"string\">'Unknown'</span> : <span class=\"built_in\">type</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key) &#123;</span><br><span class=\"line\">          defineKeyPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ref) &#123;</span><br><span class=\"line\">          defineRefPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> ReactElement(<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, ReactCurrentOwner.current, props);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。<br>但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。</p>\n<h3 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h3><p>先看参数</p>\n<ul>\n<li>type: 使用 React.createElement创建的 React 组件</li>\n<li>key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能</li>\n<li>ref: 这个 ReactElement 的 ref，真实DOM的引用</li>\n<li>props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)</li>\n<li>self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。</li>\n<li>source: 中包含了一些文件名称，行号等信息。</li>\n<li>owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。<br>ReactElement 这个函数只是将以上参数放入一个对象，并返回。<br>源码如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Factory method to create a new React element. This no longer adheres to</span><br><span class=\"line\"> * the class pattern, so <span class=\"keyword\">do</span> not use new to call it. Also, no instanceof check</span><br><span class=\"line\"> * will work. Instead <span class=\"built_in\">test</span> $<span class=\"variable\">$typeof</span> field against Symbol.for(<span class=\"string\">'react.element'</span>) to check</span><br><span class=\"line\"> * <span class=\"keyword\">if</span> something is a React Element.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">type</span></span><br><span class=\"line\"> * @param &#123;*&#125; key</span><br><span class=\"line\"> * @param &#123;string|object&#125; ref</span><br><span class=\"line\"> * @param &#123;*&#125; self A *temporary* helper to detect places <span class=\"built_in\">where</span> `this` is</span><br><span class=\"line\"> * different from the `owner` when React.createElement is called, so that we</span><br><span class=\"line\"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span><br><span class=\"line\"> * <span class=\"built_in\">functions</span>, and as long as `this` and owner are the same, there will be no</span><br><span class=\"line\"> * change <span class=\"keyword\">in</span> behavior.</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">source</span> An annotation object (added by a transpiler or otherwise)</span><br><span class=\"line\"> * indicating filename, line number, and/or other information.</span><br><span class=\"line\"> * @param &#123;*&#125; owner</span><br><span class=\"line\"> * @param &#123;*&#125; props</span><br><span class=\"line\"> * @internal</span><br><span class=\"line\"> */</span><br><span class=\"line\">var ReactElement = <span class=\"keyword\">function</span> (<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, owner, props) &#123;</span><br><span class=\"line\">  var element = &#123;</span><br><span class=\"line\">    //作为ReactElement的标识，运用ES6的Symbol</span><br><span class=\"line\">    $<span class=\"variable\">$typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Built-in properties that belong on the element</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"built_in\">type</span>,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Record the component responsible <span class=\"keyword\">for</span> creating this element.</span><br><span class=\"line\">    _owner: owner</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    element._store = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Object.defineProperty(element._store, <span class=\"string\">'validated'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // self and <span class=\"built_in\">source</span> are DEV only properties.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_self'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: self</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // Two elements created <span class=\"keyword\">in</span> two different places should be considered</span><br><span class=\"line\">    // equal <span class=\"keyword\">for</span> testing purposes and therefore we hide it from enumeration.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_source'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: <span class=\"built_in\">source</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">      Object.freeze(element.props);</span><br><span class=\"line\">      Object.freeze(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> element;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该方法在其他方法中也经常被调用，结果被return。</p>\n<h3 id=\"React-Component\"><a href=\"#React-Component\" class=\"headerlink\" title=\"React.Component\"></a>React.Component</h3><p>我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Component(props, context, updater) &#123;</span><br><span class=\"line\">  this.props = props;</span><br><span class=\"line\">  this.context = context;</span><br><span class=\"line\">  this.refs = emptyObject;</span><br><span class=\"line\">  // We initialize the default updater but the real one gets injected by the</span><br><span class=\"line\">  // renderer.</span><br><span class=\"line\">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Component.prototype.setState = <span class=\"keyword\">function</span> (partialState, callback) &#123;</span><br><span class=\"line\">  !(typeof partialState === <span class=\"string\">'object'</span> || typeof partialState === <span class=\"string\">'function'</span> || partialState == null) ? invariant(<span class=\"literal\">false</span>, <span class=\"string\">'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'</span>) : void 0;</span><br><span class=\"line\">  this.updater.enqueueSetState(this, partialState, callback, <span class=\"string\">'setState'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Component.prototype.forceUpdate = <span class=\"keyword\">function</span> (callback) &#123;</span><br><span class=\"line\">  this.updater.enqueueForceUpdate(this, callback, <span class=\"string\">'forceUpdate'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>贴张图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>学了React有差不多俩星期了，做个总结。</p>\n</blockquote>\n<h3 id=\"什么是JSX\"><a href=\"#什么是JSX\" class=\"headerlink\" title=\"什么是JSX\"></a>什么是JSX</h3><p>JSX=JavaScriptXml<br><br>JSX可以理解为在JS中编写与XML语言类似的语言，他并不能被浏览器识别，他的目的是通过编译器将这些标记变异成标准的JS语言。换句话说他是js语法的拓展。</p>","more":"<h3 id=\"javascript表达式\"><a href=\"#javascript表达式\" class=\"headerlink\" title=\"javascript表达式\"></a>javascript表达式</h3><p>要使用Javascript表达式作为属性值，只需要把这个表达式用一对大括号（{}）包起来，不要用引号（””）。求职表达式本身和JSX没啥关系，是JS中的特性。他是会返回值的表达式，与语句本质的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。</p>\n<h3 id=\"关于用法和注意事项\"><a href=\"#关于用法和注意事项\" class=\"headerlink\" title=\"关于用法和注意事项\"></a>关于用法和注意事项</h3><p>官网有一篇深入JSX<a href=\"https://doc.react-china.org/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h3 id=\"组件是啥\"><a href=\"#组件是啥\" class=\"headerlink\" title=\"组件是啥\"></a>组件是啥</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;App/&gt;)</span><br></pre></td></tr></table></figure>\n<p>如图所示：<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cosole.log%28APP%29.png\" alt=\"\"></p>\n<p>as  we  can see，组件并不是我们之前传统开发模式下的可复用的HTML+CSS，而是单纯的js对象，或者说虚拟DOM。<br>接下来<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&lt;ToDoList name=&#123;<span class=\"string\">'todo'</span>&#125; onClick=&#123;()=&gt;&#123;console.log(<span class=\"string\">'ss'</span>)&#125;&#125;/&gt;)&lt;br&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在组件里添加属性和方法，(ToDoList是之前写的一个小组件)，在控制台上可以看到。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/JSX.png\" alt=\"\">;<br>可以看到props里多了name和事件onClick，这也就是React声明组件属性和方法的方式，从这一点来看Vue还要去props里注册要省事一点。<br>可以看到组件对象里还有一些其他的属性，这些是用来干嘛的呢？O98k，打开<a href=\"https://babeljs.io/repl\" target=\"_blank\" rel=\"noopener\">在线Babel编译器</a>，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">hello</span></span>()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (&lt;div&gt;hello&lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/babelHello.png\" alt=\"\"><br>babel调用了React的createElement方法，这也就是为什么，我们在webpack环境下，声明一个组件，明明没有用到React，也要去引入的原因。<br>那么这个函数是干嘛使得呢？o98k，接下来好好看看。</p>\n<h3 id=\"createElemnt\"><a href=\"#createElemnt\" class=\"headerlink\" title=\"createElemnt\"></a>createElemnt</h3><p>首先把React源码的地址贴上，<a href=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/react.development.js\" target=\"_blank\" rel=\"noopener\">REACT源码</a>，有兴趣的小伙伴可以复制下来看看。<br>在React0.15版本中用到的是createClass方法，但是这个方法貌似已经过时了，16版本用的就是createElement。</p>\n<p>在源码的481行，可以找到这个函数，他有三个参数：</p>\n<ul>\n<li>type 标签名</li>\n<li>config 配置信息className，事件啥的，没有则为null</li>\n<li>children 标签里面的元素如：上述hello组件中调用createElelment时，children值就是’hello’，有意思的时当里面的元素是嵌套了一层的话，比如<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">return</span> (&lt;div&gt;&lt;p&gt;sss&lt;/p&gt;&lt;/div&gt;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>那么children对应的值就是React.createElement的返回结果。<br>这在babel网站上会看的很清楚，比如声明一个组件和渲染一个组件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>()&#123;</span><br><span class=\"line\">  reutn (&lt;div className=<span class=\"string\">\"foo\"</span>  onClick=&#123;()=&gt;&#123;cconsole.log(<span class=\"string\">'sss'</span>)&#125;&#125; &gt;</span><br><span class=\"line\">           &lt;p&gt;sss&lt;/p&gt;</span><br><span class=\"line\">        &lt;/div&gt;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;TodoItem /&gt;</span><br></pre></td></tr></table></figure>\n<p>在右边可以看到如下代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">TodoItem</span></span>() &#123;</span><br><span class=\"line\">  reutn(React.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    &#123; className: <span class=\"string\">\"foo\"</span>, onClick: <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">onClick</span></span>() &#123;</span><br><span class=\"line\">        cconsole.log(<span class=\"string\">'sss'</span>);</span><br><span class=\"line\">      &#125; &#125;,</span><br><span class=\"line\">    React.createElement(</span><br><span class=\"line\">      <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">      null,</span><br><span class=\"line\">      <span class=\"string\">\"sss\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  ));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">React.createElement(TodoItem, null);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到无论是原生标签还是自定义组件标签，React都会调用createElement进行处理，而处理的结果我们可以从接下来的源码里寻找。</p>\n<p>createElement源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Create and <span class=\"built_in\">return</span> a new ReactElement of the given <span class=\"built_in\">type</span>.</span><br><span class=\"line\"> * See https://reactjs.org/docs/react-api.html<span class=\"comment\">#createelement</span></span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> createElement(<span class=\"built_in\">type</span>, config, children) &#123;</span><br><span class=\"line\">  var propName;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 内置静态变量，作为参数传递给ReactElement方法</span><br><span class=\"line\"></span><br><span class=\"line\">  //属性承载的容器，子组件内部就是通过这个对象访问对应的属性</span><br><span class=\"line\">  var props = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var key = null;</span><br><span class=\"line\">  var ref = null;</span><br><span class=\"line\">  var self = null;</span><br><span class=\"line\">  var <span class=\"built_in\">source</span> = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config != null) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"string\">''</span> + config.key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //todo self 和 <span class=\"built_in\">source</span> 都是通过 props 传入的</span><br><span class=\"line\">    self = config.__self === undefined ? null : config.__self;</span><br><span class=\"line\">    <span class=\"built_in\">source</span> = config.__source === undefined ? null : config.__source;</span><br><span class=\"line\">    // Remaining properties are added to a new props object</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> config) &#123;</span><br><span class=\"line\">        // 检验是不是 OwnProperty，且不能是保留的名称。属性名不能是 key, ref, __self 和 __source</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class=\"line\">        props[propName] = config[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  //todo createElement 可以接受不止三个参数，在 children 后面传入更多的参数，表示有更多的 child，因此这里要把它们收集起来。</span><br><span class=\"line\">  var childrenLength = arguments.length - 2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childrenLength === 1) &#123;</span><br><span class=\"line\">    props.children = children;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenLength &gt; 1) &#123;</span><br><span class=\"line\">    var childArray = Array(childrenLength);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class=\"line\">      childArray[i] = arguments[i + 2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      //Object.freeze使对象不可扩展，对象的属性不可删除，不可修改</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">        Object.freeze(childArray);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    props.children = childArray;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //todo 把组件的默认属性值赋予组件的实例上</span><br><span class=\"line\">  // Resolve default props</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">type</span> &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    var defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> defaultProps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (props[propName] === undefined) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key || ref) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (typeof props.$<span class=\"variable\">$typeof</span> === <span class=\"string\">'undefined'</span> || props.$<span class=\"variable\">$typeof</span> !== REACT_ELEMENT_TYPE) &#123;</span><br><span class=\"line\">        var displayName = typeof <span class=\"built_in\">type</span> === <span class=\"string\">'function'</span> ? type.displayName || type.name || <span class=\"string\">'Unknown'</span> : <span class=\"built_in\">type</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key) &#123;</span><br><span class=\"line\">          defineKeyPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ref) &#123;</span><br><span class=\"line\">          defineRefPropWarningGetter(props, displayName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> ReactElement(<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, ReactCurrentOwner.current, props);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里，其实还有点模糊，这个方法是干嘛的，在整个生命周期起到了一个什么作用。<br>但是可以在最后看到createElement的返回值其实就是ReactElement方法的返回值，那么接下来就看看ReactElelment，是干啥的。</p>\n<h3 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h3><p>先看参数</p>\n<ul>\n<li>type: 使用 React.createElement创建的 React 组件</li>\n<li>key: 使用 React 组件创建的 ReactElement 的 key，DOM结构标识，提升update性能</li>\n<li>ref: 这个 ReactElement 的 ref，真实DOM的引用</li>\n<li>props：子结构相关信息(有则增加children字段/没有为空)和组件属性(如style)</li>\n<li>self: 用来记录当前元素所在的环境，因为创建组件的时候是一个递归的过程，就像之前，提到的hello嵌套组件，所以有必要对于每一层的组件保存this。</li>\n<li>source: 中包含了一些文件名称，行号等信息。</li>\n<li>owner: 用来记录该元素所属的组件。值为创建当前组件的对象，默认值为null。<br>ReactElement 这个函数只是将以上参数放入一个对象，并返回。<br>源码如下：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Factory method to create a new React element. This no longer adheres to</span><br><span class=\"line\"> * the class pattern, so <span class=\"keyword\">do</span> not use new to call it. Also, no instanceof check</span><br><span class=\"line\"> * will work. Instead <span class=\"built_in\">test</span> $<span class=\"variable\">$typeof</span> field against Symbol.for(<span class=\"string\">'react.element'</span>) to check</span><br><span class=\"line\"> * <span class=\"keyword\">if</span> something is a React Element.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">type</span></span><br><span class=\"line\"> * @param &#123;*&#125; key</span><br><span class=\"line\"> * @param &#123;string|object&#125; ref</span><br><span class=\"line\"> * @param &#123;*&#125; self A *temporary* helper to detect places <span class=\"built_in\">where</span> `this` is</span><br><span class=\"line\"> * different from the `owner` when React.createElement is called, so that we</span><br><span class=\"line\"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span><br><span class=\"line\"> * <span class=\"built_in\">functions</span>, and as long as `this` and owner are the same, there will be no</span><br><span class=\"line\"> * change <span class=\"keyword\">in</span> behavior.</span><br><span class=\"line\"> * @param &#123;*&#125; <span class=\"built_in\">source</span> An annotation object (added by a transpiler or otherwise)</span><br><span class=\"line\"> * indicating filename, line number, and/or other information.</span><br><span class=\"line\"> * @param &#123;*&#125; owner</span><br><span class=\"line\"> * @param &#123;*&#125; props</span><br><span class=\"line\"> * @internal</span><br><span class=\"line\"> */</span><br><span class=\"line\">var ReactElement = <span class=\"keyword\">function</span> (<span class=\"built_in\">type</span>, key, ref, self, <span class=\"built_in\">source</span>, owner, props) &#123;</span><br><span class=\"line\">  var element = &#123;</span><br><span class=\"line\">    //作为ReactElement的标识，运用ES6的Symbol</span><br><span class=\"line\">    $<span class=\"variable\">$typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Built-in properties that belong on the element</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"built_in\">type</span>,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    // Record the component responsible <span class=\"keyword\">for</span> creating this element.</span><br><span class=\"line\">    _owner: owner</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    element._store = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Object.defineProperty(element._store, <span class=\"string\">'validated'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // self and <span class=\"built_in\">source</span> are DEV only properties.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_self'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: self</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // Two elements created <span class=\"keyword\">in</span> two different places should be considered</span><br><span class=\"line\">    // equal <span class=\"keyword\">for</span> testing purposes and therefore we hide it from enumeration.</span><br><span class=\"line\">    Object.defineProperty(element, <span class=\"string\">'_source'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: <span class=\"built_in\">source</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.freeze) &#123;</span><br><span class=\"line\">      Object.freeze(element.props);</span><br><span class=\"line\">      Object.freeze(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> element;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该方法在其他方法中也经常被调用，结果被return。</p>\n<h3 id=\"React-Component\"><a href=\"#React-Component\" class=\"headerlink\" title=\"React.Component\"></a>React.Component</h3><p>我们在最开始声明的组件App，其实是继承React.Component类的子类，它的原型具有setState等方法。这样组件App已经有了最基本的雏形。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Component(props, context, updater) &#123;</span><br><span class=\"line\">  this.props = props;</span><br><span class=\"line\">  this.context = context;</span><br><span class=\"line\">  this.refs = emptyObject;</span><br><span class=\"line\">  // We initialize the default updater but the real one gets injected by the</span><br><span class=\"line\">  // renderer.</span><br><span class=\"line\">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Component.prototype.setState = <span class=\"keyword\">function</span> (partialState, callback) &#123;</span><br><span class=\"line\">  !(typeof partialState === <span class=\"string\">'object'</span> || typeof partialState === <span class=\"string\">'function'</span> || partialState == null) ? invariant(<span class=\"literal\">false</span>, <span class=\"string\">'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'</span>) : void 0;</span><br><span class=\"line\">  this.updater.enqueueSetState(this, partialState, callback, <span class=\"string\">'setState'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Component.prototype.forceUpdate = <span class=\"keyword\">function</span> (callback) &#123;</span><br><span class=\"line\">  this.updater.enqueueForceUpdate(this, callback, <span class=\"string\">'forceUpdate'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>贴张图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/ReactComponent.png\" alt=\"\"></p>"},{"title":"Ngnix","date":"2018-07-19T04:25:14.000Z","_content":"### Nginx是啥\nNginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。\n<!--more-->\n### Nginx可以干什么\n网站资源服务器，反向代理负载均衡。\n\n### 正向代理\n在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！\n\n上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。\n\n### 反向代理\n多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！\n\n### 负载均衡\n首先明确两个概念：\n\n+ 负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。\n+ 均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。\n故将服务器接收到的请求按照规则分发的过程，称为负载均衡。\n#### HTTP重定向实现\b\n当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br>\n\n在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br>\n\n调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br>\n\n+ 随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。\n\n+ 轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。\n\n由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br>\n\n##### 优缺点分析\n\n采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br>\n\n在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br>\n\n由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br>\n\n若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br>\n\n#### DNS负载均衡\nDNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。\n\n##### 具体做法\n首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。\n\n当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。\n\n##### 调度策略\n\n一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。\n\n##### 优缺点分析\n\nDNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。\n此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。\n<br>\n但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。\n<br>\nDNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。\n<br>\n此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。\n<br>\n动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。\n<br>\n#### 反向代理负载均衡\n反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。\n<br>\n之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。\n<br>\n我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。\n<br>\n##### 优点\n\n+ 隐藏后端服务器。\n+ 与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。\n故障转移\n+ 与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。\n合理分配任务\n+ HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。\n##### 缺点\n\n+ 调度者压力过大\n+ 由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。\n制约扩展\n+ 当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。\n","source":"_posts/Ngnix.md","raw":"---\ntitle: Ngnix\ndate: 2018-07-19 12:25:14\ntags: 学习\ncategories: 学习\n---\n### Nginx是啥\nNginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。\n<!--more-->\n### Nginx可以干什么\n网站资源服务器，反向代理负载均衡。\n\n### 正向代理\n在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！\n\n上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。\n\n### 反向代理\n多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！\n\n### 负载均衡\n首先明确两个概念：\n\n+ 负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。\n+ 均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。\n故将服务器接收到的请求按照规则分发的过程，称为负载均衡。\n#### HTTP重定向实现\b\n当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br>\n\n在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br>\n\n调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br>\n\n+ 随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。\n\n+ 轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。\n\n由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br>\n\n##### 优缺点分析\n\n采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br>\n\n在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br>\n\n由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br>\n\n若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br>\n\n#### DNS负载均衡\nDNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。\n\n##### 具体做法\n首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。\n\n当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。\n\n##### 调度策略\n\n一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。\n\n##### 优缺点分析\n\nDNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。\n此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。\n<br>\n但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。\n<br>\nDNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。\n<br>\n此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。\n<br>\n动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。\n<br>\n#### 反向代理负载均衡\n反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。\n<br>\n之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。\n<br>\n我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。\n<br>\n##### 优点\n\n+ 隐藏后端服务器。\n+ 与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。\n故障转移\n+ 与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。\n合理分配任务\n+ HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。\n##### 缺点\n\n+ 调度者压力过大\n+ 由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。\n制约扩展\n+ 当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。\n","slug":"Ngnix","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskst80025hvs64r2h20ul","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"Nginx是啥\"><a href=\"#Nginx是啥\" class=\"headerlink\" title=\"Nginx是啥\"></a>Nginx是啥</h3><p>Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br><a id=\"more\"></a></p>\n<h3 id=\"Nginx可以干什么\"><a href=\"#Nginx可以干什么\" class=\"headerlink\" title=\"Nginx可以干什么\"></a>Nginx可以干什么</h3><p>网站资源服务器，反向代理负载均衡。</p>\n<h3 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h3><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p>\n<p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>首先明确两个概念：</p>\n<ul>\n<li>负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。</li>\n<li>均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。<br>故将服务器接收到的请求按照规则分发的过程，称为负载均衡。<h4 id=\"HTTP重定向实现\"><a href=\"#HTTP重定向实现\" class=\"headerlink\" title=\"HTTP重定向实现\b\"></a>HTTP重定向实现\b</h4>当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br></li>\n</ul>\n<p>在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br></p>\n<p>调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br></p>\n<ul>\n<li><p>随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。</p>\n</li>\n<li><p>轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。</p>\n</li>\n</ul>\n<p>由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br></p>\n<h5 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br></p>\n<p>在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br></p>\n<p>由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br></p>\n<p>若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br></p>\n<h4 id=\"DNS负载均衡\"><a href=\"#DNS负载均衡\" class=\"headerlink\" title=\"DNS负载均衡\"></a>DNS负载均衡</h4><p>DNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。</p>\n<h5 id=\"具体做法\"><a href=\"#具体做法\" class=\"headerlink\" title=\"具体做法\"></a>具体做法</h5><p>首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。</p>\n<p>当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。</p>\n<h5 id=\"调度策略\"><a href=\"#调度策略\" class=\"headerlink\" title=\"调度策略\"></a>调度策略</h5><p>一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。</p>\n<h5 id=\"优缺点分析-1\"><a href=\"#优缺点分析-1\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。<br>此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。<br><br><br>但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。<br><br><br>DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。<br><br><br>此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。<br><br><br>动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。<br><br></p>\n<h4 id=\"反向代理负载均衡\"><a href=\"#反向代理负载均衡\" class=\"headerlink\" title=\"反向代理负载均衡\"></a>反向代理负载均衡</h4><p>反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。<br><br><br>之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。<br><br><br>我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。<br><br></p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>隐藏后端服务器。</li>\n<li>与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。<br>故障转移</li>\n<li>与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。<br>合理分配任务</li>\n<li><p>HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5></li>\n<li><p>调度者压力过大</p>\n</li>\n<li>由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。<br>制约扩展</li>\n<li>当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"Nginx是啥\"><a href=\"#Nginx是啥\" class=\"headerlink\" title=\"Nginx是啥\"></a>Nginx是啥</h3><p>Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br>","more":"</p>\n<h3 id=\"Nginx可以干什么\"><a href=\"#Nginx可以干什么\" class=\"headerlink\" title=\"Nginx可以干什么\"></a>Nginx可以干什么</h3><p>网站资源服务器，反向代理负载均衡。</p>\n<h3 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h3><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p>\n<p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>首先明确两个概念：</p>\n<ul>\n<li>负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。</li>\n<li>均衡规则：请求数量按照一定的规则\b分配到不同服务器处理的规则。<br>故将服务器接收到的请求按照规则分发的过程，称为负载均衡。<h4 id=\"HTTP重定向实现\"><a href=\"#HTTP重定向实现\" class=\"headerlink\" title=\"HTTP重定向实现\b\"></a>HTTP重定向实现\b</h4>当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status\b\b返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br></li>\n</ul>\n<p>在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br></p>\n<p>调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br></p>\n<ul>\n<li><p>随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。</p>\n</li>\n<li><p>轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。</p>\n</li>\n</ul>\n<p>由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br></p>\n<h5 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br></p>\n<p>在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br></p>\n<p>由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br></p>\n<p>若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br></p>\n<h4 id=\"DNS负载均衡\"><a href=\"#DNS负载均衡\" class=\"headerlink\" title=\"DNS负载均衡\"></a>DNS负载均衡</h4><p>DNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。</p>\n<h5 id=\"具体做法\"><a href=\"#具体做法\" class=\"headerlink\" title=\"具体做法\"></a>具体做法</h5><p>首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。</p>\n<p>当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。</p>\n<h5 id=\"调度策略\"><a href=\"#调度策略\" class=\"headerlink\" title=\"调度策略\"></a>调度策略</h5><p>一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。</p>\n<h5 id=\"优缺点分析-1\"><a href=\"#优缺点分析-1\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h5><p>DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。<br>此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。<br><br><br>但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。<br><br><br>DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。<br><br><br>此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。<br><br><br>动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。<br><br></p>\n<h4 id=\"反向代理负载均衡\"><a href=\"#反向代理负载均衡\" class=\"headerlink\" title=\"反向代理负载均衡\"></a>反向代理负载均衡</h4><p>反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。<br><br><br>之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。<br><br><br>我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。<br><br></p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>隐藏后端服务器。</li>\n<li>与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。<br>故障转移</li>\n<li>与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。<br>合理分配任务</li>\n<li><p>HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5></li>\n<li><p>调度者压力过大</p>\n</li>\n<li>由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。<br>制约扩展</li>\n<li>当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。</li>\n</ul>"},{"title":"axioshhh","date":"2018-04-09T16:51:31.000Z","_content":"\n> 这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。\n\n<!--more-->\n\n这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br>\n\n说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br>\n\n今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png)\nexm????为啥传来的值在key上，\n是我的body-parser用的不对吗？之前也是这么用的啊\n```bash\nlet bodyParser = require(\"body-parser\");\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n```\n好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。\n\n### axios简介\n\naxios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。\n通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。\n值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。\n\n### axios配置\n般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type='application/x-www-form-urlencoded;charset=utf-8'数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）\n\n```bash\naxios.defaults.headers.common['Content-Type'] = 'application/json'\naxios.defaults.baseURL = _apiHost\n```\n\n### axios使用方法\n\n基本使用方法\nGET请求\n```bash\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n\n\nPOST请求\n```bash\n axios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n同时执行多个\n```bash\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n\n```\n\n可以直接通过config来完成请求\naxios(config)\n```bash\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n```\n详情请点击[这里](https://www.kancloud.cn/yunye/axios/234845)\n### 请求配置\n```bash\n\n{\n  // `url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // `method` 是创建请求时使用的方法\n  method: 'get', // 默认是 get\n\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // `data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n  // `withCredentials` 表示跨域请求时是否需要携带cookie\n  withCredentials: false, // 默认的\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // 默认的\n\n  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称\n  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的\n\n  // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // 默认的\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // 默认的\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: : {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n\n### 响应结构\n```bash\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n  // `config` 是为请求提供的配置信息\n  config: {}\n}\n```\n\n### 请求\n\n后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？\n原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。\n之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。\n\n#### 简单请求\n","source":"_posts/axioshhh.md","raw":"---\ntitle: axioshhh\ndate: 2018-04-10 00:51:31\ntags: javascript\ncategories: 学习\n---\n\n> 这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。\n\n<!--more-->\n\n这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br>\n\n说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br>\n\n今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png)\nexm????为啥传来的值在key上，\n是我的body-parser用的不对吗？之前也是这么用的啊\n```bash\nlet bodyParser = require(\"body-parser\");\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n```\n好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。\n\n### axios简介\n\naxios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。\n通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。\n值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。\n\n### axios配置\n般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type='application/x-www-form-urlencoded;charset=utf-8'数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）\n\n```bash\naxios.defaults.headers.common['Content-Type'] = 'application/json'\naxios.defaults.baseURL = _apiHost\n```\n\n### axios使用方法\n\n基本使用方法\nGET请求\n```bash\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n\n\nPOST请求\n```bash\n axios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n```\n同时执行多个\n```bash\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n\n```\n\n可以直接通过config来完成请求\naxios(config)\n```bash\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n```\n详情请点击[这里](https://www.kancloud.cn/yunye/axios/234845)\n### 请求配置\n```bash\n\n{\n  // `url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // `method` 是创建请求时使用的方法\n  method: 'get', // 默认是 get\n\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // `data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n  // `withCredentials` 表示跨域请求时是否需要携带cookie\n  withCredentials: false, // 默认的\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // 默认的\n\n  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称\n  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的\n\n  // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // 默认的\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // 默认的\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: : {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n\n### 响应结构\n```bash\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n  // `config` 是为请求提供的配置信息\n  config: {}\n}\n```\n\n### 请求\n\n后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？\n原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。\n之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。\n\n#### 简单请求\n","slug":"axioshhh","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskstc0028hvs6lb6648ky","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br></p>\n<p>说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br></p>\n<p>今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png\" alt=\"\"><br>exm????为啥传来的值在key上，<br>是我的body-parser用的不对吗？之前也是这么用的啊<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> bodyParser = require(<span class=\"string\">\"body-parser\"</span>);</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: <span class=\"literal\">true</span> &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。</p>\n<h3 id=\"axios简介\"><a href=\"#axios简介\" class=\"headerlink\" title=\"axios简介\"></a>axios简介</h3><p>axios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。<br>通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。<br>值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。</p>\n<h3 id=\"axios配置\"><a href=\"#axios配置\" class=\"headerlink\" title=\"axios配置\"></a>axios配置</h3><p>般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type=’application/x-www-form-urlencoded;charset=utf-8’数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'application/json'</span></span><br><span class=\"line\">axios.defaults.baseURL = _apiHost</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios使用方法\"><a href=\"#axios使用方法\" class=\"headerlink\" title=\"axios使用方法\"></a>axios使用方法</h3><p>基本使用方法<br>GET请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make a request <span class=\"keyword\">for</span> a user with a given ID</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Optionally the request above could also be <span class=\"keyword\">done</span> as</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>POST请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">   firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">   lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">   console.log(response);</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">   console.log(error);</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>同时执行多个<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserAccount</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserPermissions</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> (acct, perms) &#123;</span><br><span class=\"line\">    // Both requests are now complete</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>可以直接通过config来完成请求<br>axios(config)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">  url: <span class=\"string\">'/user/12345'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>详情请点击<a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"请求配置\"><a href=\"#请求配置\" class=\"headerlink\" title=\"请求配置\"></a>请求配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // `url` 是用于请求的服务器 URL</span><br><span class=\"line\">  url: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `method` 是创建请求时使用的方法</span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>, // 默认是 get</span><br><span class=\"line\"></span><br><span class=\"line\">  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span><br><span class=\"line\">  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span><br><span class=\"line\">  baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformRequest` 允许在向服务器发送前，修改请求数据</span><br><span class=\"line\">  // 只能用在 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span> 和 <span class=\"string\">'PATCH'</span> 这几个请求方法</span><br><span class=\"line\">  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span><br><span class=\"line\">  transformRequest: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformResponse` 在传递给 <span class=\"keyword\">then</span>/catch 前，允许修改响应数据</span><br><span class=\"line\">  transformResponse: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 是即将被发送的自定义请求头</span><br><span class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>: <span class=\"string\">'XMLHttpRequest'</span>&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `params` 是即将与请求一起发送的 URL 参数</span><br><span class=\"line\">  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: 12345</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `paramsSerializer` 是一个负责 `params` 序列化的函数</span><br><span class=\"line\">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class=\"line\">  paramsSerializer: <span class=\"keyword\">function</span>(params) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Qs.stringify(params, &#123;arrayFormat: <span class=\"string\">'brackets'</span>&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `data` 是作为请求主体被发送的数据</span><br><span class=\"line\">  // 只适用于这些请求方法 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span>, 和 <span class=\"string\">'PATCH'</span></span><br><span class=\"line\">  // 在没有设置 `transformRequest` 时，必须是以下类型之一：</span><br><span class=\"line\">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class=\"line\">  // - 浏览器专属：FormData, File, Blob</span><br><span class=\"line\">  // - Node 专属： Stream</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span><br><span class=\"line\">  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `withCredentials` 表示跨域请求时是否需要携带cookie</span><br><span class=\"line\">  withCredentials: <span class=\"literal\">false</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `adapter` 允许自定义处理请求，以使测试更轻松</span><br><span class=\"line\">  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](<span class=\"comment\">#response-api)).</span></span><br><span class=\"line\">  adapter: <span class=\"keyword\">function</span> (config) &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span><br><span class=\"line\">  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: <span class=\"string\">'janedoe'</span>,</span><br><span class=\"line\">    password: <span class=\"string\">'s00pers3cret'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `responseType` 表示服务器响应的数据类型，可以是 <span class=\"string\">'arraybuffer'</span>, <span class=\"string\">'blob'</span>, <span class=\"string\">'document'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'text'</span>, <span class=\"string\">'stream'</span></span><br><span class=\"line\">  responseType: <span class=\"string\">'json'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span><br><span class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span><br><span class=\"line\">  xsrfHeaderName: <span class=\"string\">'X-XSRF-TOKEN'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onUploadProgress` 允许为上传处理进度事件</span><br><span class=\"line\">  onUploadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onDownloadProgress` 允许为下载处理进度事件</span><br><span class=\"line\">  onDownloadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxContentLength` 定义允许的响应内容的最大尺寸</span><br><span class=\"line\">  maxContentLength: 2000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `<span class=\"literal\">true</span>` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span><br><span class=\"line\">  validateStatus: <span class=\"keyword\">function</span> (status) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span><br><span class=\"line\">  // 如果设置为0，将不会 follow 任何重定向</span><br><span class=\"line\">  maxRedirects: 5, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span><br><span class=\"line\">  // `keepAlive` 默认没有启用</span><br><span class=\"line\">  httpAgent: new http.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\">  httpsAgent: new https.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // <span class=\"string\">'proxy'</span> 定义代理服务器的主机名称和端口</span><br><span class=\"line\">  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class=\"line\">  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">    port: 9000,</span><br><span class=\"line\">    auth: : &#123;</span><br><span class=\"line\">      username: <span class=\"string\">'mikeymike'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'rapunz3l'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `cancelToken` 指定用于取消请求的 cancel token</span><br><span class=\"line\">  // （查看后面的 Cancellation 这节了解更多）</span><br><span class=\"line\">  cancelToken: new CancelToken(<span class=\"keyword\">function</span> (cancel) &#123;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"响应结构\"><a href=\"#响应结构\" class=\"headerlink\" title=\"响应结构\"></a>响应结构</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `data` 由服务器提供的响应</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class=\"line\">  status: 200,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 服务器响应的头</span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `config` 是为请求提供的配置信息</span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？<br>原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。<br>之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4>","site":{"data":{}},"excerpt":"<blockquote>\n<p>这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。</p>\n</blockquote>","more":"<p>这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br></p>\n<p>说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br></p>\n<p>今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png\" alt=\"\"><br>exm????为啥传来的值在key上，<br>是我的body-parser用的不对吗？之前也是这么用的啊<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> bodyParser = require(<span class=\"string\">\"body-parser\"</span>);</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: <span class=\"literal\">true</span> &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。</p>\n<h3 id=\"axios简介\"><a href=\"#axios简介\" class=\"headerlink\" title=\"axios简介\"></a>axios简介</h3><p>axios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。<br>通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。<br>值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。</p>\n<h3 id=\"axios配置\"><a href=\"#axios配置\" class=\"headerlink\" title=\"axios配置\"></a>axios配置</h3><p>般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type=’application/x-www-form-urlencoded;charset=utf-8’数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'application/json'</span></span><br><span class=\"line\">axios.defaults.baseURL = _apiHost</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios使用方法\"><a href=\"#axios使用方法\" class=\"headerlink\" title=\"axios使用方法\"></a>axios使用方法</h3><p>基本使用方法<br>GET请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make a request <span class=\"keyword\">for</span> a user with a given ID</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Optionally the request above could also be <span class=\"keyword\">done</span> as</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>POST请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">   firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">   lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .<span class=\"keyword\">then</span>(<span class=\"keyword\">function</span> (response) &#123;</span><br><span class=\"line\">   console.log(response);</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .catch(<span class=\"keyword\">function</span> (error) &#123;</span><br><span class=\"line\">   console.log(error);</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>同时执行多个<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserAccount</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getUserPermissions</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> (acct, perms) &#123;</span><br><span class=\"line\">    // Both requests are now complete</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>可以直接通过config来完成请求<br>axios(config)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">  url: <span class=\"string\">'/user/12345'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>详情请点击<a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"请求配置\"><a href=\"#请求配置\" class=\"headerlink\" title=\"请求配置\"></a>请求配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // `url` 是用于请求的服务器 URL</span><br><span class=\"line\">  url: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `method` 是创建请求时使用的方法</span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>, // 默认是 get</span><br><span class=\"line\"></span><br><span class=\"line\">  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span><br><span class=\"line\">  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span><br><span class=\"line\">  baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformRequest` 允许在向服务器发送前，修改请求数据</span><br><span class=\"line\">  // 只能用在 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span> 和 <span class=\"string\">'PATCH'</span> 这几个请求方法</span><br><span class=\"line\">  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span><br><span class=\"line\">  transformRequest: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformResponse` 在传递给 <span class=\"keyword\">then</span>/catch 前，允许修改响应数据</span><br><span class=\"line\">  transformResponse: [<span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">    // 对 data 进行任意转换处理</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 是即将被发送的自定义请求头</span><br><span class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>: <span class=\"string\">'XMLHttpRequest'</span>&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `params` 是即将与请求一起发送的 URL 参数</span><br><span class=\"line\">  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: 12345</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `paramsSerializer` 是一个负责 `params` 序列化的函数</span><br><span class=\"line\">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class=\"line\">  paramsSerializer: <span class=\"keyword\">function</span>(params) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Qs.stringify(params, &#123;arrayFormat: <span class=\"string\">'brackets'</span>&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `data` 是作为请求主体被发送的数据</span><br><span class=\"line\">  // 只适用于这些请求方法 <span class=\"string\">'PUT'</span>, <span class=\"string\">'POST'</span>, 和 <span class=\"string\">'PATCH'</span></span><br><span class=\"line\">  // 在没有设置 `transformRequest` 时，必须是以下类型之一：</span><br><span class=\"line\">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class=\"line\">  // - 浏览器专属：FormData, File, Blob</span><br><span class=\"line\">  // - Node 专属： Stream</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span><br><span class=\"line\">  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `withCredentials` 表示跨域请求时是否需要携带cookie</span><br><span class=\"line\">  withCredentials: <span class=\"literal\">false</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `adapter` 允许自定义处理请求，以使测试更轻松</span><br><span class=\"line\">  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](<span class=\"comment\">#response-api)).</span></span><br><span class=\"line\">  adapter: <span class=\"keyword\">function</span> (config) &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span><br><span class=\"line\">  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: <span class=\"string\">'janedoe'</span>,</span><br><span class=\"line\">    password: <span class=\"string\">'s00pers3cret'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `responseType` 表示服务器响应的数据类型，可以是 <span class=\"string\">'arraybuffer'</span>, <span class=\"string\">'blob'</span>, <span class=\"string\">'document'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'text'</span>, <span class=\"string\">'stream'</span></span><br><span class=\"line\">  responseType: <span class=\"string\">'json'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span><br><span class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span><br><span class=\"line\">  xsrfHeaderName: <span class=\"string\">'X-XSRF-TOKEN'</span>, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onUploadProgress` 允许为上传处理进度事件</span><br><span class=\"line\">  onUploadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onDownloadProgress` 允许为下载处理进度事件</span><br><span class=\"line\">  onDownloadProgress: <span class=\"keyword\">function</span> (progressEvent) &#123;</span><br><span class=\"line\">    // 对原生进度事件的处理</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxContentLength` 定义允许的响应内容的最大尺寸</span><br><span class=\"line\">  maxContentLength: 2000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `<span class=\"literal\">true</span>` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span><br><span class=\"line\">  validateStatus: <span class=\"keyword\">function</span> (status) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span><br><span class=\"line\">  // 如果设置为0，将不会 follow 任何重定向</span><br><span class=\"line\">  maxRedirects: 5, // 默认的</span><br><span class=\"line\"></span><br><span class=\"line\">  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span><br><span class=\"line\">  // `keepAlive` 默认没有启用</span><br><span class=\"line\">  httpAgent: new http.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\">  httpsAgent: new https.Agent(&#123; keepAlive: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // <span class=\"string\">'proxy'</span> 定义代理服务器的主机名称和端口</span><br><span class=\"line\">  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class=\"line\">  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">    port: 9000,</span><br><span class=\"line\">    auth: : &#123;</span><br><span class=\"line\">      username: <span class=\"string\">'mikeymike'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'rapunz3l'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `cancelToken` 指定用于取消请求的 cancel token</span><br><span class=\"line\">  // （查看后面的 Cancellation 这节了解更多）</span><br><span class=\"line\">  cancelToken: new CancelToken(<span class=\"keyword\">function</span> (cancel) &#123;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"响应结构\"><a href=\"#响应结构\" class=\"headerlink\" title=\"响应结构\"></a>响应结构</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `data` 由服务器提供的响应</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class=\"line\">  status: 200,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` 服务器响应的头</span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `config` 是为请求提供的配置信息</span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？<br>原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。<br>之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4>"},{"title":"从源码看vue的lifecycle","date":"2018-04-29T05:47:53.000Z","_content":"\n\n>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。\n\n<!--more-->\n\n话不多说，先来张图。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png)\n熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。\n知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。\n\n### 阅读技巧\n\n这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始\n```bash\n(function(window, undefined) {\n    var  jQuery = function(selector, context) {\n\n        return new jQuery.fn.init(selector, context, rootjQuery);\n    }\n\n\n    jQuery.fn = jQuery.prototype = {\n\n        init: function(selector, context, rootjQuery) {\n            // ...\n        }\n    }\n\n    jQuery.fn.init.prototype = jQuery.fn;\n\n})(window);\n\n```\n\n然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。\n\n而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png)\n而入口文件是 core/index.js\n\n### 正文开始\n\ncore/index.js源码如下\n\n```bash\n//Vue的核心方法\nimport Vue from './instance/index'\n//初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n//获取布尔值变量判断是不是SSR\nimport { isServerRendering } from 'core/util/env'\n// 初始化全局变量\ninitGlobalAPI(Vue)\n// 为Vue原型定义属性$isServer\nObject.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n})\n// 为Vue原型定义属性$ssrContext\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n    get () {\n        /* istanbul ignore next */\n        return this.$vnode && this.$vnode.ssrContext\n    }\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n\n```\n\nemmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  './instance/index',(凭直觉，这里应该有东西)\n<br>\n./instance/index\n```bash\n\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\n//为Vue的原型扩展_init方法\ninitMixin(Vue)\n\n//初始化$data $props $set $delete等\nstateMixin(Vue)\n\n//初始化$on $once $off $emit等函数\neventsMixin(Vue)\n\n//初始化_update $forceUpdate $destroy函数\nlifecycleMixin(Vue)\n\n//初始化 $nextTick _render函数\nrenderMixin(Vue)\n\nexport default Vue\n\n```\n当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看\n\n点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里\n\n```bash\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n```\n\ninitMixin就是再前文提到的./instance/index里被调用的。\n其实接下来才开始和那张图有关系。\n\n```bash\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n        // 如果是Vue的实例，则不需要被observe\n    vm._isVue = true\n        // 第一步： options参数的处理\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n        // 第二步： renderProxy\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n        // 第三步： vm的生命周期相关变量初始化\n    initLifecycle(vm)\n        // 第四步： vm的事件监听（v-on）初始化\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n        // 第六步：render & mount\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n```\n\n代码中做了注释，\n+ 第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。\n+ 第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。\n+ 第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。\n+ 第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数\n+ 第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。\n\n因此，至少在created时才能拿到data等里面的值。<br>\n\n当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。\n\n编译方式有两种：\n+ 编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。\n\n然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。\n+ 运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。\n（打把王者，回头再写，有点头疼）\nloading......................................................................................\n王者打完了，接着写\n\n## beforeMount\n解释一下图中在created和beforeMount之间的部分。\n第一个分支：\n如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。\n<br>\n\n第二个分支：\n1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数\n2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高\n3.如果1,2条件都不具备，则报错\n\n接着就调用beforeMount生命周期钩子\n<br>\ncore/instance/lifecycle.js\n```bash\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n\n```\n","source":"_posts/Vue-lifecycle.md","raw":"---\ntitle: 从源码看vue的lifecycle\ndate: 2018-04-29 13:47:53\ntags: vue\ncategories: 学习\n---\n\n\n>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。\n\n<!--more-->\n\n话不多说，先来张图。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png)\n熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。\n知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。\n\n### 阅读技巧\n\n这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始\n```bash\n(function(window, undefined) {\n    var  jQuery = function(selector, context) {\n\n        return new jQuery.fn.init(selector, context, rootjQuery);\n    }\n\n\n    jQuery.fn = jQuery.prototype = {\n\n        init: function(selector, context, rootjQuery) {\n            // ...\n        }\n    }\n\n    jQuery.fn.init.prototype = jQuery.fn;\n\n})(window);\n\n```\n\n然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。\n\n而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png)\n而入口文件是 core/index.js\n\n### 正文开始\n\ncore/index.js源码如下\n\n```bash\n//Vue的核心方法\nimport Vue from './instance/index'\n//初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n//获取布尔值变量判断是不是SSR\nimport { isServerRendering } from 'core/util/env'\n// 初始化全局变量\ninitGlobalAPI(Vue)\n// 为Vue原型定义属性$isServer\nObject.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n})\n// 为Vue原型定义属性$ssrContext\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n    get () {\n        /* istanbul ignore next */\n        return this.$vnode && this.$vnode.ssrContext\n    }\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n\n```\n\nemmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  './instance/index',(凭直觉，这里应该有东西)\n<br>\n./instance/index\n```bash\n\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\n//为Vue的原型扩展_init方法\ninitMixin(Vue)\n\n//初始化$data $props $set $delete等\nstateMixin(Vue)\n\n//初始化$on $once $off $emit等函数\neventsMixin(Vue)\n\n//初始化_update $forceUpdate $destroy函数\nlifecycleMixin(Vue)\n\n//初始化 $nextTick _render函数\nrenderMixin(Vue)\n\nexport default Vue\n\n```\n当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看\n\n点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里\n\n```bash\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n```\n\ninitMixin就是再前文提到的./instance/index里被调用的。\n其实接下来才开始和那张图有关系。\n\n```bash\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n        // 如果是Vue的实例，则不需要被observe\n    vm._isVue = true\n        // 第一步： options参数的处理\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n        // 第二步： renderProxy\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n        // 第三步： vm的生命周期相关变量初始化\n    initLifecycle(vm)\n        // 第四步： vm的事件监听（v-on）初始化\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n        // 第六步：render & mount\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n```\n\n代码中做了注释，\n+ 第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。\n+ 第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。\n+ 第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。\n+ 第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数\n+ 第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。\n\n因此，至少在created时才能拿到data等里面的值。<br>\n\n当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。\n\n编译方式有两种：\n+ 编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。\n\n然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。\n+ 运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。\n（打把王者，回头再写，有点头疼）\nloading......................................................................................\n王者打完了，接着写\n\n## beforeMount\n解释一下图中在created和beforeMount之间的部分。\n第一个分支：\n如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。\n<br>\n\n第二个分支：\n1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数\n2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高\n3.如果1,2条件都不具备，则报错\n\n接着就调用beforeMount生命周期钩子\n<br>\ncore/instance/lifecycle.js\n```bash\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n\n```\n","slug":"Vue-lifecycle","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskste002bhvs69mgxp84s","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>话不多说，先来张图。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png\" alt=\"\"><br>熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。<br>知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。</p>\n<h3 id=\"阅读技巧\"><a href=\"#阅读技巧\" class=\"headerlink\" title=\"阅读技巧\"></a>阅读技巧</h3><p>这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(window, undefined) &#123;</span><br><span class=\"line\">    var  jQuery = <span class=\"keyword\">function</span>(selector, context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">return</span> new jQuery.fn.init(selector, context, rootjQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        init: <span class=\"keyword\">function</span>(selector, context, rootjQuery) &#123;</span><br><span class=\"line\">            // ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(window);</span><br></pre></td></tr></table></figure></p>\n<p>然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。</p>\n<p>而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png\" alt=\"\"><br>而入口文件是 core/index.js</p>\n<h3 id=\"正文开始\"><a href=\"#正文开始\" class=\"headerlink\" title=\"正文开始\"></a>正文开始</h3><p>core/index.js源码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Vue的核心方法</span><br><span class=\"line\">import Vue from <span class=\"string\">'./instance/index'</span></span><br><span class=\"line\">//初始化全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from <span class=\"string\">'./global-api/index'</span></span><br><span class=\"line\">//获取布尔值变量判断是不是SSR</span><br><span class=\"line\">import &#123; isServerRendering &#125; from <span class=\"string\">'core/util/env'</span></span><br><span class=\"line\">// 初始化全局变量</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$isServer</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$isServer'</span>, &#123;</span><br><span class=\"line\">    get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$ssrContext</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$ssrContext'</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span></span> () &#123;</span><br><span class=\"line\">        /* istanbul ignore next */</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this.<span class=\"variable\">$vnode</span> &amp;&amp; this.<span class=\"variable\">$vnode</span>.ssrContext</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = <span class=\"string\">'__VERSION__'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure>\n<p>emmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  ‘./instance/index’,(凭直觉，这里应该有东西)<br><br><br>./instance/index<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import &#123; initMixin &#125; from <span class=\"string\">'./init'</span></span><br><span class=\"line\">import &#123; stateMixin &#125; from <span class=\"string\">'./state'</span></span><br><span class=\"line\">import &#123; renderMixin &#125; from <span class=\"string\">'./render'</span></span><br><span class=\"line\">import &#123; eventsMixin &#125; from <span class=\"string\">'./events'</span></span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from <span class=\"string\">'./lifecycle'</span></span><br><span class=\"line\">import &#123; warn &#125; from <span class=\"string\">'../util/index'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> Vue (options) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//为Vue的原型扩展_init方法</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$data</span> <span class=\"variable\">$props</span> <span class=\"variable\">$set</span> <span class=\"variable\">$delete</span>等</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$on</span> <span class=\"variable\">$once</span> <span class=\"variable\">$off</span> <span class=\"variable\">$emit</span>等函数</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化_update <span class=\"variable\">$forceUpdate</span> <span class=\"variable\">$destroy</span>函数</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化 <span class=\"variable\">$nextTick</span> _render函数</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure></p>\n<p>当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看</p>\n<p>点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br></pre></td></tr></table></figure>\n<p>initMixin就是再前文提到的./instance/index里被调用的。<br>其实接下来才开始和那张图有关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // a uid</span><br><span class=\"line\">    vm._uid = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">let</span> startTag, endTag</span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = `vue-perf-start:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      endTag = `vue-perf-end:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果是Vue的实例，则不需要被observe</span><br><span class=\"line\">    vm._isVue = <span class=\"literal\">true</span></span><br><span class=\"line\">        // 第一步： options参数的处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class=\"line\">      // optimize internal component instantiation</span><br><span class=\"line\">      // since dynamic options merging is pretty slow, and none of the</span><br><span class=\"line\">      // internal component options needs special treatment.</span><br><span class=\"line\">      initInternalComponent(vm, options)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$options</span> = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第二步： renderProxy</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">        // 第三步： vm的生命周期相关变量初始化</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">        // 第四步： vm的事件监听（v-on）初始化</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm._name = formatComponentName(vm, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;vm._name&#125;</span> init`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第六步：render &amp; mount</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"variable\">$options</span>.el) &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$mount</span>(vm.<span class=\"variable\">$options</span>.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>代码中做了注释，</p>\n<ul>\n<li>第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。</li>\n<li>第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。</li>\n<li>第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。</li>\n<li>第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数</li>\n<li>第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。</li>\n</ul>\n<p>因此，至少在created时才能拿到data等里面的值。<br></p>\n<p>当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。</p>\n<p>编译方式有两种：</p>\n<ul>\n<li>编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。</li>\n</ul>\n<p>然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。</p>\n<ul>\n<li>运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。<br>（打把王者，回头再写，有点头疼）<br>loading…………………………………………………………………………..<br>王者打完了，接着写</li>\n</ul>\n<h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><p>解释一下图中在created和beforeMount之间的部分。<br>第一个分支：<br>如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。<br><br></p>\n<p>第二个分支：<br>1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数<br>2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高<br>3.如果1,2条件都不具备，则报错</p>\n<p>接着就调用beforeMount生命周期钩子<br><br><br>core/instance/lifecycle.js<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> mountComponent (</span><br><span class=\"line\">  vm: Component,</span><br><span class=\"line\">  el: ?Element,</span><br><span class=\"line\">  hydrating?: boolean</span><br><span class=\"line\">): Component &#123;</span><br><span class=\"line\">  vm.<span class=\"variable\">$el</span> = el</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!vm.<span class=\"variable\">$options</span>.render) &#123;</span><br><span class=\"line\">    vm.<span class=\"variable\">$options</span>.render = createEmptyVNode</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((vm.<span class=\"variable\">$options</span>.template &amp;&amp; vm.<span class=\"variable\">$options</span>.template.charAt(0) !== <span class=\"string\">'#'</span>) ||</span><br><span class=\"line\">        vm.<span class=\"variable\">$options</span>.el || el) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class=\"line\">          <span class=\"string\">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class=\"line\">          <span class=\"string\">'render functions, or use the compiler-included build.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callHook(vm, <span class=\"string\">'beforeMount'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">let</span> updateComponent</span><br><span class=\"line\">  /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      const name = vm._name</span><br><span class=\"line\">      const id = vm._uid</span><br><span class=\"line\">      const startTag = `vue-perf-start:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\">      const endTag = `vue-perf-end:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      const vnode = vm._render()</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> render`, startTag, endTag)</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      vm._update(vnode, hydrating)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> patch`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      vm._update(vm._render(), hydrating)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // we <span class=\"built_in\">set</span> this to vm._watcher inside the watcher<span class=\"string\">'s constructor</span></span><br><span class=\"line\"><span class=\"string\">  // since the watcher'</span>s initial patch may call <span class=\"variable\">$forceUpdate</span> (e.g. inside child</span><br><span class=\"line\">  // component<span class=\"string\">'s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class=\"line\"><span class=\"string\">  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span></span><br><span class=\"line\"><span class=\"string\">  hydrating = false</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // manually mounted instance, call mounted on self</span></span><br><span class=\"line\"><span class=\"string\">  // mounted is called for render-created child components in its inserted hook</span></span><br><span class=\"line\"><span class=\"string\">  if (vm.$vnode == null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    vm._isMounted = true</span></span><br><span class=\"line\"><span class=\"string\">    callHook(vm, '</span>mounted<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  return vm</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。</p>\n</blockquote>","more":"<p>话不多说，先来张图。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png\" alt=\"\"><br>熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。<br>知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。</p>\n<h3 id=\"阅读技巧\"><a href=\"#阅读技巧\" class=\"headerlink\" title=\"阅读技巧\"></a>阅读技巧</h3><p>这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(window, undefined) &#123;</span><br><span class=\"line\">    var  jQuery = <span class=\"keyword\">function</span>(selector, context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">return</span> new jQuery.fn.init(selector, context, rootjQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        init: <span class=\"keyword\">function</span>(selector, context, rootjQuery) &#123;</span><br><span class=\"line\">            // ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(window);</span><br></pre></td></tr></table></figure></p>\n<p>然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。</p>\n<p>而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png\" alt=\"\"><br>而入口文件是 core/index.js</p>\n<h3 id=\"正文开始\"><a href=\"#正文开始\" class=\"headerlink\" title=\"正文开始\"></a>正文开始</h3><p>core/index.js源码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Vue的核心方法</span><br><span class=\"line\">import Vue from <span class=\"string\">'./instance/index'</span></span><br><span class=\"line\">//初始化全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from <span class=\"string\">'./global-api/index'</span></span><br><span class=\"line\">//获取布尔值变量判断是不是SSR</span><br><span class=\"line\">import &#123; isServerRendering &#125; from <span class=\"string\">'core/util/env'</span></span><br><span class=\"line\">// 初始化全局变量</span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$isServer</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$isServer'</span>, &#123;</span><br><span class=\"line\">    get: isServerRendering</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 为Vue原型定义属性<span class=\"variable\">$ssrContext</span></span><br><span class=\"line\">Object.defineProperty(Vue.prototype, <span class=\"string\">'$ssrContext'</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span></span> () &#123;</span><br><span class=\"line\">        /* istanbul ignore next */</span><br><span class=\"line\">        <span class=\"built_in\">return</span> this.<span class=\"variable\">$vnode</span> &amp;&amp; this.<span class=\"variable\">$vnode</span>.ssrContext</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.version = <span class=\"string\">'__VERSION__'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure>\n<p>emmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  ‘./instance/index’,(凭直觉，这里应该有东西)<br><br><br>./instance/index<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import &#123; initMixin &#125; from <span class=\"string\">'./init'</span></span><br><span class=\"line\">import &#123; stateMixin &#125; from <span class=\"string\">'./state'</span></span><br><span class=\"line\">import &#123; renderMixin &#125; from <span class=\"string\">'./render'</span></span><br><span class=\"line\">import &#123; eventsMixin &#125; from <span class=\"string\">'./events'</span></span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from <span class=\"string\">'./lifecycle'</span></span><br><span class=\"line\">import &#123; warn &#125; from <span class=\"string\">'../util/index'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> Vue (options) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//为Vue的原型扩展_init方法</span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$data</span> <span class=\"variable\">$props</span> <span class=\"variable\">$set</span> <span class=\"variable\">$delete</span>等</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化<span class=\"variable\">$on</span> <span class=\"variable\">$once</span> <span class=\"variable\">$off</span> <span class=\"variable\">$emit</span>等函数</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化_update <span class=\"variable\">$forceUpdate</span> <span class=\"variable\">$destroy</span>函数</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化 <span class=\"variable\">$nextTick</span> _render函数</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default Vue</span><br></pre></td></tr></table></figure></p>\n<p>当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看</p>\n<p>点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br></pre></td></tr></table></figure>\n<p>initMixin就是再前文提到的./instance/index里被调用的。<br>其实接下来才开始和那张图有关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = <span class=\"keyword\">function</span> (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // a uid</span><br><span class=\"line\">    vm._uid = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">let</span> startTag, endTag</span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = `vue-perf-start:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      endTag = `vue-perf-end:<span class=\"variable\">$&#123;vm._uid&#125;</span>`</span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果是Vue的实例，则不需要被observe</span><br><span class=\"line\">    vm._isVue = <span class=\"literal\">true</span></span><br><span class=\"line\">        // 第一步： options参数的处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class=\"line\">      // optimize internal component instantiation</span><br><span class=\"line\">      // since dynamic options merging is pretty slow, and none of the</span><br><span class=\"line\">      // internal component options needs special treatment.</span><br><span class=\"line\">      initInternalComponent(vm, options)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$options</span> = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第二步： renderProxy</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">        // 第三步： vm的生命周期相关变量初始化</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">        // 第四步： vm的事件监听（v-on）初始化</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm._name = formatComponentName(vm, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;vm._name&#125;</span> init`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        // 第六步：render &amp; mount</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"variable\">$options</span>.el) &#123;</span><br><span class=\"line\">      vm.<span class=\"variable\">$mount</span>(vm.<span class=\"variable\">$options</span>.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>代码中做了注释，</p>\n<ul>\n<li>第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。</li>\n<li>第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。</li>\n<li>第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。</li>\n<li>第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数</li>\n<li>第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。</li>\n</ul>\n<p>因此，至少在created时才能拿到data等里面的值。<br></p>\n<p>当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。</p>\n<p>编译方式有两种：</p>\n<ul>\n<li>编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。</li>\n</ul>\n<p>然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。</p>\n<ul>\n<li>运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。<br>（打把王者，回头再写，有点头疼）<br>loading…………………………………………………………………………..<br>王者打完了，接着写</li>\n</ul>\n<h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><p>解释一下图中在created和beforeMount之间的部分。<br>第一个分支：<br>如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。<br><br></p>\n<p>第二个分支：<br>1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数<br>2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高<br>3.如果1,2条件都不具备，则报错</p>\n<p>接着就调用beforeMount生命周期钩子<br><br><br>core/instance/lifecycle.js<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> <span class=\"keyword\">function</span> mountComponent (</span><br><span class=\"line\">  vm: Component,</span><br><span class=\"line\">  el: ?Element,</span><br><span class=\"line\">  hydrating?: boolean</span><br><span class=\"line\">): Component &#123;</span><br><span class=\"line\">  vm.<span class=\"variable\">$el</span> = el</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!vm.<span class=\"variable\">$options</span>.render) &#123;</span><br><span class=\"line\">    vm.<span class=\"variable\">$options</span>.render = createEmptyVNode</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((vm.<span class=\"variable\">$options</span>.template &amp;&amp; vm.<span class=\"variable\">$options</span>.template.charAt(0) !== <span class=\"string\">'#'</span>) ||</span><br><span class=\"line\">        vm.<span class=\"variable\">$options</span>.el || el) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class=\"line\">          <span class=\"string\">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class=\"line\">          <span class=\"string\">'render functions, or use the compiler-included build.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callHook(vm, <span class=\"string\">'beforeMount'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">let</span> updateComponent</span><br><span class=\"line\">  /* istanbul ignore <span class=\"keyword\">if</span> */</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      const name = vm._name</span><br><span class=\"line\">      const id = vm._uid</span><br><span class=\"line\">      const startTag = `vue-perf-start:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\">      const endTag = `vue-perf-end:<span class=\"variable\">$&#123;id&#125;</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      const vnode = vm._render()</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> render`, startTag, endTag)</span><br><span class=\"line\"></span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">      vm._update(vnode, hydrating)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue <span class=\"variable\">$&#123;name&#125;</span> patch`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    updateComponent = () =&gt; &#123;</span><br><span class=\"line\">      vm._update(vm._render(), hydrating)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // we <span class=\"built_in\">set</span> this to vm._watcher inside the watcher<span class=\"string\">'s constructor</span></span><br><span class=\"line\"><span class=\"string\">  // since the watcher'</span>s initial patch may call <span class=\"variable\">$forceUpdate</span> (e.g. inside child</span><br><span class=\"line\">  // component<span class=\"string\">'s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class=\"line\"><span class=\"string\">  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span></span><br><span class=\"line\"><span class=\"string\">  hydrating = false</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // manually mounted instance, call mounted on self</span></span><br><span class=\"line\"><span class=\"string\">  // mounted is called for render-created child components in its inserted hook</span></span><br><span class=\"line\"><span class=\"string\">  if (vm.$vnode == null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    vm._isMounted = true</span></span><br><span class=\"line\"><span class=\"string\">    callHook(vm, '</span>mounted<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  return vm</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>"},{"title":"ReactNativeComponent","date":"2018-06-01T03:53:02.000Z","_content":"\n>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。\n>初学了一些东西，做个总结。\n<!--more-->\n### AppRegistry\nAppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。\n要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。\nAppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。\n\n### StyleSheet\nStyleSheet提供了一种类似CSS样式表的抽象。\n创建一个样式表：\n```bash\nvar styles = StyleSheet.create({\n  container: {\n    borderRadius: 4,\n    borderWidth: 0.5,\n    borderColor: '#d6d7da',\n  },\n  title: {\n    fontSize: 19,\n    fontWeight: 'bold',\n  },\n  activeTitle: {\n    color: 'red',\n  },\n});\n```\n使用一个样式表：\n```bash\n<View style={styles.container}>\n  <Text style={[styles.title, this.props.isActive && styles.activeTitle]} />\n</View>\n```\n从代码质量角度：\n从render函数中移除具体的样式内容，可以使代码更清晰易懂。\n给样式命名也是对render函数中的原始组件的作用的一种标记。\n从性能角度：\n创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。\n它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。\n注意：create() 和 hairlineWidth\n这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：\n\n```bash\n{\n    borderBottomColor: '#bbb',\n    borderBottomWidth: StyleSheet.hairlineWidth\n }\n```\n\n这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。\n\n###  Text\n一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。\nAndroid内建的字体有:\n+ normal\n+ serif\n+ monospace <br>\n\n\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n你必须把你的文本节点放在\\<Text>组件内。你不能直接在\\<View>下放置一段文本。\n\n### Image\n#### 宽、高尺寸设置\n+ Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。\n+ 有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：\n```bash\npreciseImageStyle: {\n  width: actrualWidth / PixelRatio.get(),\n  height: actrualHeight / PixelRatio.get(),\n}\n```\n#### Image组件的常见属性\n+ onLayout(function) <br>\n当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.\n\n+ onLoad (function)  <br>\n当图片加载成功之后，回调该方法\n\n+ onLoadEnd (function)  <br>\n当图片加载失败回调该方法，该不会管图片加载成功还是失败\n+ onLoadStart (fcuntion)  <br>\n当图片开始加载的时候调用该方法\n+ resizeMode  <br>\n缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片\n+ source{uri:string}  <br>\n进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径\n它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:\n```bash\n <Image\n                style={{flex: 1}}\n                source={[\n                   {uri:'https://facebook.github.io/react/img/logo_small.png', width: 38, height: 38},\n                  {uri: 'https://facebook.github.io/react/img/logo_small_2x.png', width: 76, height: 76},\n                  {uri: 'https://facebook.github.io/react/img/logo_og.png', width: 400, height: 400}\n                        ]}\n                    />\n\n```\n###  View\n作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。\nView的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。\n\n#### accessible bool\n当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。\n\n如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。\n#### onResponderMove function\n当用户正在屏幕上移动手指时调用这个函数\n\n### Button\n一个简单的跨平台的按钮组件。可以进行一些简单的定制。\ndisabled bool\n设置为true时此按钮将不可点击\n\n title: PropTypes.string.isRequired,\nPlatform.OS === 'android' ? title.toUpperCase() : title;\n\n### FlatList\nFlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。\nFlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。\nFlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。\n\n### SectionList\n如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。\n\n### TouchableOpacity\n本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。\n此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景\n### TouchableHighlight\n<em>注意：TouchableHighlight只支持一个子节点\n如果你希望包含多个子组件，用一个View来包装它们。</em>\n### ScrollView\n一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。\nScrollView和ListView/FlatList应该如何选择？\nScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。\n#### horizontal bool\n当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。\n#### pagingEnabled bool\n当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。\n#### showsHorizontalScrollIndicator bool #\n当此属性为true的时候，显示一个水平方向的滚动条。\n### Dimensions\n本模块用于获取设备屏幕的宽高\n例子：var {height, width} = Dimensions.get('window');\n","source":"_posts/ReactNativeComponent.md","raw":"---\ntitle: ReactNativeComponent\ndate: 2018-06-1 11:53:02\ntags: React Native\ncategories: 学习\n---\n\n>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。\n>初学了一些东西，做个总结。\n<!--more-->\n### AppRegistry\nAppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。\n要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。\nAppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。\n\n### StyleSheet\nStyleSheet提供了一种类似CSS样式表的抽象。\n创建一个样式表：\n```bash\nvar styles = StyleSheet.create({\n  container: {\n    borderRadius: 4,\n    borderWidth: 0.5,\n    borderColor: '#d6d7da',\n  },\n  title: {\n    fontSize: 19,\n    fontWeight: 'bold',\n  },\n  activeTitle: {\n    color: 'red',\n  },\n});\n```\n使用一个样式表：\n```bash\n<View style={styles.container}>\n  <Text style={[styles.title, this.props.isActive && styles.activeTitle]} />\n</View>\n```\n从代码质量角度：\n从render函数中移除具体的样式内容，可以使代码更清晰易懂。\n给样式命名也是对render函数中的原始组件的作用的一种标记。\n从性能角度：\n创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。\n它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。\n注意：create() 和 hairlineWidth\n这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：\n\n```bash\n{\n    borderBottomColor: '#bbb',\n    borderBottomWidth: StyleSheet.hairlineWidth\n }\n```\n\n这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。\n\n###  Text\n一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。\nAndroid内建的字体有:\n+ normal\n+ serif\n+ monospace <br>\n\n\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n\\<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。\n你必须把你的文本节点放在\\<Text>组件内。你不能直接在\\<View>下放置一段文本。\n\n### Image\n#### 宽、高尺寸设置\n+ Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。\n+ 有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：\n```bash\npreciseImageStyle: {\n  width: actrualWidth / PixelRatio.get(),\n  height: actrualHeight / PixelRatio.get(),\n}\n```\n#### Image组件的常见属性\n+ onLayout(function) <br>\n当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.\n\n+ onLoad (function)  <br>\n当图片加载成功之后，回调该方法\n\n+ onLoadEnd (function)  <br>\n当图片加载失败回调该方法，该不会管图片加载成功还是失败\n+ onLoadStart (fcuntion)  <br>\n当图片开始加载的时候调用该方法\n+ resizeMode  <br>\n缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片\n+ source{uri:string}  <br>\n进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径\n它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:\n```bash\n <Image\n                style={{flex: 1}}\n                source={[\n                   {uri:'https://facebook.github.io/react/img/logo_small.png', width: 38, height: 38},\n                  {uri: 'https://facebook.github.io/react/img/logo_small_2x.png', width: 76, height: 76},\n                  {uri: 'https://facebook.github.io/react/img/logo_og.png', width: 400, height: 400}\n                        ]}\n                    />\n\n```\n###  View\n作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。\nView的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。\n\n#### accessible bool\n当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。\n\n如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。\n#### onResponderMove function\n当用户正在屏幕上移动手指时调用这个函数\n\n### Button\n一个简单的跨平台的按钮组件。可以进行一些简单的定制。\ndisabled bool\n设置为true时此按钮将不可点击\n\n title: PropTypes.string.isRequired,\nPlatform.OS === 'android' ? title.toUpperCase() : title;\n\n### FlatList\nFlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。\nFlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。\nFlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。\n\n### SectionList\n如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。\n\n### TouchableOpacity\n本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。\n此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景\n### TouchableHighlight\n<em>注意：TouchableHighlight只支持一个子节点\n如果你希望包含多个子组件，用一个View来包装它们。</em>\n### ScrollView\n一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。\nScrollView和ListView/FlatList应该如何选择？\nScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。\n#### horizontal bool\n当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。\n#### pagingEnabled bool\n当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。\n#### showsHorizontalScrollIndicator bool #\n当此属性为true的时候，显示一个水平方向的滚动条。\n### Dimensions\n本模块用于获取设备屏幕的宽高\n例子：var {height, width} = Dimensions.get('window');\n","slug":"ReactNativeComponent","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskstf002ehvs64o2ij9rw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。<br>初学了一些东西，做个总结。<br><a id=\"more\"></a></p>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>AppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。<br>要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。<br>AppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。</p>\n</blockquote>\n<h3 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h3><p>StyleSheet提供了一种类似CSS样式表的抽象。<br>创建一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    borderRadius: 4,</span><br><span class=\"line\">    borderWidth: 0.5,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#d6d7da'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: 19,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  activeTitle: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>使用一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">  &lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p>\n<p>从代码质量角度：<br>从render函数中移除具体的样式内容，可以使代码更清晰易懂。<br>给样式命名也是对render函数中的原始组件的作用的一种标记。<br>从性能角度：<br>创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。<br>它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。<br>注意：create() 和 hairlineWidth<br>这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    borderBottomColor: <span class=\"string\">'#bbb'</span>,</span><br><span class=\"line\">    borderBottomWidth: StyleSheet.hairlineWidth</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。<br>Android内建的字体有:</p>\n<ul>\n<li>normal</li>\n<li>serif</li>\n<li>monospace <br></li>\n</ul>\n<p>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>你必须把你的文本节点放在\\<text>组件内。你不能直接在\\<view>下放置一段文本。</view></text></text></text></text></text></p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><h4 id=\"宽、高尺寸设置\"><a href=\"#宽、高尺寸设置\" class=\"headerlink\" title=\"宽、高尺寸设置\"></a>宽、高尺寸设置</h4><ul>\n<li>Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。</li>\n<li>有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preciseImageStyle: &#123;</span><br><span class=\"line\">  width: actrualWidth / PixelRatio.get(),</span><br><span class=\"line\">  height: actrualHeight / PixelRatio.get(),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Image组件的常见属性\"><a href=\"#Image组件的常见属性\" class=\"headerlink\" title=\"Image组件的常见属性\"></a>Image组件的常见属性</h4><ul>\n<li><p>onLayout(function) <br><br>当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.</p>\n</li>\n<li><p>onLoad (function)  <br><br>当图片加载成功之后，回调该方法</p>\n</li>\n<li><p>onLoadEnd (function)  <br><br>当图片加载失败回调该方法，该不会管图片加载成功还是失败</p>\n</li>\n<li>onLoadStart (fcuntion)  <br><br>当图片开始加载的时候调用该方法</li>\n<li>resizeMode  <br><br>缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片</li>\n<li>source{uri:string}  <br><br>进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径<br>它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Image</span><br><span class=\"line\">               style=&#123;&#123;flex: 1&#125;&#125;</span><br><span class=\"line\">               <span class=\"built_in\">source</span>=&#123;[</span><br><span class=\"line\">                  &#123;uri:<span class=\"string\">'https://facebook.github.io/react/img/logo_small.png'</span>, width: 38, height: 38&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_small_2x.png'</span>, width: 76, height: 76&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_og.png'</span>, width: 400, height: 400&#125;</span><br><span class=\"line\">                       ]&#125;</span><br><span class=\"line\">                   /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3><p>作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。<br>View的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。</div></p>\n<h4 id=\"accessible-bool\"><a href=\"#accessible-bool\" class=\"headerlink\" title=\"accessible bool\"></a>accessible bool</h4><p>当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。</p>\n<p>如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。</p>\n<h4 id=\"onResponderMove-function\"><a href=\"#onResponderMove-function\" class=\"headerlink\" title=\"onResponderMove function\"></a>onResponderMove function</h4><p>当用户正在屏幕上移动手指时调用这个函数</p>\n<h3 id=\"Button\"><a href=\"#Button\" class=\"headerlink\" title=\"Button\"></a>Button</h3><p>一个简单的跨平台的按钮组件。可以进行一些简单的定制。<br>disabled bool<br>设置为true时此按钮将不可点击</p>\n<p> title: PropTypes.string.isRequired,<br>Platform.OS === ‘android’ ? title.toUpperCase() : title;</p>\n<h3 id=\"FlatList\"><a href=\"#FlatList\" class=\"headerlink\" title=\"FlatList\"></a>FlatList</h3><p>FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。<br>FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。<br>FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p>\n<h3 id=\"SectionList\"><a href=\"#SectionList\" class=\"headerlink\" title=\"SectionList\"></a>SectionList</h3><p>如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。</p>\n<h3 id=\"TouchableOpacity\"><a href=\"#TouchableOpacity\" class=\"headerlink\" title=\"TouchableOpacity\"></a>TouchableOpacity</h3><p>本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。<br>此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景</p>\n<h3 id=\"TouchableHighlight\"><a href=\"#TouchableHighlight\" class=\"headerlink\" title=\"TouchableHighlight\"></a>TouchableHighlight</h3><p><em>注意：TouchableHighlight只支持一个子节点<br>如果你希望包含多个子组件，用一个View来包装它们。</em></p>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。<br>ScrollView和ListView/FlatList应该如何选择？<br>ScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。</p>\n<h4 id=\"horizontal-bool\"><a href=\"#horizontal-bool\" class=\"headerlink\" title=\"horizontal bool\"></a>horizontal bool</h4><p>当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</p>\n<h4 id=\"pagingEnabled-bool\"><a href=\"#pagingEnabled-bool\" class=\"headerlink\" title=\"pagingEnabled bool\"></a>pagingEnabled bool</h4><p>当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</p>\n<h4 id=\"showsHorizontalScrollIndicator-bool\"><a href=\"#showsHorizontalScrollIndicator-bool\" class=\"headerlink\" title=\"showsHorizontalScrollIndicator bool\"></a>showsHorizontalScrollIndicator bool</h4><p>当此属性为true的时候，显示一个水平方向的滚动条。</p>\n<h3 id=\"Dimensions\"><a href=\"#Dimensions\" class=\"headerlink\" title=\"Dimensions\"></a>Dimensions</h3><p>本模块用于获取设备屏幕的宽高<br>例子：var {height, width} = Dimensions.get(‘window’);</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。<br>初学了一些东西，做个总结。<br>","more":"</p>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>AppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。<br>要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。<br>AppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。</p>\n</blockquote>\n<h3 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h3><p>StyleSheet提供了一种类似CSS样式表的抽象。<br>创建一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    borderRadius: 4,</span><br><span class=\"line\">    borderWidth: 0.5,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#d6d7da'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: 19,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  activeTitle: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>使用一个样式表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">  &lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p>\n<p>从代码质量角度：<br>从render函数中移除具体的样式内容，可以使代码更清晰易懂。<br>给样式命名也是对render函数中的原始组件的作用的一种标记。<br>从性能角度：<br>创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。<br>它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。<br>注意：create() 和 hairlineWidth<br>这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    borderBottomColor: <span class=\"string\">'#bbb'</span>,</span><br><span class=\"line\">    borderBottomWidth: StyleSheet.hairlineWidth</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。<br>Android内建的字体有:</p>\n<ul>\n<li>normal</li>\n<li>serif</li>\n<li>monospace <br></li>\n</ul>\n<p>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>\\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>你必须把你的文本节点放在\\<text>组件内。你不能直接在\\<view>下放置一段文本。</view></text></text></text></text></text></p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><h4 id=\"宽、高尺寸设置\"><a href=\"#宽、高尺寸设置\" class=\"headerlink\" title=\"宽、高尺寸设置\"></a>宽、高尺寸设置</h4><ul>\n<li>Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。</li>\n<li>有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preciseImageStyle: &#123;</span><br><span class=\"line\">  width: actrualWidth / PixelRatio.get(),</span><br><span class=\"line\">  height: actrualHeight / PixelRatio.get(),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Image组件的常见属性\"><a href=\"#Image组件的常见属性\" class=\"headerlink\" title=\"Image组件的常见属性\"></a>Image组件的常见属性</h4><ul>\n<li><p>onLayout(function) <br><br>当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.</p>\n</li>\n<li><p>onLoad (function)  <br><br>当图片加载成功之后，回调该方法</p>\n</li>\n<li><p>onLoadEnd (function)  <br><br>当图片加载失败回调该方法，该不会管图片加载成功还是失败</p>\n</li>\n<li>onLoadStart (fcuntion)  <br><br>当图片开始加载的时候调用该方法</li>\n<li>resizeMode  <br><br>缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片</li>\n<li>source{uri:string}  <br><br>进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径<br>它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Image</span><br><span class=\"line\">               style=&#123;&#123;flex: 1&#125;&#125;</span><br><span class=\"line\">               <span class=\"built_in\">source</span>=&#123;[</span><br><span class=\"line\">                  &#123;uri:<span class=\"string\">'https://facebook.github.io/react/img/logo_small.png'</span>, width: 38, height: 38&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_small_2x.png'</span>, width: 76, height: 76&#125;,</span><br><span class=\"line\">                 &#123;uri: <span class=\"string\">'https://facebook.github.io/react/img/logo_og.png'</span>, width: 400, height: 400&#125;</span><br><span class=\"line\">                       ]&#125;</span><br><span class=\"line\">                   /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3><p>作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\\<div>还是android.view.View。<br>View的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。</div></p>\n<h4 id=\"accessible-bool\"><a href=\"#accessible-bool\" class=\"headerlink\" title=\"accessible bool\"></a>accessible bool</h4><p>当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。</p>\n<p>如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。</p>\n<h4 id=\"onResponderMove-function\"><a href=\"#onResponderMove-function\" class=\"headerlink\" title=\"onResponderMove function\"></a>onResponderMove function</h4><p>当用户正在屏幕上移动手指时调用这个函数</p>\n<h3 id=\"Button\"><a href=\"#Button\" class=\"headerlink\" title=\"Button\"></a>Button</h3><p>一个简单的跨平台的按钮组件。可以进行一些简单的定制。<br>disabled bool<br>设置为true时此按钮将不可点击</p>\n<p> title: PropTypes.string.isRequired,<br>Platform.OS === ‘android’ ? title.toUpperCase() : title;</p>\n<h3 id=\"FlatList\"><a href=\"#FlatList\" class=\"headerlink\" title=\"FlatList\"></a>FlatList</h3><p>FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。<br>FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。<br>FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p>\n<h3 id=\"SectionList\"><a href=\"#SectionList\" class=\"headerlink\" title=\"SectionList\"></a>SectionList</h3><p>如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。</p>\n<h3 id=\"TouchableOpacity\"><a href=\"#TouchableOpacity\" class=\"headerlink\" title=\"TouchableOpacity\"></a>TouchableOpacity</h3><p>本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。<br>此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景</p>\n<h3 id=\"TouchableHighlight\"><a href=\"#TouchableHighlight\" class=\"headerlink\" title=\"TouchableHighlight\"></a>TouchableHighlight</h3><p><em>注意：TouchableHighlight只支持一个子节点<br>如果你希望包含多个子组件，用一个View来包装它们。</em></p>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。<br>ScrollView和ListView/FlatList应该如何选择？<br>ScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。</p>\n<h4 id=\"horizontal-bool\"><a href=\"#horizontal-bool\" class=\"headerlink\" title=\"horizontal bool\"></a>horizontal bool</h4><p>当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</p>\n<h4 id=\"pagingEnabled-bool\"><a href=\"#pagingEnabled-bool\" class=\"headerlink\" title=\"pagingEnabled bool\"></a>pagingEnabled bool</h4><p>当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</p>\n<h4 id=\"showsHorizontalScrollIndicator-bool\"><a href=\"#showsHorizontalScrollIndicator-bool\" class=\"headerlink\" title=\"showsHorizontalScrollIndicator bool\"></a>showsHorizontalScrollIndicator bool</h4><p>当此属性为true的时候，显示一个水平方向的滚动条。</p>\n<h3 id=\"Dimensions\"><a href=\"#Dimensions\" class=\"headerlink\" title=\"Dimensions\"></a>Dimensions</h3><p>本模块用于获取设备屏幕的宽高<br>例子：var {height, width} = Dimensions.get(‘window’);</p>"},{"title":"koaMiddleWare","date":"2018-08-07T13:09:48.000Z","_content":"### js的异步解决方案\n在javascript里，异步的解决方案包括以下几种：\n\n+ 回调\n+ promise\n+ generator\n+ async\n优雅程度自上而下。\n<!--more-->\n\n### express koa1 koa2\n随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br>\n\nkoa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。\n<br>\n\n在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。\n个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br>\n\n### application.js\nkoa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：\n```bash\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst isGeneratorFunction = require('is-generator-function');\nconst debug = require('debug')('koa:application');\nconst onFinished = require('on-finished');\nconst response = require('./response');\nconst compose = require('koa-compose');\nconst isJSON = require('koa-is-json');\nconst context = require('./context');\nconst request = require('./request');\nconst statuses = require('statuses');\nconst Emitter = require('events');\nconst util = require('util');\nconst Stream = require('stream');\nconst http = require('http');\nconst only = require('only');\nconst convert = require('koa-convert');\nconst deprecate = require('depd')('koa');\n\n/**\n * Expose `Application` class.\n * Inherits from `Emitter.prototype`.\n */\n\n //继承Emitter  因此 koa的实例 this可以调用on\nmodule.exports = class Application extends Emitter {\n  /**\n   * Initialize a new `Application`.\n   *\n   * @api public\n   */\n\n  constructor() {\n    super();\n\n    this.proxy = false; //代理设置\n    this.middleware = [];\n    this.subdomainOffset = 2; //域名偏移\n    this.env = process.env.NODE_ENV || 'development';\n    this.context = Object.create(context);\n    this.request = Object.create(request);\n    this.response = Object.create(response);\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  /**\n   * Shorthand for:\n   *\n   *    http.createServer(app.callback()).listen(...)\n   *\n   * @param {Mixed} ...\n   * @return {Server}\n   * @api public\n   */\n\n  listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n\n  /**\n   * Return JSON representation.\n   * We only bother showing settings.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  toJSON() {\n    return only(this, [\n      'subdomainOffset',\n      'proxy',\n      'env'\n    ]);\n  }\n\n  /**\n   * Inspect implementation.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  inspect() {\n    return this.toJSON();\n  }\n\n  /**\n   * Use the given middleware `fn`.\n   *\n   * Old-style middleware will be converted.\n   *\n   * @param {Function} fn\n   * @return {Application} self\n   * @api public\n   */\n\n  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),\n  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.\n  use(fn) {\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n    if (isGeneratorFunction(fn)) {\n      deprecate('Support for generators will be removed in v3. ' +\n                'See the documentation for examples of how to convert old middleware ' +\n                'https://github.com/koajs/koa/blob/master/docs/migration.md');\n      fn = convert(fn);\n    }\n    debug('use %s', fn._name || fn.name || '-');\n    this.middleware.push(fn);\n    return this;\n  }\n\n  /**\n   * Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public\n   */\n\n  callback() {\n    //合并中间件\n    const fn = compose(this.middleware);\n\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  /**\n   * Handle request in callback.\n   *\n   * @api private\n   */\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  /**\n   * Initialize a new context.\n   *\n   * @api private\n   */\n\n   //创建cotext request reponse 与http模块的关系\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n\n  /**\n   * Default error handler.\n   *\n   * @param {Error} err\n   * @api private\n   */\n\n  onerror(err) {\n    if (!(err instanceof Error)) throw new TypeError(util.format('non-error thrown: %j', err));\n\n    if (404 == err.status || err.expose) return;\n    if (this.silent) return;\n\n    const msg = err.stack || err.toString();\n    console.error();\n    console.error(msg.replace(/^/gm, '  '));\n    console.error();\n  }\n};\n\n/**\n * Response helper.\n */\n\nfunction respond(ctx) {\n  // allow bypassing koa\n  if (false === ctx.respond) return;\n\n  const res = ctx.res;\n  if (!ctx.writable) return;\n\n  let body = ctx.body;\n  const code = ctx.status;\n\n  // ignore body\n  if (statuses.empty[code]) {\n    // strip headers\n    ctx.body = null;\n    return res.end();\n  }\n\n  if ('HEAD' == ctx.method) {\n    if (!res.headersSent && isJSON(body)) {\n      ctx.length = Buffer.byteLength(JSON.stringify(body));\n    }\n    return res.end();\n  }\n\n  // status body\n  if (null == body) {\n    body = ctx.message || String(code);\n    if (!res.headersSent) {\n      ctx.type = 'text';\n      ctx.length = Buffer.byteLength(body);\n    }\n    return res.end(body);\n  }\n\n  // responses\n  if (Buffer.isBuffer(body)) return res.end(body);\n  if ('string' == typeof body) return res.end(body);\n  if (body instanceof Stream) return body.pipe(res);\n\n  // body: json\n  body = JSON.stringify(body);\n  if (!res.headersSent) {\n    ctx.length = Buffer.byteLength(body);\n  }\n  res.end(body);\n}\n```\n其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。\n<br>\n当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br>\n最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。\n\n### compose.js\n\n```bash\nuse strict'\n\n/**\n * Expose compositor.\n */\n\nmodule.exports = compose\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\n\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1; //当前中间件的索引\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\ncompose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\" />\n其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。\n","source":"_posts/koaMiddle.md","raw":"---\ntitle: koaMiddleWare\ndate: 2018-08-07 21:09:48\ntags: koa\ncategories: 学习\n---\n### js的异步解决方案\n在javascript里，异步的解决方案包括以下几种：\n\n+ 回调\n+ promise\n+ generator\n+ async\n优雅程度自上而下。\n<!--more-->\n\n### express koa1 koa2\n随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br>\n\nkoa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。\n<br>\n\n在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。\n个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br>\n\n### application.js\nkoa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：\n```bash\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst isGeneratorFunction = require('is-generator-function');\nconst debug = require('debug')('koa:application');\nconst onFinished = require('on-finished');\nconst response = require('./response');\nconst compose = require('koa-compose');\nconst isJSON = require('koa-is-json');\nconst context = require('./context');\nconst request = require('./request');\nconst statuses = require('statuses');\nconst Emitter = require('events');\nconst util = require('util');\nconst Stream = require('stream');\nconst http = require('http');\nconst only = require('only');\nconst convert = require('koa-convert');\nconst deprecate = require('depd')('koa');\n\n/**\n * Expose `Application` class.\n * Inherits from `Emitter.prototype`.\n */\n\n //继承Emitter  因此 koa的实例 this可以调用on\nmodule.exports = class Application extends Emitter {\n  /**\n   * Initialize a new `Application`.\n   *\n   * @api public\n   */\n\n  constructor() {\n    super();\n\n    this.proxy = false; //代理设置\n    this.middleware = [];\n    this.subdomainOffset = 2; //域名偏移\n    this.env = process.env.NODE_ENV || 'development';\n    this.context = Object.create(context);\n    this.request = Object.create(request);\n    this.response = Object.create(response);\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  /**\n   * Shorthand for:\n   *\n   *    http.createServer(app.callback()).listen(...)\n   *\n   * @param {Mixed} ...\n   * @return {Server}\n   * @api public\n   */\n\n  listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n\n  /**\n   * Return JSON representation.\n   * We only bother showing settings.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  toJSON() {\n    return only(this, [\n      'subdomainOffset',\n      'proxy',\n      'env'\n    ]);\n  }\n\n  /**\n   * Inspect implementation.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  inspect() {\n    return this.toJSON();\n  }\n\n  /**\n   * Use the given middleware `fn`.\n   *\n   * Old-style middleware will be converted.\n   *\n   * @param {Function} fn\n   * @return {Application} self\n   * @api public\n   */\n\n  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),\n  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.\n  use(fn) {\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n    if (isGeneratorFunction(fn)) {\n      deprecate('Support for generators will be removed in v3. ' +\n                'See the documentation for examples of how to convert old middleware ' +\n                'https://github.com/koajs/koa/blob/master/docs/migration.md');\n      fn = convert(fn);\n    }\n    debug('use %s', fn._name || fn.name || '-');\n    this.middleware.push(fn);\n    return this;\n  }\n\n  /**\n   * Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public\n   */\n\n  callback() {\n    //合并中间件\n    const fn = compose(this.middleware);\n\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  /**\n   * Handle request in callback.\n   *\n   * @api private\n   */\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  /**\n   * Initialize a new context.\n   *\n   * @api private\n   */\n\n   //创建cotext request reponse 与http模块的关系\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n\n  /**\n   * Default error handler.\n   *\n   * @param {Error} err\n   * @api private\n   */\n\n  onerror(err) {\n    if (!(err instanceof Error)) throw new TypeError(util.format('non-error thrown: %j', err));\n\n    if (404 == err.status || err.expose) return;\n    if (this.silent) return;\n\n    const msg = err.stack || err.toString();\n    console.error();\n    console.error(msg.replace(/^/gm, '  '));\n    console.error();\n  }\n};\n\n/**\n * Response helper.\n */\n\nfunction respond(ctx) {\n  // allow bypassing koa\n  if (false === ctx.respond) return;\n\n  const res = ctx.res;\n  if (!ctx.writable) return;\n\n  let body = ctx.body;\n  const code = ctx.status;\n\n  // ignore body\n  if (statuses.empty[code]) {\n    // strip headers\n    ctx.body = null;\n    return res.end();\n  }\n\n  if ('HEAD' == ctx.method) {\n    if (!res.headersSent && isJSON(body)) {\n      ctx.length = Buffer.byteLength(JSON.stringify(body));\n    }\n    return res.end();\n  }\n\n  // status body\n  if (null == body) {\n    body = ctx.message || String(code);\n    if (!res.headersSent) {\n      ctx.type = 'text';\n      ctx.length = Buffer.byteLength(body);\n    }\n    return res.end(body);\n  }\n\n  // responses\n  if (Buffer.isBuffer(body)) return res.end(body);\n  if ('string' == typeof body) return res.end(body);\n  if (body instanceof Stream) return body.pipe(res);\n\n  // body: json\n  body = JSON.stringify(body);\n  if (!res.headersSent) {\n    ctx.length = Buffer.byteLength(body);\n  }\n  res.end(body);\n}\n```\n其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。\n<br>\n当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br>\n最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。\n\n### compose.js\n\n```bash\nuse strict'\n\n/**\n * Expose compositor.\n */\n\nmodule.exports = compose\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\n\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1; //当前中间件的索引\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\ncompose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。\n<img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\" />\n其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。\n","slug":"koaMiddle","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydsksth002hhvs64dkjo4nx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"js的异步解决方案\"><a href=\"#js的异步解决方案\" class=\"headerlink\" title=\"js的异步解决方案\"></a>js的异步解决方案</h3><p>在javascript里，异步的解决方案包括以下几种：</p>\n<ul>\n<li>回调</li>\n<li>promise</li>\n<li>generator</li>\n<li>async<br>优雅程度自上而下。<a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"express-koa1-koa2\"><a href=\"#express-koa1-koa2\" class=\"headerlink\" title=\"express koa1 koa2\"></a>express koa1 koa2</h3><p>随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br></p>\n<p>koa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。<br><br></p>\n<p>在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。<br>个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br></p>\n<h3 id=\"application-js\"><a href=\"#application-js\" class=\"headerlink\" title=\"application.js\"></a>application.js</h3><p>koa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Module dependencies.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">const isGeneratorFunction = require(<span class=\"string\">'is-generator-function'</span>);</span><br><span class=\"line\">const debug = require(<span class=\"string\">'debug'</span>)(<span class=\"string\">'koa:application'</span>);</span><br><span class=\"line\">const onFinished = require(<span class=\"string\">'on-finished'</span>);</span><br><span class=\"line\">const response = require(<span class=\"string\">'./response'</span>);</span><br><span class=\"line\">const compose = require(<span class=\"string\">'koa-compose'</span>);</span><br><span class=\"line\">const isJSON = require(<span class=\"string\">'koa-is-json'</span>);</span><br><span class=\"line\">const context = require(<span class=\"string\">'./context'</span>);</span><br><span class=\"line\">const request = require(<span class=\"string\">'./request'</span>);</span><br><span class=\"line\">const statuses = require(<span class=\"string\">'statuses'</span>);</span><br><span class=\"line\">const Emitter = require(<span class=\"string\">'events'</span>);</span><br><span class=\"line\">const util = require(<span class=\"string\">'util'</span>);</span><br><span class=\"line\">const Stream = require(<span class=\"string\">'stream'</span>);</span><br><span class=\"line\">const http = require(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">const only = require(<span class=\"string\">'only'</span>);</span><br><span class=\"line\">const convert = require(<span class=\"string\">'koa-convert'</span>);</span><br><span class=\"line\">const deprecate = require(<span class=\"string\">'depd'</span>)(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Expose `Application` class.</span><br><span class=\"line\"> * Inherits from `Emitter.prototype`.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\"> //继承Emitter  因此 koa的实例 this可以调用on</span><br><span class=\"line\">module.exports = class Application extends Emitter &#123;</span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Initialize a new `Application`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span></span>() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\"></span><br><span class=\"line\">    this.proxy = <span class=\"literal\">false</span>; //代理设置</span><br><span class=\"line\">    this.middleware = [];</span><br><span class=\"line\">    this.subdomainOffset = 2; //域名偏移</span><br><span class=\"line\">    this.env = process.env.NODE_ENV || <span class=\"string\">'development'</span>;</span><br><span class=\"line\">    this.context = Object.create(context);</span><br><span class=\"line\">    this.request = Object.create(request);</span><br><span class=\"line\">    this.response = Object.create(response);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (util.inspect.custom) &#123;</span><br><span class=\"line\">      this[util.inspect.custom] = this.inspect;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Shorthand <span class=\"keyword\">for</span>:</span><br><span class=\"line\">   *</span><br><span class=\"line\">   *    http.createServer(app.callback()).listen(...)</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Mixed&#125; ...</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Server&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  listen(...args) &#123;</span><br><span class=\"line\">    debug(<span class=\"string\">'listen'</span>);</span><br><span class=\"line\">    const server = http.createServer(this.callback());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> server.listen(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return JSON representation.</span><br><span class=\"line\">   * We only bother showing settings.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toJSON</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> only(this, [</span><br><span class=\"line\">      <span class=\"string\">'subdomainOffset'</span>,</span><br><span class=\"line\">      <span class=\"string\">'proxy'</span>,</span><br><span class=\"line\">      <span class=\"string\">'env'</span></span><br><span class=\"line\">    ]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Inspect implementation.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inspect</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this.toJSON();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Use the given middleware `fn`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * Old-style middleware will be converted.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Function&#125; fn</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Application&#125; self</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),</span><br><span class=\"line\">  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof fn !== <span class=\"string\">'function'</span>) throw new TypeError(<span class=\"string\">'middleware must be a function!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class=\"line\">      deprecate(<span class=\"string\">'Support for generators will be removed in v3. '</span> +</span><br><span class=\"line\">                <span class=\"string\">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class=\"line\">                <span class=\"string\">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class=\"line\">      fn = convert(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debug(<span class=\"string\">'use %s'</span>, fn._name || fn.name || <span class=\"string\">'-'</span>);</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return a request handler callback</span><br><span class=\"line\">   * <span class=\"keyword\">for</span> node<span class=\"string\">'s native http server.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  callback() &#123;</span></span><br><span class=\"line\"><span class=\"string\">    //合并中间件</span></span><br><span class=\"line\"><span class=\"string\">    const fn = compose(this.middleware);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (!this.listenerCount('</span>error<span class=\"string\">')) this.on('</span>error<span class=\"string\">', this.onerror);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const handleRequest = (req, res) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">      const ctx = this.createContext(req, res);</span></span><br><span class=\"line\"><span class=\"string\">      return this.handleRequest(ctx, fn);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    return handleRequest;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Handle request in callback.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  handleRequest(ctx, fnMiddleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">    res.statusCode = 404;</span></span><br><span class=\"line\"><span class=\"string\">    const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class=\"line\"><span class=\"string\">    const handleResponse = () =&gt; respond(ctx);</span></span><br><span class=\"line\"><span class=\"string\">    onFinished(res, onerror);</span></span><br><span class=\"line\"><span class=\"string\">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Initialize a new context.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">   //创建cotext request reponse 与http模块的关系</span></span><br><span class=\"line\"><span class=\"string\">  createContext(req, res) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const context = Object.create(this.context);</span></span><br><span class=\"line\"><span class=\"string\">    const request = context.request = Object.create(this.request);</span></span><br><span class=\"line\"><span class=\"string\">    const response = context.response = Object.create(this.response);</span></span><br><span class=\"line\"><span class=\"string\">    context.app = request.app = response.app = this;</span></span><br><span class=\"line\"><span class=\"string\">    context.req = request.req = response.req = req;</span></span><br><span class=\"line\"><span class=\"string\">    context.res = request.res = response.res = res;</span></span><br><span class=\"line\"><span class=\"string\">    request.ctx = response.ctx = context;</span></span><br><span class=\"line\"><span class=\"string\">    request.response = response;</span></span><br><span class=\"line\"><span class=\"string\">    response.request = request;</span></span><br><span class=\"line\"><span class=\"string\">    context.originalUrl = request.originalUrl = req.url;</span></span><br><span class=\"line\"><span class=\"string\">    context.state = &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\">    return context;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Default error handler.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Error&#125; err</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  onerror(err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!(err instanceof Error)) throw new TypeError(util.format('</span>non-error thrown: %j<span class=\"string\">', err));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (404 == err.status || err.expose) return;</span></span><br><span class=\"line\"><span class=\"string\">    if (this.silent) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const msg = err.stack || err.toString();</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">    console.error(msg.replace(/^/gm, '</span>  <span class=\"string\">'));</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Response helper.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function respond(ctx) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  // allow bypassing koa</span></span><br><span class=\"line\"><span class=\"string\">  if (false === ctx.respond) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">  if (!ctx.writable) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  let body = ctx.body;</span></span><br><span class=\"line\"><span class=\"string\">  const code = ctx.status;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // ignore body</span></span><br><span class=\"line\"><span class=\"string\">  if (statuses.empty[code]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // strip headers</span></span><br><span class=\"line\"><span class=\"string\">    ctx.body = null;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>HEAD<span class=\"string\">' == ctx.method) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // status body</span></span><br><span class=\"line\"><span class=\"string\">  if (null == body) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    body = ctx.message || String(code);</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.type = '</span>text<span class=\"string\">';</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // responses</span></span><br><span class=\"line\"><span class=\"string\">  if (Buffer.isBuffer(body)) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>string<span class=\"string\">' == typeof body) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (body instanceof Stream) return body.pipe(res);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // body: json</span></span><br><span class=\"line\"><span class=\"string\">  body = JSON.stringify(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。<br><br><br>当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br><br>最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。</p>\n<h3 id=\"compose-js\"><a href=\"#compose-js\" class=\"headerlink\" title=\"compose.js\"></a>compose.js</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use strict<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Expose compositor.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">module.exports = compose</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Compose `middleware` returning</span></span><br><span class=\"line\"><span class=\"string\"> * a fully valid middleware comprised</span></span><br><span class=\"line\"><span class=\"string\"> * of all those which are passed.</span></span><br><span class=\"line\"><span class=\"string\"> *</span></span><br><span class=\"line\"><span class=\"string\"> * @param &#123;Array&#125; middleware</span></span><br><span class=\"line\"><span class=\"string\"> * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\"> * @api public</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function compose (middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  if (!Array.isArray(middleware)) throw new TypeError('</span>Middleware stack must be an array!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  for (const fn of middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (typeof fn !== '</span><span class=\"keyword\">function</span><span class=\"string\">') throw new TypeError('</span>Middleware must be composed of <span class=\"built_in\">functions</span>!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Object&#125; context</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Promise&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  return function (context, next) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // last called middleware #</span></span><br><span class=\"line\"><span class=\"string\">    let index = -1; //当前中间件的索引</span></span><br><span class=\"line\"><span class=\"string\">    return dispatch(0)</span></span><br><span class=\"line\"><span class=\"string\">    function dispatch (i) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      if (i &lt;= index) return Promise.reject(new Error('</span>next() called multiple <span class=\"built_in\">times</span><span class=\"string\">'))</span></span><br><span class=\"line\"><span class=\"string\">      index = i</span></span><br><span class=\"line\"><span class=\"string\">      let fn = middleware[i]</span></span><br><span class=\"line\"><span class=\"string\">      if (i === middleware.length) fn = next</span></span><br><span class=\"line\"><span class=\"string\">      if (!fn) return Promise.resolve()</span></span><br><span class=\"line\"><span class=\"string\">      try &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span></span><br><span class=\"line\"><span class=\"string\">      &#125; catch (err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.reject(err)</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>compose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\"><br>其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"js的异步解决方案\"><a href=\"#js的异步解决方案\" class=\"headerlink\" title=\"js的异步解决方案\"></a>js的异步解决方案</h3><p>在javascript里，异步的解决方案包括以下几种：</p>\n<ul>\n<li>回调</li>\n<li>promise</li>\n<li>generator</li>\n<li>async<br>优雅程度自上而下。","more":"</li>\n</ul>\n<h3 id=\"express-koa1-koa2\"><a href=\"#express-koa1-koa2\" class=\"headerlink\" title=\"express koa1 koa2\"></a>express koa1 koa2</h3><p>随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br></p>\n<p>koa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。<br><br></p>\n<p>在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。<br>个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br></p>\n<h3 id=\"application-js\"><a href=\"#application-js\" class=\"headerlink\" title=\"application.js\"></a>application.js</h3><p>koa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Module dependencies.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">const isGeneratorFunction = require(<span class=\"string\">'is-generator-function'</span>);</span><br><span class=\"line\">const debug = require(<span class=\"string\">'debug'</span>)(<span class=\"string\">'koa:application'</span>);</span><br><span class=\"line\">const onFinished = require(<span class=\"string\">'on-finished'</span>);</span><br><span class=\"line\">const response = require(<span class=\"string\">'./response'</span>);</span><br><span class=\"line\">const compose = require(<span class=\"string\">'koa-compose'</span>);</span><br><span class=\"line\">const isJSON = require(<span class=\"string\">'koa-is-json'</span>);</span><br><span class=\"line\">const context = require(<span class=\"string\">'./context'</span>);</span><br><span class=\"line\">const request = require(<span class=\"string\">'./request'</span>);</span><br><span class=\"line\">const statuses = require(<span class=\"string\">'statuses'</span>);</span><br><span class=\"line\">const Emitter = require(<span class=\"string\">'events'</span>);</span><br><span class=\"line\">const util = require(<span class=\"string\">'util'</span>);</span><br><span class=\"line\">const Stream = require(<span class=\"string\">'stream'</span>);</span><br><span class=\"line\">const http = require(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">const only = require(<span class=\"string\">'only'</span>);</span><br><span class=\"line\">const convert = require(<span class=\"string\">'koa-convert'</span>);</span><br><span class=\"line\">const deprecate = require(<span class=\"string\">'depd'</span>)(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Expose `Application` class.</span><br><span class=\"line\"> * Inherits from `Emitter.prototype`.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\"> //继承Emitter  因此 koa的实例 this可以调用on</span><br><span class=\"line\">module.exports = class Application extends Emitter &#123;</span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Initialize a new `Application`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span></span>() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\"></span><br><span class=\"line\">    this.proxy = <span class=\"literal\">false</span>; //代理设置</span><br><span class=\"line\">    this.middleware = [];</span><br><span class=\"line\">    this.subdomainOffset = 2; //域名偏移</span><br><span class=\"line\">    this.env = process.env.NODE_ENV || <span class=\"string\">'development'</span>;</span><br><span class=\"line\">    this.context = Object.create(context);</span><br><span class=\"line\">    this.request = Object.create(request);</span><br><span class=\"line\">    this.response = Object.create(response);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (util.inspect.custom) &#123;</span><br><span class=\"line\">      this[util.inspect.custom] = this.inspect;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Shorthand <span class=\"keyword\">for</span>:</span><br><span class=\"line\">   *</span><br><span class=\"line\">   *    http.createServer(app.callback()).listen(...)</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Mixed&#125; ...</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Server&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  listen(...args) &#123;</span><br><span class=\"line\">    debug(<span class=\"string\">'listen'</span>);</span><br><span class=\"line\">    const server = http.createServer(this.callback());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> server.listen(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return JSON representation.</span><br><span class=\"line\">   * We only bother showing settings.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toJSON</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> only(this, [</span><br><span class=\"line\">      <span class=\"string\">'subdomainOffset'</span>,</span><br><span class=\"line\">      <span class=\"string\">'proxy'</span>,</span><br><span class=\"line\">      <span class=\"string\">'env'</span></span><br><span class=\"line\">    ]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Inspect implementation.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Object&#125;</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inspect</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this.toJSON();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Use the given middleware `fn`.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * Old-style middleware will be converted.</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param &#123;Function&#125; fn</span><br><span class=\"line\">   * @<span class=\"built_in\">return</span> &#123;Application&#125; self</span><br><span class=\"line\">   * @api public</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),</span><br><span class=\"line\">  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeof fn !== <span class=\"string\">'function'</span>) throw new TypeError(<span class=\"string\">'middleware must be a function!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class=\"line\">      deprecate(<span class=\"string\">'Support for generators will be removed in v3. '</span> +</span><br><span class=\"line\">                <span class=\"string\">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class=\"line\">                <span class=\"string\">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class=\"line\">      fn = convert(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debug(<span class=\"string\">'use %s'</span>, fn._name || fn.name || <span class=\"string\">'-'</span>);</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Return a request handler callback</span><br><span class=\"line\">   * <span class=\"keyword\">for</span> node<span class=\"string\">'s native http server.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  callback() &#123;</span></span><br><span class=\"line\"><span class=\"string\">    //合并中间件</span></span><br><span class=\"line\"><span class=\"string\">    const fn = compose(this.middleware);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (!this.listenerCount('</span>error<span class=\"string\">')) this.on('</span>error<span class=\"string\">', this.onerror);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const handleRequest = (req, res) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">      const ctx = this.createContext(req, res);</span></span><br><span class=\"line\"><span class=\"string\">      return this.handleRequest(ctx, fn);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    return handleRequest;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Handle request in callback.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  handleRequest(ctx, fnMiddleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">    res.statusCode = 404;</span></span><br><span class=\"line\"><span class=\"string\">    const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class=\"line\"><span class=\"string\">    const handleResponse = () =&gt; respond(ctx);</span></span><br><span class=\"line\"><span class=\"string\">    onFinished(res, onerror);</span></span><br><span class=\"line\"><span class=\"string\">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Initialize a new context.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">   //创建cotext request reponse 与http模块的关系</span></span><br><span class=\"line\"><span class=\"string\">  createContext(req, res) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    const context = Object.create(this.context);</span></span><br><span class=\"line\"><span class=\"string\">    const request = context.request = Object.create(this.request);</span></span><br><span class=\"line\"><span class=\"string\">    const response = context.response = Object.create(this.response);</span></span><br><span class=\"line\"><span class=\"string\">    context.app = request.app = response.app = this;</span></span><br><span class=\"line\"><span class=\"string\">    context.req = request.req = response.req = req;</span></span><br><span class=\"line\"><span class=\"string\">    context.res = request.res = response.res = res;</span></span><br><span class=\"line\"><span class=\"string\">    request.ctx = response.ctx = context;</span></span><br><span class=\"line\"><span class=\"string\">    request.response = response;</span></span><br><span class=\"line\"><span class=\"string\">    response.request = request;</span></span><br><span class=\"line\"><span class=\"string\">    context.originalUrl = request.originalUrl = req.url;</span></span><br><span class=\"line\"><span class=\"string\">    context.state = &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\">    return context;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * Default error handler.</span></span><br><span class=\"line\"><span class=\"string\">   *</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Error&#125; err</span></span><br><span class=\"line\"><span class=\"string\">   * @api private</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  onerror(err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!(err instanceof Error)) throw new TypeError(util.format('</span>non-error thrown: %j<span class=\"string\">', err));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    if (404 == err.status || err.expose) return;</span></span><br><span class=\"line\"><span class=\"string\">    if (this.silent) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    const msg = err.stack || err.toString();</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">    console.error(msg.replace(/^/gm, '</span>  <span class=\"string\">'));</span></span><br><span class=\"line\"><span class=\"string\">    console.error();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Response helper.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function respond(ctx) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  // allow bypassing koa</span></span><br><span class=\"line\"><span class=\"string\">  if (false === ctx.respond) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  const res = ctx.res;</span></span><br><span class=\"line\"><span class=\"string\">  if (!ctx.writable) return;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  let body = ctx.body;</span></span><br><span class=\"line\"><span class=\"string\">  const code = ctx.status;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // ignore body</span></span><br><span class=\"line\"><span class=\"string\">  if (statuses.empty[code]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // strip headers</span></span><br><span class=\"line\"><span class=\"string\">    ctx.body = null;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>HEAD<span class=\"string\">' == ctx.method) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end();</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // status body</span></span><br><span class=\"line\"><span class=\"string\">  if (null == body) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    body = ctx.message || String(code);</span></span><br><span class=\"line\"><span class=\"string\">    if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      ctx.type = '</span>text<span class=\"string\">';</span></span><br><span class=\"line\"><span class=\"string\">      ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // responses</span></span><br><span class=\"line\"><span class=\"string\">  if (Buffer.isBuffer(body)) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if ('</span>string<span class=\"string\">' == typeof body) return res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (body instanceof Stream) return body.pipe(res);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  // body: json</span></span><br><span class=\"line\"><span class=\"string\">  body = JSON.stringify(body);</span></span><br><span class=\"line\"><span class=\"string\">  if (!res.headersSent) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    ctx.length = Buffer.byteLength(body);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  res.end(body);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。<br><br><br>当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br><br>最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。</p>\n<h3 id=\"compose-js\"><a href=\"#compose-js\" class=\"headerlink\" title=\"compose.js\"></a>compose.js</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use strict<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Expose compositor.</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">module.exports = compose</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/**</span></span><br><span class=\"line\"><span class=\"string\"> * Compose `middleware` returning</span></span><br><span class=\"line\"><span class=\"string\"> * a fully valid middleware comprised</span></span><br><span class=\"line\"><span class=\"string\"> * of all those which are passed.</span></span><br><span class=\"line\"><span class=\"string\"> *</span></span><br><span class=\"line\"><span class=\"string\"> * @param &#123;Array&#125; middleware</span></span><br><span class=\"line\"><span class=\"string\"> * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"string\"> * @api public</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function compose (middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  if (!Array.isArray(middleware)) throw new TypeError('</span>Middleware stack must be an array!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  for (const fn of middleware) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if (typeof fn !== '</span><span class=\"keyword\">function</span><span class=\"string\">') throw new TypeError('</span>Middleware must be composed of <span class=\"built_in\">functions</span>!<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  /**</span></span><br><span class=\"line\"><span class=\"string\">   * @param &#123;Object&#125; context</span></span><br><span class=\"line\"><span class=\"string\">   * @return &#123;Promise&#125;</span></span><br><span class=\"line\"><span class=\"string\">   * @api public</span></span><br><span class=\"line\"><span class=\"string\">   */</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  return function (context, next) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // last called middleware #</span></span><br><span class=\"line\"><span class=\"string\">    let index = -1; //当前中间件的索引</span></span><br><span class=\"line\"><span class=\"string\">    return dispatch(0)</span></span><br><span class=\"line\"><span class=\"string\">    function dispatch (i) &#123;</span></span><br><span class=\"line\"><span class=\"string\">      if (i &lt;= index) return Promise.reject(new Error('</span>next() called multiple <span class=\"built_in\">times</span><span class=\"string\">'))</span></span><br><span class=\"line\"><span class=\"string\">      index = i</span></span><br><span class=\"line\"><span class=\"string\">      let fn = middleware[i]</span></span><br><span class=\"line\"><span class=\"string\">      if (i === middleware.length) fn = next</span></span><br><span class=\"line\"><span class=\"string\">      if (!fn) return Promise.resolve()</span></span><br><span class=\"line\"><span class=\"string\">      try &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span></span><br><span class=\"line\"><span class=\"string\">      &#125; catch (err) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return Promise.reject(err)</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>compose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png\"><br>其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。</p>"},{"title":"sort","date":"2018-07-25T03:33:49.000Z","_content":"先来张图片\n<img  src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\" />\n<!--more-->\n### 冒泡排序\n#### 算法描述\n\n+ <1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n+ <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n+ <3>.针对所有的元素重复以上的步骤，除了最后一个；\n+ <4>.重复步骤1~3，直到排序完成。\n\n#### 代码实现\n设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\n```bash\nfunction bubbleSort(arr) {\n    var i = arr.length-1;  //初始时,最后位置保持不变\n    while ( i> 0) {\n        var pos= 0; //每趟开始时,无记录交换\n        for (var j= 0; j< i; j++)\n            if (arr[j]> arr[j+1]) {\n                pos= j; //记录交换的位置\n                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;\n            }\n        i= pos; //为下一趟排序作准备\n     }\n     console.timeEnd('改进后冒泡排序耗时');\n     return arr;\n}\n```\n\n### 选择排序\n#### 算法描述\n\n+ <1>.初始状态：无序区为R[1..n]，有序区为空；\n+ <2>.第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n+ <3>.n-1趟结束，数组有序化了。\n\n#### 代码实现\n\n```bash\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}\n```\n### 插入排序\n#### 算法描述\n\n+ <1>.从第一个元素开始，该元素可以认为已经被排序；\n+ <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；\n+ <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；\n+ <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n+ <5>.将新元素插入到该位置后；\n+ <6>.重复步骤2~5。\n\n#### 代码描述\n```bash\nfunction insertionSort(array) {\n    for (var i = 1; i < array.length; i++) {\n            var key = array[i];\n            var j = i - 1;\n            while (j >= 0 && array[j] > key) {\n                array[j + 1] = array[j];\n                j--;\n            }\n            array[j + 1] = key;\n        }\n        return array;\n}\n```\n#### 算法分析\n+ 最佳情况：输入数组按升序排列。T(n) = O(n)\n+ 最坏情况：输入数组按降序排列。T(n) = O(n2)\n+ 平均情况：T(n) = O(n2)\n\n### 希尔排序\n#### 算法描述\n\n+ <1>. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n+ <2>.按增量序列个数k，对序列进行k 趟排序；\n+ <3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 代码实现\n```bash\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    console.time('希尔排序耗时:');\n    while(gap < len/5) {          //动态定义间隔序列\n        gap =gap*5+1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap/5)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    console.timeEnd('希尔排序耗时:');\n    return arr;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlog2 n)\n+ 最坏情况：T(n) = O(nlog2 n)\n+ 平均情况：T(n) =O(nlog n)\n\n### 归并排序\n#### 算法描述\n\n+ <1>把长度为n的输入序列分成两个长度为n/2的子序列；\n+ <2>对这两个子序列分别采用归并排序；\n+ <3>将两个排序好的子序列合并成一个最终的排序序列。\n\n#### 代码实现\n```bash\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    console.time('归并排序耗时');\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    console.timeEnd('归并排序耗时');\n    return result;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(n)\n+ 最坏情况：T(n) = O(nlog n)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 快速排序\n#### 算法描述\n\n+ <1>从数列中挑出一个元素，称为 \"基准\"（pivot）；\n+ <2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n+ <3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n#### 代码实现\n```bash\nvar arr = [12,3,23,5,17,9,15,46];\n\nfunction quickSort(arr,left, right){\n  var i,j,t,temp;\n  if(left>right){\n    return;\n  }\n  i = left;\n  j = right;\n  temp = arr[left];\n\n  while(i!==j){\n    while(temp<=arr[j]&&i<j){\n      j--;\n    }\n    while(temp>=arr[i]&&i<j){\n      i++\n    }\n    if(i<j){\n      [arr[j], arr[i]] = [arr[i], arr[j]];\n    }\n  }\n  arr[left] = arr[i];\n  arr[i] = temp;\n  quickSort(arr,left,i-1);\n  quickSort(arr,i+1,right);\n}\nquickSort(arr,0, arr.length-1);\nconsole.log(arr);\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(n2)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 堆排序\n#### 算法描述\n\n+ <1>将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；\n+ <2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]；\n+ <3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n#### 代码实现\n```bash\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(nlogn)\n+ 平均情况：T(n) =O(nlogn)\n","source":"_posts/sort.md","raw":"---\ntitle: sort\ndate: 2018-07-25 11:33:49\ntags: 算法\ncategories: 学习\n---\n先来张图片\n<img  src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\" />\n<!--more-->\n### 冒泡排序\n#### 算法描述\n\n+ <1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n+ <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n+ <3>.针对所有的元素重复以上的步骤，除了最后一个；\n+ <4>.重复步骤1~3，直到排序完成。\n\n#### 代码实现\n设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\n```bash\nfunction bubbleSort(arr) {\n    var i = arr.length-1;  //初始时,最后位置保持不变\n    while ( i> 0) {\n        var pos= 0; //每趟开始时,无记录交换\n        for (var j= 0; j< i; j++)\n            if (arr[j]> arr[j+1]) {\n                pos= j; //记录交换的位置\n                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;\n            }\n        i= pos; //为下一趟排序作准备\n     }\n     console.timeEnd('改进后冒泡排序耗时');\n     return arr;\n}\n```\n\n### 选择排序\n#### 算法描述\n\n+ <1>.初始状态：无序区为R[1..n]，有序区为空；\n+ <2>.第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n+ <3>.n-1趟结束，数组有序化了。\n\n#### 代码实现\n\n```bash\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}\n```\n### 插入排序\n#### 算法描述\n\n+ <1>.从第一个元素开始，该元素可以认为已经被排序；\n+ <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；\n+ <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；\n+ <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n+ <5>.将新元素插入到该位置后；\n+ <6>.重复步骤2~5。\n\n#### 代码描述\n```bash\nfunction insertionSort(array) {\n    for (var i = 1; i < array.length; i++) {\n            var key = array[i];\n            var j = i - 1;\n            while (j >= 0 && array[j] > key) {\n                array[j + 1] = array[j];\n                j--;\n            }\n            array[j + 1] = key;\n        }\n        return array;\n}\n```\n#### 算法分析\n+ 最佳情况：输入数组按升序排列。T(n) = O(n)\n+ 最坏情况：输入数组按降序排列。T(n) = O(n2)\n+ 平均情况：T(n) = O(n2)\n\n### 希尔排序\n#### 算法描述\n\n+ <1>. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n+ <2>.按增量序列个数k，对序列进行k 趟排序；\n+ <3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 代码实现\n```bash\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    console.time('希尔排序耗时:');\n    while(gap < len/5) {          //动态定义间隔序列\n        gap =gap*5+1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap/5)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    console.timeEnd('希尔排序耗时:');\n    return arr;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlog2 n)\n+ 最坏情况：T(n) = O(nlog2 n)\n+ 平均情况：T(n) =O(nlog n)\n\n### 归并排序\n#### 算法描述\n\n+ <1>把长度为n的输入序列分成两个长度为n/2的子序列；\n+ <2>对这两个子序列分别采用归并排序；\n+ <3>将两个排序好的子序列合并成一个最终的排序序列。\n\n#### 代码实现\n```bash\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    console.time('归并排序耗时');\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    console.timeEnd('归并排序耗时');\n    return result;\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(n)\n+ 最坏情况：T(n) = O(nlog n)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 快速排序\n#### 算法描述\n\n+ <1>从数列中挑出一个元素，称为 \"基准\"（pivot）；\n+ <2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n+ <3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n#### 代码实现\n```bash\nvar arr = [12,3,23,5,17,9,15,46];\n\nfunction quickSort(arr,left, right){\n  var i,j,t,temp;\n  if(left>right){\n    return;\n  }\n  i = left;\n  j = right;\n  temp = arr[left];\n\n  while(i!==j){\n    while(temp<=arr[j]&&i<j){\n      j--;\n    }\n    while(temp>=arr[i]&&i<j){\n      i++\n    }\n    if(i<j){\n      [arr[j], arr[i]] = [arr[i], arr[j]];\n    }\n  }\n  arr[left] = arr[i];\n  arr[i] = temp;\n  quickSort(arr,left,i-1);\n  quickSort(arr,i+1,right);\n}\nquickSort(arr,0, arr.length-1);\nconsole.log(arr);\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(n2)\n+ 平均情况：T(n) =O(nlog n)\n\n\n### 堆排序\n#### 算法描述\n\n+ <1>将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；\n+ <2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]；\n+ <3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n#### 代码实现\n```bash\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n```\n#### 算法分析\n+ 最佳情况：T(n) = O(nlogn)\n+ 最坏情况：T(n) = O(nlogn)\n+ 平均情况：T(n) =O(nlogn)\n","slug":"sort","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydsksti002khvs6zu5bpktv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>先来张图片<br><img src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\"><br><a id=\"more\"></a></p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>\n<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>\n<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>\n<li><4>.重复步骤1~3，直到排序完成。</4></li>\n</ul>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> bubbleSort(arr) &#123;</span><br><span class=\"line\">    var i = arr.length-1;  //初始时,最后位置保持不变</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( i&gt; 0) &#123;</span><br><span class=\"line\">        var pos= 0; //每趟开始时,无记录交换</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j= 0; j&lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+1]) &#123;</span><br><span class=\"line\">                pos= j; //记录交换的位置</span><br><span class=\"line\">                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        i= pos; //为下一趟排序作准备</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     console.timeEnd(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">     <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><h4 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>\n<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>\n<li><3>.n-1趟结束，数组有序化了。</3></li>\n</ul>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> selectionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var minIndex, temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class=\"line\">                minIndex = j;                 //将最小数的索引保存</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><h4 id=\"算法描述-2\"><a href=\"#算法描述-2\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>\n<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>\n<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>\n<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>\n<li><5>.将新元素插入到该位置后；</5></li>\n<li><6>.重复步骤2~5。</6></li>\n</ul>\n<h4 id=\"代码描述\"><a href=\"#代码描述\" class=\"headerlink\" title=\"代码描述\"></a>代码描述</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> insertionSort(array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            var key = array[i];</span><br><span class=\"line\">            var j = i - 1;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">                array[j + 1] = array[j];</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[j + 1] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>\n<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h4 id=\"算法描述-3\"><a href=\"#算法描述-3\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>\n<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>\n<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>\n</ul>\n<h4 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> shellSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length,</span><br><span class=\"line\">        temp,</span><br><span class=\"line\">        gap = 1;</span><br><span class=\"line\">    console.time(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(gap &lt; len/5) &#123;          //动态定义间隔序列</span><br><span class=\"line\">        gap =gap*5+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class=\"line\">                arr[j+gap] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j+gap] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlog2 n)</li>\n<li>最坏情况：T(n) = O(nlog2 n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><h4 id=\"算法描述-4\"><a href=\"#算法描述-4\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>\n<li><2>对这两个子序列分别采用归并排序；</2></li>\n<li><3>将两个排序好的子序列合并成一个最终的排序序列。</3></li>\n</ul>\n<h4 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len &lt; 2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var middle = Math.floor(len / 2),</span><br><span class=\"line\">        left = arr.slice(0, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> merge(left, right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\">    console.time(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最坏情况：T(n) = O(nlog n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h4 id=\"算法描述-5\"><a href=\"#算法描述-5\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>\n<li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>\n<li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>\n</ul>\n<h4 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [12,3,23,5,17,9,15,46];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> quickSort(arr,left, right)&#123;</span><br><span class=\"line\">  var i,j,t,temp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(left&gt;right)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  i = left;</span><br><span class=\"line\">  j = right;</span><br><span class=\"line\">  temp = arr[left];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i!==j)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;j)&#123;</span><br><span class=\"line\">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr[left] = arr[i];</span><br><span class=\"line\">  arr[i] = temp;</span><br><span class=\"line\">  quickSort(arr,left,i-1);</span><br><span class=\"line\">  quickSort(arr,i+1,right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">quickSort(arr,0, arr.length-1);</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(n2)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><h4 id=\"算法描述-6\"><a href=\"#算法描述-6\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>\n<li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>\n<li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h4 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*方法说明：维护堆的性质</span><br><span class=\"line\">@param  arr 数组</span><br><span class=\"line\">@param  x   数组下标</span><br><span class=\"line\">@param  len 堆大小*/</span><br><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</3></li>\n</ul>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(nlogn)</li>\n<li>平均情况：T(n) =O(nlogn)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>先来张图片<br><img src=\"http://pdqpny9og.bkt.clouddn.com/paixu.png\"><br>","more":"</p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>\n<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>\n<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>\n<li><4>.重复步骤1~3，直到排序完成。</4></li>\n</ul>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> bubbleSort(arr) &#123;</span><br><span class=\"line\">    var i = arr.length-1;  //初始时,最后位置保持不变</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( i&gt; 0) &#123;</span><br><span class=\"line\">        var pos= 0; //每趟开始时,无记录交换</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j= 0; j&lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j]&gt; arr[j+1]) &#123;</span><br><span class=\"line\">                pos= j; //记录交换的位置</span><br><span class=\"line\">                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        i= pos; //为下一趟排序作准备</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     console.timeEnd(<span class=\"string\">'改进后冒泡排序耗时'</span>);</span><br><span class=\"line\">     <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><h4 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>\n<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>\n<li><3>.n-1趟结束，数组有序化了。</3></li>\n</ul>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> selectionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var minIndex, temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class=\"line\">                minIndex = j;                 //将最小数的索引保存</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><h4 id=\"算法描述-2\"><a href=\"#算法描述-2\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>\n<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>\n<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>\n<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>\n<li><5>.将新元素插入到该位置后；</5></li>\n<li><6>.重复步骤2~5。</6></li>\n</ul>\n<h4 id=\"代码描述\"><a href=\"#代码描述\" class=\"headerlink\" title=\"代码描述\"></a>代码描述</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> insertionSort(array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            var key = array[i];</span><br><span class=\"line\">            var j = i - 1;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">                array[j + 1] = array[j];</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[j + 1] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>\n<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h4 id=\"算法描述-3\"><a href=\"#算法描述-3\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>\n<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>\n<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>\n</ul>\n<h4 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> shellSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length,</span><br><span class=\"line\">        temp,</span><br><span class=\"line\">        gap = 1;</span><br><span class=\"line\">    console.time(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(gap &lt; len/5) &#123;          //动态定义间隔序列</span><br><span class=\"line\">        gap =gap*5+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class=\"line\">                arr[j+gap] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j+gap] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'希尔排序耗时:'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlog2 n)</li>\n<li>最坏情况：T(n) = O(nlog2 n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><h4 id=\"算法描述-4\"><a href=\"#算法描述-4\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>\n<li><2>对这两个子序列分别采用归并排序；</2></li>\n<li><3>将两个排序好的子序列合并成一个最终的排序序列。</3></li>\n</ul>\n<h4 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len &lt; 2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var middle = Math.floor(len / 2),</span><br><span class=\"line\">        left = arr.slice(0, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> merge(left, right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\">    console.time(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\">    console.timeEnd(<span class=\"string\">'归并排序耗时'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最坏情况：T(n) = O(nlog n)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h4 id=\"算法描述-5\"><a href=\"#算法描述-5\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>\n<li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>\n<li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>\n</ul>\n<h4 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [12,3,23,5,17,9,15,46];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> quickSort(arr,left, right)&#123;</span><br><span class=\"line\">  var i,j,t,temp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(left&gt;right)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  i = left;</span><br><span class=\"line\">  j = right;</span><br><span class=\"line\">  temp = arr[left];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i!==j)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;j)&#123;</span><br><span class=\"line\">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr[left] = arr[i];</span><br><span class=\"line\">  arr[i] = temp;</span><br><span class=\"line\">  quickSort(arr,left,i-1);</span><br><span class=\"line\">  quickSort(arr,i+1,right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">quickSort(arr,0, arr.length-1);</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(n2)</li>\n<li>平均情况：T(n) =O(nlog n)</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><h4 id=\"算法描述-6\"><a href=\"#算法描述-6\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>\n<li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>\n<li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h4 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*方法说明：维护堆的性质</span><br><span class=\"line\">@param  arr 数组</span><br><span class=\"line\">@param  x   数组下标</span><br><span class=\"line\">@param  len 堆大小*/</span><br><span class=\"line\"><span class=\"keyword\">function</span> heapify(arr, x, len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class=\"string\">'Array'</span> &amp;&amp; typeof x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</3></li>\n</ul>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最坏情况：T(n) = O(nlogn)</li>\n<li>平均情况：T(n) =O(nlogn)</li>\n</ul>"},{"title":"vue的diff","date":"2019-01-17T09:41:09.000Z","_content":"\n> 昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。\n\n<!-- more -->\n## 关键源码\n\n### updateChildren\n\nvue关于diff模块源码地址：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\n\n其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。\n\n规则很简单，循环体内：\n\n+ 首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）\n+  oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。\n+  oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd--，oldEnd--，否则进入下一步。\n+  oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd--，oldStart++，否则进入下一步。\n+  oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd--，newStart++，否则进入下一步。\n\n+ 如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。\n\n```bash\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh)\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n       /*\n          生成一个key与旧VNode的key对应的哈希表，形如{oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:\n          3}，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引\n        */\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            oldCh[idxInOld] = undefined\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n\n------------\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  let i, key\n  const map = {}\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  }\n  return map\n}\n```\n\n### patchVnode\n\n代码在这：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js   第501行。\n其实这个函数就是在两个节点值得diff的情况下，去更新差异。\n规则如下：\n\n1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。\n\n2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。\n\n3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。\n\n4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。\n\n5.当新老节点都无子节点的时候，只是文本的替换。\n\n### sameVnode\n\n代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。\n\n```bash\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n```\n\n\n\n## 开始BB\n\n首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：\n\n+ 两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。\n\n+ 一个map，是一个用来建立oldVnode的key和索引的映射关系，形如\n\n``` bash\n{\n    oldKey0: 0,\n    oldKey1: 1,\n    oldKey2: 2,\n    oldKey3: 3,\n}\n```\n\n### 举个🌰\n\n原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。\n\n![1](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg)\n\n#### 第1步\n\n在满足oldStart<= oldEnd && newStart <= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg)\n\n#### 第2步\n\n接着发现newB和oldB也是值得比较的就重复上述的步骤\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg)\n\n#### 第3步\n\n\nC和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg)\n\n#### 第4步\n\n这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg)\n\n#### 第5步\n\n这个时候oldEnd>oldStart不满足oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx，这个时候\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg)\n\noldStart > oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来\n\nnewStart > newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：\n\n> 1. js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。\n> 2. JS 代码调用 DOM API 必须经过 *挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎*，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。\n> 3. 若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。\n> 4. 若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，**重新计算布局**、**重新绘制图像**会引起更大的性能消耗。\n\n所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰\n\n### 再举个🌰\n\n#### 第1步\n原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。\n\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg)\n#### 第2步\n目前真实的dom和oldNodeList是一样，以后***移动节点是在真实的dom上移动的***。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，\n根据文章一开始介绍的规则，将oldStart移动到***oldEnd***所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针\n\nmove的代码如下\n\n```bash\n\ncanMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n\n\n\n```\nnodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在[这个位置](https://github.com/vuejs/vue/tree/2.6/src/platforms) 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。\n\n如图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg)\n#### 第3步\n\nok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg)\n\n#### 第4步\n\n最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg)\n\n\n### 再再举个例子\n#### 第1步\n\n原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg)\n\n#### 第2步\n\n于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后***将newStart对应的真实dom移动到oldStart的前面***，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg)\n#### 第3步\n至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，***将oldEnd对应的真实dom移动到oldStart的前面***，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg)\n\n#### 第4步\n接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。\n","source":"_posts/vue的diff.md","raw":"---\ntitle: vue的diff\ndate: 2019-01-17 17:41:09\ntags: vue\n---\n\n> 昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。\n\n<!-- more -->\n## 关键源码\n\n### updateChildren\n\nvue关于diff模块源码地址：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\n\n其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。\n\n规则很简单，循环体内：\n\n+ 首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）\n+  oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。\n+  oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd--，oldEnd--，否则进入下一步。\n+  oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd--，oldStart++，否则进入下一步。\n+  oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd--，newStart++，否则进入下一步。\n\n+ 如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。\n\n```bash\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh)\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n       /*\n          生成一个key与旧VNode的key对应的哈希表，形如{oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:\n          3}，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引\n        */\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            oldCh[idxInOld] = undefined\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n\n------------\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  let i, key\n  const map = {}\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  }\n  return map\n}\n```\n\n### patchVnode\n\n代码在这：https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js   第501行。\n其实这个函数就是在两个节点值得diff的情况下，去更新差异。\n规则如下：\n\n1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。\n\n2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。\n\n3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。\n\n4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。\n\n5.当新老节点都无子节点的时候，只是文本的替换。\n\n### sameVnode\n\n代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。\n\n```bash\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n```\n\n\n\n## 开始BB\n\n首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：\n\n+ 两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。\n\n+ 一个map，是一个用来建立oldVnode的key和索引的映射关系，形如\n\n``` bash\n{\n    oldKey0: 0,\n    oldKey1: 1,\n    oldKey2: 2,\n    oldKey3: 3,\n}\n```\n\n### 举个🌰\n\n原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。\n\n![1](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg)\n\n#### 第1步\n\n在满足oldStart<= oldEnd && newStart <= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg)\n\n#### 第2步\n\n接着发现newB和oldB也是值得比较的就重复上述的步骤\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg)\n\n#### 第3步\n\n\nC和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg)\n\n#### 第4步\n\n这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇\n\n![2](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg)\n\n#### 第5步\n\n这个时候oldEnd>oldStart不满足oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx，这个时候\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg)\n\noldStart > oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来\n\nnewStart > newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：\n\n> 1. js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。\n> 2. JS 代码调用 DOM API 必须经过 *挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎*，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。\n> 3. 若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。\n> 4. 若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，**重新计算布局**、**重新绘制图像**会引起更大的性能消耗。\n\n所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰\n\n### 再举个🌰\n\n#### 第1步\n原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。\n\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg)\n#### 第2步\n目前真实的dom和oldNodeList是一样，以后***移动节点是在真实的dom上移动的***。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，\n根据文章一开始介绍的规则，将oldStart移动到***oldEnd***所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针\n\nmove的代码如下\n\n```bash\n\ncanMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n\n\n\n```\nnodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在[这个位置](https://github.com/vuejs/vue/tree/2.6/src/platforms) 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。\n\n如图\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg)\n#### 第3步\n\nok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg)\n\n#### 第4步\n\n最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg)\n\n\n### 再再举个例子\n#### 第1步\n\n原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg)\n\n#### 第2步\n\n于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后***将newStart对应的真实dom移动到oldStart的前面***，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示\n\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg)\n#### 第3步\n至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，***将oldEnd对应的真实dom移动到oldStart的前面***，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。\n![](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg)\n\n#### 第4步\n接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。\n","slug":"vue的diff","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydskstj002nhvs6zfser86l","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"关键源码\"><a href=\"#关键源码\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h2><h3 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren\"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p>\n<p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p>\n<p>规则很简单，循环体内：</p>\n<ul>\n<li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li>\n<li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li>\n<li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li>\n<li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li>\n<li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p>\n</li>\n<li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndIdx = oldCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartVnode = oldCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndIdx = newCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartVnode = newCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class=\"line\">    // to ensure removed elements stay <span class=\"keyword\">in</span> correct relative positions</span><br><span class=\"line\">    // during leaving transitions</span><br><span class=\"line\">    const canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      checkDuplicateKeys(newCh)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class=\"line\">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class=\"line\">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       /*</span><br><span class=\"line\">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class=\"line\">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class=\"line\">        */</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">            oldCh[idxInOld] = undefined</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // same key but different element. treat as new element</span><br><span class=\"line\">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class=\"line\">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\"><span class=\"keyword\">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> i, key</span><br><span class=\"line\">  const map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class=\"line\">    key = children[i].key</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(key)) map[key] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"patchVnode\"><a href=\"#patchVnode\" class=\"headerlink\" title=\"patchVnode\"></a>patchVnode</h3><p>代码在这：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p>\n<p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p>\n<p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p>\n<p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p>\n<p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p>\n<p>5.当新老节点都无子节点的时候，只是文本的替换。</p>\n<h3 id=\"sameVnode\"><a href=\"#sameVnode\" class=\"headerlink\" title=\"sameVnode\"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> sameVnode (a, b) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (</span><br><span class=\"line\">    a.key === b.key &amp;&amp; (</span><br><span class=\"line\">      (</span><br><span class=\"line\">        a.tag === b.tag &amp;&amp;</span><br><span class=\"line\">        a.isComment === b.isComment &amp;&amp;</span><br><span class=\"line\">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class=\"line\">        sameInputType(a, b)</span><br><span class=\"line\">      ) || (</span><br><span class=\"line\">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class=\"line\">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class=\"line\">        isUndef(b.asyncFactory.error)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开始BB\"><a href=\"#开始BB\" class=\"headerlink\" title=\"开始BB\"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p>\n<ul>\n<li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p>\n</li>\n<li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    oldKey0: 0,</span><br><span class=\"line\">    oldKey1: 1,</span><br><span class=\"line\">    oldKey2: 2,</span><br><span class=\"line\">    oldKey3: 3,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"举个🌰\"><a href=\"#举个🌰\" class=\"headerlink\" title=\"举个🌰\"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg\" alt=\"1\"></p>\n<h4 id=\"第1步\"><a href=\"#第1步\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h4 id=\"第2步\"><a href=\"#第2步\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg\" alt=\"2\"></p>\n<h4 id=\"第3步\"><a href=\"#第3步\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg\" alt=\"2\"></p>\n<h4 id=\"第4步\"><a href=\"#第4步\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg\" alt=\"2\"></p>\n<h4 id=\"第5步\"><a href=\"#第5步\" class=\"headerlink\" title=\"第5步\"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg\" alt=\"\"></p>\n<p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p>\n<p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p>\n<blockquote>\n<ol>\n<li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li>\n<li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li>\n<li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li>\n<li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li>\n</ol>\n</blockquote>\n<p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p>\n<h3 id=\"再举个🌰\"><a href=\"#再举个🌰\" class=\"headerlink\" title=\"再举个🌰\"></a>再举个🌰</h3><h4 id=\"第1步-1\"><a href=\"#第1步-1\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg\" alt=\"\"></p>\n<h4 id=\"第2步-1\"><a href=\"#第2步-1\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p>\n<p>move的代码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure>\n<p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href=\"https://github.com/vuejs/vue/tree/2.6/src/platforms\" target=\"_blank\" rel=\"noopener\">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p>\n<p>如图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg\" alt=\"\"></p>\n<h4 id=\"第3步-1\"><a href=\"#第3步-1\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg\" alt=\"\"></p>\n<h4 id=\"第4步-1\"><a href=\"#第4步-1\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg\" alt=\"\"></p>\n<h3 id=\"再再举个例子\"><a href=\"#再再举个例子\" class=\"headerlink\" title=\"再再举个例子\"></a>再再举个例子</h3><h4 id=\"第1步-2\"><a href=\"#第1步-2\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg\" alt=\"\"></p>\n<h4 id=\"第2步-2\"><a href=\"#第2步-2\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg\" alt=\"\"></p>\n<h4 id=\"第3步-2\"><a href=\"#第3步-2\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg\" alt=\"\"></p>\n<h4 id=\"第4步-2\"><a href=\"#第4步-2\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p>\n</blockquote>","more":"<h2 id=\"关键源码\"><a href=\"#关键源码\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h2><h3 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren\"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p>\n<p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p>\n<p>规则很简单，循环体内：</p>\n<ul>\n<li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li>\n<li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li>\n<li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li>\n<li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li>\n<li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p>\n</li>\n<li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartIdx = 0</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndIdx = oldCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldStartVnode = oldCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndIdx = newCh.length - 1</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newStartVnode = newCh[0]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class=\"line\">    <span class=\"built_in\">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class=\"line\">    // to ensure removed elements stay <span class=\"keyword\">in</span> correct relative positions</span><br><span class=\"line\">    // during leaving transitions</span><br><span class=\"line\">    const canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      checkDuplicateKeys(newCh)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class=\"line\">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class=\"line\">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       /*</span><br><span class=\"line\">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class=\"line\">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class=\"line\">        */</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class=\"line\">            oldCh[idxInOld] = undefined</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // same key but different element. treat as new element</span><br><span class=\"line\">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class=\"line\">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\"><span class=\"keyword\">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> i, key</span><br><span class=\"line\">  const map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class=\"line\">    key = children[i].key</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(key)) map[key] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"patchVnode\"><a href=\"#patchVnode\" class=\"headerlink\" title=\"patchVnode\"></a>patchVnode</h3><p>代码在这：<a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p>\n<p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p>\n<p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p>\n<p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p>\n<p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p>\n<p>5.当新老节点都无子节点的时候，只是文本的替换。</p>\n<h3 id=\"sameVnode\"><a href=\"#sameVnode\" class=\"headerlink\" title=\"sameVnode\"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> sameVnode (a, b) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> (</span><br><span class=\"line\">    a.key === b.key &amp;&amp; (</span><br><span class=\"line\">      (</span><br><span class=\"line\">        a.tag === b.tag &amp;&amp;</span><br><span class=\"line\">        a.isComment === b.isComment &amp;&amp;</span><br><span class=\"line\">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class=\"line\">        sameInputType(a, b)</span><br><span class=\"line\">      ) || (</span><br><span class=\"line\">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class=\"line\">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class=\"line\">        isUndef(b.asyncFactory.error)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开始BB\"><a href=\"#开始BB\" class=\"headerlink\" title=\"开始BB\"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p>\n<ul>\n<li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p>\n</li>\n<li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    oldKey0: 0,</span><br><span class=\"line\">    oldKey1: 1,</span><br><span class=\"line\">    oldKey2: 2,</span><br><span class=\"line\">    oldKey3: 3,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"举个🌰\"><a href=\"#举个🌰\" class=\"headerlink\" title=\"举个🌰\"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg\" alt=\"1\"></p>\n<h4 id=\"第1步\"><a href=\"#第1步\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h4 id=\"第2步\"><a href=\"#第2步\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg\" alt=\"2\"></p>\n<h4 id=\"第3步\"><a href=\"#第3步\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg\" alt=\"2\"></p>\n<h4 id=\"第4步\"><a href=\"#第4步\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg\" alt=\"2\"></p>\n<h4 id=\"第5步\"><a href=\"#第5步\" class=\"headerlink\" title=\"第5步\"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg\" alt=\"\"></p>\n<p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p>\n<p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p>\n<blockquote>\n<ol>\n<li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li>\n<li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li>\n<li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li>\n<li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li>\n</ol>\n</blockquote>\n<p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p>\n<h3 id=\"再举个🌰\"><a href=\"#再举个🌰\" class=\"headerlink\" title=\"再举个🌰\"></a>再举个🌰</h3><h4 id=\"第1步-1\"><a href=\"#第1步-1\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg\" alt=\"\"></p>\n<h4 id=\"第2步-1\"><a href=\"#第2步-1\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p>\n<p>move的代码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure>\n<p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href=\"https://github.com/vuejs/vue/tree/2.6/src/platforms\" target=\"_blank\" rel=\"noopener\">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p>\n<p>如图<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg\" alt=\"\"></p>\n<h4 id=\"第3步-1\"><a href=\"#第3步-1\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg\" alt=\"\"></p>\n<h4 id=\"第4步-1\"><a href=\"#第4步-1\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg\" alt=\"\"></p>\n<h3 id=\"再再举个例子\"><a href=\"#再再举个例子\" class=\"headerlink\" title=\"再再举个例子\"></a>再再举个例子</h3><h4 id=\"第1步-2\"><a href=\"#第1步-2\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg\" alt=\"\"></p>\n<h4 id=\"第2步-2\"><a href=\"#第2步-2\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg\" alt=\"\"></p>\n<h4 id=\"第3步-2\"><a href=\"#第3步-2\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg\" alt=\"\"></p>\n<h4 id=\"第4步-2\"><a href=\"#第4步-2\" class=\"headerlink\" title=\"第4步\"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>"},{"title":"http学习总结","date":"2018-04-19T05:30:30.000Z","_content":"\n> 做一下http总结吧！！！\n\n<!-- more -->\n\n # HTTP简介\n\nHTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本----HTTP 1.1。\n\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\n\nHTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：\n\n- 对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。\n- 在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。\n- Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。\n- 管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。\n\n<br>\n<br><br>\n\n一次http链接的生命周期，基本包括请求和响应。\n\n# 请求\n\n一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。\n\n## 请求行\n\n请求行分为三个部分：请求方法、请求地址和协议版本.\n\n### 请求方法\n\n方法      | 描述\n------- | ---------------------------------------------------\nGET     | 从服务端获取资源\nPOST    | 用来传输实体的主题\nHEAD    | 获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等\nOPTIONS | 询问支持的方法\nPUT     | 传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）\nDELETE  | 按请求URI删除指定文件\nTRACE   | 追踪路径，易引发XST（跨站攻击），不常用\n\n### 请求地址\n\nURL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。\n\n说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。\n\n### 协议版本\n\n常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：\n\n- 多路复用<br>\n  2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。\n- 头部压缩<br>\n  当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。\n- 随时复位<br>\n  HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。\n- 服务器端推流: Server Push<br>\n  客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。\n- 优先权和依赖<br>\n  每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。\n\n## 请求头部\n\n请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段\n\n### 通用请求首部\n\n首部                | 描述\n----------------- | ---------------------------------------------------------------------------\nConnection        | 允许客户端和服务器指定与请求/响应连接有关的选项\nDate              | 提供日期和时间标志，说明报文是什么时间创建的\nMIME-Version      | 给出了发送短使用的 MINE 版本\nTrailer           | 如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合\nTransfer-Encoding | 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式\nUpdate            | 给出了发送端可能想要\"升级\"使用的新版本或协议\nVia               | 显示报文经过的中间节点（代理、网关）\n\n### 请求首部字段\n\n首部字段名               | 说明\n------------------- | --------------------------------\nAccept              | 用户代理可处理的媒体类型\nAccept-Charset      | 优先的字符集\nAccept-Encoding     | 优先的内容编码\nAccept-Language     | 有限的语言\nAuthorization       | Web认证信息\nExpect              | 期待副武器的特定行为\nfrom                | 用户的电子邮件地址\nHost                | 请求资源所在服务器\nIf-Match            | 比较实体标记ETag\nIf-Modified-Sincce  | 比较资源的更新时间\nIf-None-Match       | 比较实体标记与If-Match相反\nIf-Range            | 资源委更新时发送实体Byte的范围请求\nIf-Unmodified-Since | 比较资源的更新时间 与 If-Modified-Sincce相反\nMax-Forwards        | 最大传输逐跳数\nProxy-Authorization | 代理服务器要求客户端的认证消息\nRange               | 实体的字节范围请求\nReferer             | 队请求中URI的原始获取方法\nTE                  | 传输编码的优先级\nUser-Agent          | HTTP客户端程序的信息\n\n> 从今以后请称呼在下位为前端打字员，谢谢\n\n### 实体首部\n\n首部               | 描述\n---------------- | -----------------------------------------\nAllow            | 列出可以对此事提执行的请求方法\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式\nContent-Language | 理解主体时最适宜使用的自然语言\nContent-Length   | 主体的长度或尺寸\nContent-Locaton  | 资源实际所处的位置\nContent-MD5      | 主体的 MD5 校验和\nContent-Range    | 在整个资源中此实体表示的字节范围\nContent-Type     | 在这个主体的对象类型\nETag             | 与此实体相关的实体标记\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间\nLast-Modified    | 这个实体最后一次被修改的日期和时间\n\n## 空行\n\n即使第四部分的请求数据为空，也必须有空行。\n\n## 请求数据\n\n请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n# 响应\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n## 状态行\n\n状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n\n说一下状态码（复制粘贴的）\n\n状态码 | 含义\n--- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n100 | 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。\n101 | 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。\n102 | 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n200 | 请求已成功，请求所希望的响应头或数据体将随此响应返回。\n201 | 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。\n202 | 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。\n203 | 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。\n204 | 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n205 | 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。\n206 | 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。\n207 | 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\n300 | 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。\n301 | 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。\n302 | 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。\n303 | 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。\n304 | 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。\n305 | 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。\n306 | 在最新版的规范中，306状态码已经不再被使用。\n307 | 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n400 | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。\n401 | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。\n402 | 该状态码是为了将来可能的需求而预留的。\n403 | 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。\n404 | 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。\n405 | 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。\n406 | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。\n407 | 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。\n408 | 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。\n409 | 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。\n410 | 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。\n411 | 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。\n412 | 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。\n413 | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。\n414 | 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI \"黑洞\"，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。\n415 | 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。\n416 | 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。\n417 | 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。\n421 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）\n424 | 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）\n425 | 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。\n426 | 客户端应当切换到TLS/1.0。（RFC 2817）\n449 | 由微软扩展，代表请求应当在执行完适当的操作后进行重试。\n500 | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。\n501 | 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n502 | 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n503 | 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。\n504 | 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误\n505 | 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。\n506 | 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。\n507 | 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)\n509 | 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。\n510 | 获取资源所需要的策略并没有没满足。（RFC 2774）\n\n## 响应报头\n\n### 响应首部\n\n首部                 | 描述\n------------------ | ---------------------------------------------------------------------\nAge                | （从最初创建开始)响应持续时间。\nPublic             | 服务器为其资源支持的请求方法列表。\nRetry-After        | 如果资源不可用的话，在此日期或时间重试。\nServer             | 服务器应用程序软件的名称和版本。\nTitle              | 对 HTML 文档来说，就是 HTML 文档的源端给出的标题。\nWarning            | 比原因短语更详细一些的警告报文。\nAccept-Ranges      | 对此资源来说，服务器可接受的范围类型。\nVary               | 服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。\nProxy-Authenticate | 来自代理的对客户端的质询列表。\nSet-Cookie         | 不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。\nSet-Cookie2        | 与 Set-Cookie 类似，PFC 2965 Cookie定义。\nWWW-Authenticate   | 来自服务器对客户端的质询列表。\n\n\n\n# 实体首部\n\n首部               | 描述\n---------------- | ------------------------------------------\nAllow            | 列出可以对此事提执行的请求方法。\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式。\nContent-Language | 理解主体时最适宜使用的自然语言。\nContent-Length   | 主体的长度或尺寸。\nContent-Locaton  | 资源实际所处的位置。\nContent-MD5      | 主体的 MD5 校验和。\nContent-Range    | 在整个资源中此实体表示的字节范围。\nContent-Type     | 在这个主体的对象类型。\nETag             | 与此实体相关的实体标记。\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间。\nLast-Modified    | 这个实体最后一次被修改的日期和时间。\n\n[参考链接](http://tool.oschina.net/commons?type=5)\n","source":"_posts/http.md","raw":"---\ntitle: http学习总结\ndate: 2018-04-19T13:30:30.000Z\ntags: http\ncategories: 学习\n---\n\n> 做一下http总结吧！！！\n\n<!-- more -->\n\n # HTTP简介\n\nHTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本----HTTP 1.1。\n\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\n\nHTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：\n\n- 对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。\n- 在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。\n- Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。\n- 管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。\n\n<br>\n<br><br>\n\n一次http链接的生命周期，基本包括请求和响应。\n\n# 请求\n\n一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。\n\n## 请求行\n\n请求行分为三个部分：请求方法、请求地址和协议版本.\n\n### 请求方法\n\n方法      | 描述\n------- | ---------------------------------------------------\nGET     | 从服务端获取资源\nPOST    | 用来传输实体的主题\nHEAD    | 获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等\nOPTIONS | 询问支持的方法\nPUT     | 传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）\nDELETE  | 按请求URI删除指定文件\nTRACE   | 追踪路径，易引发XST（跨站攻击），不常用\n\n### 请求地址\n\nURL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。\n\n说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。\n\n### 协议版本\n\n常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：\n\n- 多路复用<br>\n  2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。\n- 头部压缩<br>\n  当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。\n- 随时复位<br>\n  HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。\n- 服务器端推流: Server Push<br>\n  客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。\n- 优先权和依赖<br>\n  每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。\n\n## 请求头部\n\n请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段\n\n### 通用请求首部\n\n首部                | 描述\n----------------- | ---------------------------------------------------------------------------\nConnection        | 允许客户端和服务器指定与请求/响应连接有关的选项\nDate              | 提供日期和时间标志，说明报文是什么时间创建的\nMIME-Version      | 给出了发送短使用的 MINE 版本\nTrailer           | 如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合\nTransfer-Encoding | 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式\nUpdate            | 给出了发送端可能想要\"升级\"使用的新版本或协议\nVia               | 显示报文经过的中间节点（代理、网关）\n\n### 请求首部字段\n\n首部字段名               | 说明\n------------------- | --------------------------------\nAccept              | 用户代理可处理的媒体类型\nAccept-Charset      | 优先的字符集\nAccept-Encoding     | 优先的内容编码\nAccept-Language     | 有限的语言\nAuthorization       | Web认证信息\nExpect              | 期待副武器的特定行为\nfrom                | 用户的电子邮件地址\nHost                | 请求资源所在服务器\nIf-Match            | 比较实体标记ETag\nIf-Modified-Sincce  | 比较资源的更新时间\nIf-None-Match       | 比较实体标记与If-Match相反\nIf-Range            | 资源委更新时发送实体Byte的范围请求\nIf-Unmodified-Since | 比较资源的更新时间 与 If-Modified-Sincce相反\nMax-Forwards        | 最大传输逐跳数\nProxy-Authorization | 代理服务器要求客户端的认证消息\nRange               | 实体的字节范围请求\nReferer             | 队请求中URI的原始获取方法\nTE                  | 传输编码的优先级\nUser-Agent          | HTTP客户端程序的信息\n\n> 从今以后请称呼在下位为前端打字员，谢谢\n\n### 实体首部\n\n首部               | 描述\n---------------- | -----------------------------------------\nAllow            | 列出可以对此事提执行的请求方法\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式\nContent-Language | 理解主体时最适宜使用的自然语言\nContent-Length   | 主体的长度或尺寸\nContent-Locaton  | 资源实际所处的位置\nContent-MD5      | 主体的 MD5 校验和\nContent-Range    | 在整个资源中此实体表示的字节范围\nContent-Type     | 在这个主体的对象类型\nETag             | 与此实体相关的实体标记\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间\nLast-Modified    | 这个实体最后一次被修改的日期和时间\n\n## 空行\n\n即使第四部分的请求数据为空，也必须有空行。\n\n## 请求数据\n\n请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n# 响应\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n## 状态行\n\n状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n\n说一下状态码（复制粘贴的）\n\n状态码 | 含义\n--- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n100 | 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。\n101 | 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。\n102 | 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n200 | 请求已成功，请求所希望的响应头或数据体将随此响应返回。\n201 | 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。\n202 | 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。\n203 | 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。\n204 | 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n205 | 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。\n206 | 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。\n207 | 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\n300 | 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。\n301 | 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。\n302 | 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。\n303 | 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。\n304 | 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。\n305 | 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。\n306 | 在最新版的规范中，306状态码已经不再被使用。\n307 | 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n400 | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。\n401 | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。\n402 | 该状态码是为了将来可能的需求而预留的。\n403 | 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。\n404 | 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。\n405 | 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。\n406 | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。\n407 | 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。\n408 | 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。\n409 | 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。\n410 | 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。\n411 | 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。\n412 | 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。\n413 | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。\n414 | 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI \"黑洞\"，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。\n415 | 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。\n416 | 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。\n417 | 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。\n421 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。\n422 | 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）\n424 | 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）\n425 | 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。\n426 | 客户端应当切换到TLS/1.0。（RFC 2817）\n449 | 由微软扩展，代表请求应当在执行完适当的操作后进行重试。\n500 | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。\n501 | 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n502 | 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n503 | 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。\n504 | 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误\n505 | 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。\n506 | 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。\n507 | 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)\n509 | 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。\n510 | 获取资源所需要的策略并没有没满足。（RFC 2774）\n\n## 响应报头\n\n### 响应首部\n\n首部                 | 描述\n------------------ | ---------------------------------------------------------------------\nAge                | （从最初创建开始)响应持续时间。\nPublic             | 服务器为其资源支持的请求方法列表。\nRetry-After        | 如果资源不可用的话，在此日期或时间重试。\nServer             | 服务器应用程序软件的名称和版本。\nTitle              | 对 HTML 文档来说，就是 HTML 文档的源端给出的标题。\nWarning            | 比原因短语更详细一些的警告报文。\nAccept-Ranges      | 对此资源来说，服务器可接受的范围类型。\nVary               | 服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。\nProxy-Authenticate | 来自代理的对客户端的质询列表。\nSet-Cookie         | 不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。\nSet-Cookie2        | 与 Set-Cookie 类似，PFC 2965 Cookie定义。\nWWW-Authenticate   | 来自服务器对客户端的质询列表。\n\n\n\n# 实体首部\n\n首部               | 描述\n---------------- | ------------------------------------------\nAllow            | 列出可以对此事提执行的请求方法。\nLocation         | 告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。\nContent-Base     | 解释主体中的相对 URL 时使用的基础 URL\nContent-Encoding | 对主体执行的任意编码方式。\nContent-Language | 理解主体时最适宜使用的自然语言。\nContent-Length   | 主体的长度或尺寸。\nContent-Locaton  | 资源实际所处的位置。\nContent-MD5      | 主体的 MD5 校验和。\nContent-Range    | 在整个资源中此实体表示的字节范围。\nContent-Type     | 在这个主体的对象类型。\nETag             | 与此实体相关的实体标记。\nExpires          | 实体不再有效，要从原始的源端再次获取此实体的日期和时间。\nLast-Modified    | 这个实体最后一次被修改的日期和时间。\n\n[参考链接](http://tool.oschina.net/commons?type=5)\n","slug":"http","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydsksye002vhvs6jcuj8uhi","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>做一下http总结吧！！！</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h1><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本—-HTTP 1.1。</p>\n<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>\n<p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：</p>\n<ul>\n<li>对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。</li>\n<li>在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。</li>\n<li>Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。</li>\n<li>管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。</li>\n</ul>\n<p><br><br><br><br></p>\n<p>一次http链接的生命周期，基本包括请求和响应。</p>\n<h1 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h1><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。</p>\n<h2 id=\"请求行\"><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h2><p>请求行分为三个部分：请求方法、请求地址和协议版本.</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>从服务端获取资源</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>用来传输实体的主题</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>询问支持的方法</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>按请求URI删除指定文件</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>追踪路径，易引发XST（跨站攻击），不常用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求地址\"><a href=\"#请求地址\" class=\"headerlink\" title=\"请求地址\"></a>请求地址</h3><p>URL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。</p>\n<p>说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。</p>\n<h3 id=\"协议版本\"><a href=\"#协议版本\" class=\"headerlink\" title=\"协议版本\"></a>协议版本</h3><p>常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：</p>\n<ul>\n<li>多路复用<br><br>2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</li>\n<li>头部压缩<br><br>当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。</li>\n<li>随时复位<br><br>HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。</li>\n<li>服务器端推流: Server Push<br><br>客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。</li>\n<li>优先权和依赖<br><br>每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</li>\n</ul>\n<h2 id=\"请求头部\"><a href=\"#请求头部\" class=\"headerlink\" title=\"请求头部\"></a>请求头部</h2><p>请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段</p>\n<h3 id=\"通用请求首部\"><a href=\"#通用请求首部\" class=\"headerlink\" title=\"通用请求首部\"></a>通用请求首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connection</td>\n<td>允许客户端和服务器指定与请求/响应连接有关的选项</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>提供日期和时间标志，说明报文是什么时间创建的</td>\n</tr>\n<tr>\n<td>MIME-Version</td>\n<td>给出了发送短使用的 MINE 版本</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>\n</tr>\n<tr>\n<td>Update</td>\n<td>给出了发送端可能想要”升级”使用的新版本或协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>显示报文经过的中间节点（代理、网关）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>有限的语言</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待副武器的特定行为</td>\n</tr>\n<tr>\n<td>from</td>\n<td>用户的电子邮件地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记ETag</td>\n</tr>\n<tr>\n<td>If-Modified-Sincce</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记与If-Match相反</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源委更新时发送实体Byte的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间 与 If-Modified-Sincce相反</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证消息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>队请求中URI的原始获取方法</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP客户端程序的信息</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>从今以后请称呼在下位为前端打字员，谢谢</p>\n</blockquote>\n<h3 id=\"实体首部\"><a href=\"#实体首部\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a>空行</h2><p>即使第四部分的请求数据为空，也必须有空行。</p>\n<h2 id=\"请求数据\"><a href=\"#请求数据\" class=\"headerlink\" title=\"请求数据\"></a>请求数据</h2><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h1 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h1><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<h2 id=\"状态行\"><a href=\"#状态行\" class=\"headerlink\" title=\"状态行\"></a>状态行</h2><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>\n<p>说一下状态码（复制粘贴的）</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>\n</tr>\n<tr>\n<td>101</td>\n<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>\n</tr>\n<tr>\n<td>102</td>\n<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>\n</tr>\n<tr>\n<td>200</td>\n<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>\n</tr>\n<tr>\n<td>201</td>\n<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>\n</tr>\n<tr>\n<td>202</td>\n<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>\n</tr>\n<tr>\n<td>205</td>\n<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>\n</tr>\n<tr>\n<td>206</td>\n<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>\n</tr>\n<tr>\n<td>207</td>\n<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>\n</tr>\n<tr>\n<td>300</td>\n<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>\n</tr>\n<tr>\n<td>306</td>\n<td>在最新版的规范中，306状态码已经不再被使用。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>\n</tr>\n<tr>\n<td>400</td>\n<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>402</td>\n<td>该状态码是为了将来可能的需求而预留的。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>\n</tr>\n<tr>\n<td>409</td>\n<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>\n</tr>\n<tr>\n<td>410</td>\n<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>\n</tr>\n<tr>\n<td>411</td>\n<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>\n</tr>\n<tr>\n<td>421</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>424</td>\n<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>425</td>\n<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>\n</tr>\n<tr>\n<td>426</td>\n<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>\n</tr>\n<tr>\n<td>449</td>\n<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>\n</tr>\n<tr>\n<td>500</td>\n<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>\n</tr>\n<tr>\n<td>505</td>\n<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>\n</tr>\n<tr>\n<td>506</td>\n<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>\n</tr>\n<tr>\n<td>507</td>\n<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>\n</tr>\n<tr>\n<td>509</td>\n<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>\n</tr>\n<tr>\n<td>510</td>\n<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"响应报头\"><a href=\"#响应报头\" class=\"headerlink\" title=\"响应报头\"></a>响应报头</h2><h3 id=\"响应首部\"><a href=\"#响应首部\" class=\"headerlink\" title=\"响应首部\"></a>响应首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>（从最初创建开始)响应持续时间。</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>服务器为其资源支持的请求方法列表。</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果资源不可用的话，在此日期或时间重试。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器应用程序软件的名称和版本。</td>\n</tr>\n<tr>\n<td>Title</td>\n<td>对 HTML 文档来说，就是 HTML 文档的源端给出的标题。</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>比原因短语更详细一些的警告报文。</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>对此资源来说，服务器可接受的范围类型。</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>来自代理的对客户端的质询列表。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。</td>\n</tr>\n<tr>\n<td>Set-Cookie2</td>\n<td>与 Set-Cookie 类似，PFC 2965 Cookie定义。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>来自服务器对客户端的质询列表。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"实体首部-1\"><a href=\"#实体首部-1\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h1><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式。</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸。</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置。</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和。</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型。</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间。</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间。</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://tool.oschina.net/commons?type=5\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>做一下http总结吧！！！</p>\n</blockquote>","more":"<h1 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h1><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本—-HTTP 1.1。</p>\n<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>\n<p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：</p>\n<ul>\n<li>对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。</li>\n<li>在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。</li>\n<li>Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。</li>\n<li>管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。</li>\n</ul>\n<p><br><br><br><br></p>\n<p>一次http链接的生命周期，基本包括请求和响应。</p>\n<h1 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h1><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。</p>\n<h2 id=\"请求行\"><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h2><p>请求行分为三个部分：请求方法、请求地址和协议版本.</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>从服务端获取资源</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>用来传输实体的主题</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>询问支持的方法</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>按请求URI删除指定文件</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>追踪路径，易引发XST（跨站攻击），不常用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求地址\"><a href=\"#请求地址\" class=\"headerlink\" title=\"请求地址\"></a>请求地址</h3><p>URL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。</p>\n<p>说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。</p>\n<h3 id=\"协议版本\"><a href=\"#协议版本\" class=\"headerlink\" title=\"协议版本\"></a>协议版本</h3><p>常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：</p>\n<ul>\n<li>多路复用<br><br>2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</li>\n<li>头部压缩<br><br>当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。</li>\n<li>随时复位<br><br>HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。</li>\n<li>服务器端推流: Server Push<br><br>客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。</li>\n<li>优先权和依赖<br><br>每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</li>\n</ul>\n<h2 id=\"请求头部\"><a href=\"#请求头部\" class=\"headerlink\" title=\"请求头部\"></a>请求头部</h2><p>请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段</p>\n<h3 id=\"通用请求首部\"><a href=\"#通用请求首部\" class=\"headerlink\" title=\"通用请求首部\"></a>通用请求首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connection</td>\n<td>允许客户端和服务器指定与请求/响应连接有关的选项</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>提供日期和时间标志，说明报文是什么时间创建的</td>\n</tr>\n<tr>\n<td>MIME-Version</td>\n<td>给出了发送短使用的 MINE 版本</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>\n</tr>\n<tr>\n<td>Update</td>\n<td>给出了发送端可能想要”升级”使用的新版本或协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>显示报文经过的中间节点（代理、网关）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>有限的语言</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待副武器的特定行为</td>\n</tr>\n<tr>\n<td>from</td>\n<td>用户的电子邮件地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记ETag</td>\n</tr>\n<tr>\n<td>If-Modified-Sincce</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记与If-Match相反</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源委更新时发送实体Byte的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间 与 If-Modified-Sincce相反</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证消息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>队请求中URI的原始获取方法</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP客户端程序的信息</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>从今以后请称呼在下位为前端打字员，谢谢</p>\n</blockquote>\n<h3 id=\"实体首部\"><a href=\"#实体首部\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a>空行</h2><p>即使第四部分的请求数据为空，也必须有空行。</p>\n<h2 id=\"请求数据\"><a href=\"#请求数据\" class=\"headerlink\" title=\"请求数据\"></a>请求数据</h2><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h1 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h1><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<h2 id=\"状态行\"><a href=\"#状态行\" class=\"headerlink\" title=\"状态行\"></a>状态行</h2><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>\n<p>说一下状态码（复制粘贴的）</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>\n</tr>\n<tr>\n<td>101</td>\n<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>\n</tr>\n<tr>\n<td>102</td>\n<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>\n</tr>\n<tr>\n<td>200</td>\n<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>\n</tr>\n<tr>\n<td>201</td>\n<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>\n</tr>\n<tr>\n<td>202</td>\n<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>\n</tr>\n<tr>\n<td>205</td>\n<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>\n</tr>\n<tr>\n<td>206</td>\n<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>\n</tr>\n<tr>\n<td>207</td>\n<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>\n</tr>\n<tr>\n<td>300</td>\n<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>\n</tr>\n<tr>\n<td>306</td>\n<td>在最新版的规范中，306状态码已经不再被使用。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>\n</tr>\n<tr>\n<td>400</td>\n<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>402</td>\n<td>该状态码是为了将来可能的需求而预留的。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>\n</tr>\n<tr>\n<td>409</td>\n<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>\n</tr>\n<tr>\n<td>410</td>\n<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>\n</tr>\n<tr>\n<td>411</td>\n<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>\n</tr>\n<tr>\n<td>421</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>\n</tr>\n<tr>\n<td>422</td>\n<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>424</td>\n<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>\n</tr>\n<tr>\n<td>425</td>\n<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>\n</tr>\n<tr>\n<td>426</td>\n<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>\n</tr>\n<tr>\n<td>449</td>\n<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>\n</tr>\n<tr>\n<td>500</td>\n<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>\n</tr>\n<tr>\n<td>505</td>\n<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>\n</tr>\n<tr>\n<td>506</td>\n<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>\n</tr>\n<tr>\n<td>507</td>\n<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>\n</tr>\n<tr>\n<td>509</td>\n<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>\n</tr>\n<tr>\n<td>510</td>\n<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"响应报头\"><a href=\"#响应报头\" class=\"headerlink\" title=\"响应报头\"></a>响应报头</h2><h3 id=\"响应首部\"><a href=\"#响应首部\" class=\"headerlink\" title=\"响应首部\"></a>响应首部</h3><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>（从最初创建开始)响应持续时间。</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>服务器为其资源支持的请求方法列表。</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果资源不可用的话，在此日期或时间重试。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器应用程序软件的名称和版本。</td>\n</tr>\n<tr>\n<td>Title</td>\n<td>对 HTML 文档来说，就是 HTML 文档的源端给出的标题。</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>比原因短语更详细一些的警告报文。</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>对此资源来说，服务器可接受的范围类型。</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>来自代理的对客户端的质询列表。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。</td>\n</tr>\n<tr>\n<td>Set-Cookie2</td>\n<td>与 Set-Cookie 类似，PFC 2965 Cookie定义。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>来自服务器对客户端的质询列表。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"实体首部-1\"><a href=\"#实体首部-1\" class=\"headerlink\" title=\"实体首部\"></a>实体首部</h1><table>\n<thead>\n<tr>\n<th>首部</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>列出可以对此事提执行的请求方法。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。</td>\n</tr>\n<tr>\n<td>Content-Base</td>\n<td>解释主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>对主体执行的任意编码方式。</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>理解主体时最适宜使用的自然语言。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>主体的长度或尺寸。</td>\n</tr>\n<tr>\n<td>Content-Locaton</td>\n<td>资源实际所处的位置。</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>主体的 MD5 校验和。</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个资源中此实体表示的字节范围。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>在这个主体的对象类型。</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体不再有效，要从原始的源端再次获取此实体的日期和时间。</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>这个实体最后一次被修改的日期和时间。</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://tool.oschina.net/commons?type=5\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>"},{"title":"前端面试收集","date":"2018-04-02T06:42:08.000Z","_content":"\n本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。\n\n<!--more-->\n\n## HTML\n\n#### 1. DOCTYPE 作用？有哪些模式，模式怎么区分？\n\n**答**：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：\n\n1. 标准模式（standards mode）：浏览器根据标准规约来渲染页面。\n2. 混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。\n\n\n如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。\n\n1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）\n2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）\n3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）\n4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）\n#### 2. 常用的DOCTYPE声明有几种？\n\n**答**：\n\n1. HTML5 `<!DOCTYPE html>`\n2. HTML 4.01 Strict `<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">`\n3. HTML 4.01 Transitional\n\n```HTML\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n#### 3. 什么是 HTML 语义化，为什么要语义化？\n\n**答**：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含\n\n1. 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重\n2. 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构\n3. 方便其他设备的解析\n4. 便于团队开发和维护\n\n#### 4. 行内元素、块级元素、空(void)元素都有那些？\n\n**答**：\n\n* 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n* 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n* 空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img\n\n#### 5. 简述一下 src 与 href 的区别？\n\n**答**：\n\n* href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接\n* src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部\n\n#### 6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\n\n**答**：Cookie, localStorage 和 sessionStorage.\n\n1. Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。\n2. LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。\n\n以下为三者之间的区别：\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>特性</th>\n\t\t\t<th>Cookie</th>\n\t\t\t<th>localStorage</th>\n\t\t\t<th>sessionStorage</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>数据的生命期</td>\n\t\t\t<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n\t\t\t<td>除非被清除，否则永久保存</td>\n\t\t\t<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>存放数据大小</td>\n\t\t\t<td>4K左右</td>\n\t\t\t<td colspan=\"2\">一般为5MB</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>与服务器端通信</td>\n\t\t\t<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n\t\t\t<td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>易用性</td>\n\t\t\t<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n\t\t\t<td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n#### 7. 什么是跨域请求？其限制原因有哪些？\n\n**答**：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。\n\n#### 8. 前端跨域请求解决方案都有哪些？\n\n**答**：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 [前端跨域请求解决方案汇总](https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md) 或者 [Joe's Blog](https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/).\n\n#### 9. iframe 的优缺点？\n\n**答**：\n\n优点\n\n1. 程序调入静态页面比较方便\n2. 页面和程序分离\n3. 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)\n4. 能够原封不动的把嵌入的网页展现出来\n\n缺点\n\n1. 会产生很多页面，不容易管理\n2. 不容易打印\n3. 浏览器的后退按钮无效\n4. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用\niframe会不利于搜索引擎优化\n5. 多数小型的移动设备无法完全显示框架，设备兼容性差\n6. 多框架的页面会增加服务器的http请求，对于大型网站是不可取的\n\n#### 10. iframe 有哪些使用场景？\n\n**答**：\n\n1. 沙箱隔离。\n2. 引用第三方内容。\n3. 独立的带有交互的内容，比如幻灯片。\n4. 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。\n\n#### 11. HTML 的全局属性都有哪些？\n\n**答**：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。\n\n- `accesskey`:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按``alt + shift + a``可激活元素\n- `class`:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素\n- `contenteditable`: 指定元素内容是否可编辑\n- `contextmenu`: 自定义鼠标右键弹出菜单内容\n- `data-*`: 为元素增加自定义属性\n- `dir`: 设置元素文本方向\n- `draggable`: 设置元素是否可拖拽\n- `dropzone`: 设置元素拖放类型： copy, move, link\n- `hidden`: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果\n- `id`: 元素id，文档内唯一\n- `lang`: 元素内容的的语言\n- `spellcheck`: 是否启动拼写和语法检查\n- `style`: 行内css样式\n- `tabindex`: 设置元素可以获得焦点，通过tab可以导航\n- `title`: 元素相关的建议信息\n- `translate`: 元素和子孙节点内容是否需要本地化\n\n#### 12. 常见的浏览器内核有哪些？\n\n浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。\n\n* Trident 为 IE 内核，又称 MSHTML\n* Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核\n* Webkit 内核：Safari, Chrome 等\n* Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支\n* Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink\n* 移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident\n\n\n## JavaScript\n\n#### 1. ECMAScript/JavaScript 中都有那些数据类型？\n\n**答**：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.\n\n#### 2. 把非数值转化为数值的函数都有哪些？\n\n**答**：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。\n\n#### 3. JavaScript 中的 new 关键词做了什么？\n\n* **答**：他做了五件事\n\n1. 他生成了一个新对象。这个对象的类型只是一个普通的对象；\n2. 他将新对象内部、不可访问的原型属性（例如：`__proto__`）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 `prototype` 属性）；\n3. 他将 `this` 变量指向这个新生成的对象；\n4. 他执行构造器函数，对于每个提及到 `this` 的地方使用新生成的对象执行；\n5. 他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；\n\n#### 4. JavaScript 的六种继承类型？\n\n* **答**：\n\n* 简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；\n\n```\nfunction Super(){\n    this.val = 1;\n}\nfunction Sub(){\n    // ...\n}\nSub.prototype = new Super();\nlet sub1 = new Sub();\n```\n\n* 借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 `fun` 函数，太多了就会影响性能；\n\n```\nfunction Super(val){\n    this.val = val;\n    this.fun = function(){\n        // ...\n    }\n}\nfunction Sub(val){\n    Super.call(this, val);   // 核心\n}\nlet sub1 = new Sub(1);\n```\n\n* 组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；\n\n```\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nSub.prototype = new Super();    // 核心\nlet sub1 = new Sub(1);\n```\n\n* 原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n// 拿到父类对象\nlet sup = new Super();\n// 生孩子\nlet sub = beget(sup);\n```\n\n* 寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；\n\n```\nfunction beget(obj){   // 生孩子函数\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nfunction getSubObject(obj){\n    // 创建新对象\n    let clone = beget(obj); // 核心\n    // 增强\n    clone.attr1 = 1;\n    clone.attr2 = 2;\n    return clone;\n}\nvar sub = getSubObject(new Super());\n```\n\n* 寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n    this.arr = [1];\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nSuper.prototype.fun2 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nlet proto = beget(Super.prototype); // 核心\nproto.constructor = Sub;            // 核心\nSub.prototype = proto;              // 核心\nlet sub = new Sub();\n```\n\n#### 5. 箭头函数的适用规则？\n\n* **答**：\n\n* 如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=>箭头函数。\n* 对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=>函数语法。\n\n#### 6. 为什么我们区别 LHS 和 RHS 那么重要？\n\n**答**：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。\n\n#### 7. 如何区分声明和表达式？\n\n**答**：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。\n\n#### 8. IIFE 方式与变种？\n\n**答**：\n\n```javascript\n// 1\n(function foo(){ .. })()\n// 2\n(function(){ .. }())\n// 3，用于 UMD 项目\n(function IIFE( def ){\n\tdef( window );\n})(function def( global ){\n\tlet a = 3;\n\tconsole.log( a ); // 3\n\tconsole.log( global.a ); // 2\n});\n```\n\n#### 9. 请解释如下代码执行的结果？\n\n```\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n```\n\n**答**：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为\"\"因此{}也会被强制转换为一个string：\"[object Object]\"。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。\n\n#### 10. 什么是事件委托？\n\n**答**：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。\n\n#### 11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\n\n**答**：\n\n1. 捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；\n2. 目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；\n3. 冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；\n\n#### 12. 触摸事件都有哪些？\n\n**答**：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件\n\n1. touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。\n2. touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。\n3. touchend事件：当手指从屏幕上离开的时候触发。\n\n#### 13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\n\n**答**：\n\n1. event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。\n2. event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。**特别说明：IE不支持！**\n3. screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。\n4. event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。**特别说明：只有IE支持！**\n\n## CSS\n\n#### 1. 什么是盒子模型？\n\n**答**：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。\n\n#### 2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\n\n**答**：使用 CSS `word-break` 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS `text-overflow` 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。\n\n#### 3. 什么是 Data URI？\n\n**答**：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。\n\n#### 4. Data URI 的好处和缺点都有哪些？\n\n**答**：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：\n\n* 当访问外部资源很麻烦或受限时。\n* 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。\n* 当图片的体积太小，占用一个HTTP会话不是很值得时。\n\nData URL也有一些不适用的场合：\n\n* Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。\n* Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。\n\n#### 5. 内联元素和块级元素的区别？\n\n**答**：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。\n\n#### 6. CSS Transform / Transition / Animation 属性的区别？\n\n**答**：\n\n* transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；\n* transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；\n* animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；\n\n#### 7. position 布局方式都有哪些？\n\n**答**：\n\n* **static** - static 是默认值。任意 `position: static;` 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。\n* **relative** - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。\n* **fixed** - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。\n* **absolute** - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。\n\n*记住一个“positioned”元素是指 position 值不是 static 的元素。*\n\n#### 8. display 的属性都有哪些？\n\n**答**：块级元素默认值为 block，而行内元素为 inline。\n\n* **block** - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。\n* **inline** - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。\n* **none** - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。\n\n其他 display 值，例如 inline-block, list-item, table 和 flex。\n\n## Node 软件包管理\n\n#### 1. 简述同步和异步之间的区别？\n\n**答**：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率\n\n#### 2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 `\"d3\": \"^3.9.0\"` 或者 `\"d3\": \"~3.9.0\"`，请问 \"^\" 和 \"~\" 的含义分别是什么？\n\n**答**：根据 [\"npm install --save\" No Longer Using Tildes](http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/) 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。\n\n## 浏览器\n\n#### 3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\n\n**答**：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：\n\n```\nfunction inIframe () {\n    try {\n        return window.self !== window.top;\n    } catch (e) {\n        return true;\n    }\n}\n```\n\ntop 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。\n\n## HTTP\n\n#### 1. HTTP/0.9 只有一个命令 `GET`, HTTP/1.0 引入了 `POST` 命令和 `HEAD` 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\n\n**答**：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是\n\n1. OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'\\*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n2. HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\n3. GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法\n4. POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\n5. PUT：向指定资源位置上传其最新内容。\n6. DELETE：请求服务器删除Request-URI所标识的资源。\n7. TRACE：回显服务器收到的请求，主要用于测试或诊断。\n8. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\n\n#### 2. HTTP 状态码的主要类型有哪些？\n\n**答**：状态代码的第一个数字代表当前响应的类型，主要为五类\n\n1. 1xx消息——请求已被服务器接收，继续处理\n2. 2xx成功——请求已成功被服务器接收、理解、并接受\n3. 3xx重定向——需要后续操作才能完成这一请求\n4. 4xx请求错误——请求含有词法错误或者无法被执行\n5. 5xx服务器错误——服务器在处理某个正确请求时发生错误\n\n详细情况见 [维基百科](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)。\n\n#### 3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\n\n**答**：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n#### 4. HTTPS 建立连接的过程？\n\n**答**：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。\n\n1. 客户端发出握手请求 (Client Hello)，包含以下信息：\n\t* 支持的协议版本，比如TLS 1.0\n\t* 一个客户端生成的随机数(random\\_1)，这个随机数既需要客户端保存又需要发送给服务器\n\t* 支持的加密方法，比如RSA公钥加密\n\t* 支持的压缩方法\n2. 服务器回复 (Server Hello)，包含以下信息：\n\t* 确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信\n\t* 一个服务器生成的随机数 (random\\_2)\n\t* 确认使用的加密方法，比如RSA公钥加密\n\t* 服务器证书（其中包含服务器放入公钥）\n\t* 可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书\n3. 客户端回应，包含以下步骤：\n\t* 验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开\n\t* 客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验\n4. 服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random\\_1 和 random\\_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验\n\n在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。\n\n需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。\n\n![SSL 连接建立过程详解图](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png\")\n\n#### 4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\n\n**答**：\n\n* OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n* TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。\n* 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。\n* 每一层的协议如下：\n\t* 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）\n\t* 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）\n\t* 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）\n\t* 传输层：TCP、UDP、SPX\n\t* 会话层：NFS、SQL、NETBIOS、RPC\n\t* 表示层：JPEG、MPEG、ASII\n\t* 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n* 每一层的作用如下：\n\t* 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\n\t* 数据链路层：将比特组装成帧和点到点的传递（帧Frame）\n\t* 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\n\t* 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\n\t* 会话层：建立、管理和终止会话（会话协议数据单元SPDU）\n\t* 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\n\t* 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\n\n#### 5. IP 地址的分类？\n\n**答**：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—\n192.168.255.255 为 Internet 上保留地址用于内部。\n\n#### 6. 互联网上各类协议的介绍？\n\n**答**：\n\n1. ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。\n2. TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。\n3. HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。\n4. DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。\nNAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。\n5. DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。\n\n#### 7. TCP 和 UDP 的区别？\n\n**答**：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：\n\n```\nTCP 协议\n（1） FTP：定义了文件传输协议，使用21端口。\n（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。\n（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。\n（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。\n（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。\nUDP协议\n（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。\n（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\n（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。\n```\n","source":"_posts/面试.md","raw":"---\ntitle: 前端面试收集\ndate: 2018-04-02 14:42:08\ntags: javascript\ncategories: 学习\n---\n\n本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。\n\n<!--more-->\n\n## HTML\n\n#### 1. DOCTYPE 作用？有哪些模式，模式怎么区分？\n\n**答**：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：\n\n1. 标准模式（standards mode）：浏览器根据标准规约来渲染页面。\n2. 混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。\n\n\n如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。\n\n1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）\n2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）\n3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）\n4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）\n#### 2. 常用的DOCTYPE声明有几种？\n\n**答**：\n\n1. HTML5 `<!DOCTYPE html>`\n2. HTML 4.01 Strict `<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">`\n3. HTML 4.01 Transitional\n\n```HTML\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n#### 3. 什么是 HTML 语义化，为什么要语义化？\n\n**答**：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含\n\n1. 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重\n2. 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构\n3. 方便其他设备的解析\n4. 便于团队开发和维护\n\n#### 4. 行内元素、块级元素、空(void)元素都有那些？\n\n**答**：\n\n* 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n* 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n* 空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img\n\n#### 5. 简述一下 src 与 href 的区别？\n\n**答**：\n\n* href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接\n* src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部\n\n#### 6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\n\n**答**：Cookie, localStorage 和 sessionStorage.\n\n1. Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。\n2. LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。\n\n以下为三者之间的区别：\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>特性</th>\n\t\t\t<th>Cookie</th>\n\t\t\t<th>localStorage</th>\n\t\t\t<th>sessionStorage</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>数据的生命期</td>\n\t\t\t<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n\t\t\t<td>除非被清除，否则永久保存</td>\n\t\t\t<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>存放数据大小</td>\n\t\t\t<td>4K左右</td>\n\t\t\t<td colspan=\"2\">一般为5MB</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>与服务器端通信</td>\n\t\t\t<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n\t\t\t<td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>易用性</td>\n\t\t\t<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n\t\t\t<td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n#### 7. 什么是跨域请求？其限制原因有哪些？\n\n**答**：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。\n\n#### 8. 前端跨域请求解决方案都有哪些？\n\n**答**：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 [前端跨域请求解决方案汇总](https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md) 或者 [Joe's Blog](https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/).\n\n#### 9. iframe 的优缺点？\n\n**答**：\n\n优点\n\n1. 程序调入静态页面比较方便\n2. 页面和程序分离\n3. 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)\n4. 能够原封不动的把嵌入的网页展现出来\n\n缺点\n\n1. 会产生很多页面，不容易管理\n2. 不容易打印\n3. 浏览器的后退按钮无效\n4. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用\niframe会不利于搜索引擎优化\n5. 多数小型的移动设备无法完全显示框架，设备兼容性差\n6. 多框架的页面会增加服务器的http请求，对于大型网站是不可取的\n\n#### 10. iframe 有哪些使用场景？\n\n**答**：\n\n1. 沙箱隔离。\n2. 引用第三方内容。\n3. 独立的带有交互的内容，比如幻灯片。\n4. 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。\n\n#### 11. HTML 的全局属性都有哪些？\n\n**答**：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。\n\n- `accesskey`:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按``alt + shift + a``可激活元素\n- `class`:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素\n- `contenteditable`: 指定元素内容是否可编辑\n- `contextmenu`: 自定义鼠标右键弹出菜单内容\n- `data-*`: 为元素增加自定义属性\n- `dir`: 设置元素文本方向\n- `draggable`: 设置元素是否可拖拽\n- `dropzone`: 设置元素拖放类型： copy, move, link\n- `hidden`: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果\n- `id`: 元素id，文档内唯一\n- `lang`: 元素内容的的语言\n- `spellcheck`: 是否启动拼写和语法检查\n- `style`: 行内css样式\n- `tabindex`: 设置元素可以获得焦点，通过tab可以导航\n- `title`: 元素相关的建议信息\n- `translate`: 元素和子孙节点内容是否需要本地化\n\n#### 12. 常见的浏览器内核有哪些？\n\n浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。\n\n* Trident 为 IE 内核，又称 MSHTML\n* Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核\n* Webkit 内核：Safari, Chrome 等\n* Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支\n* Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink\n* 移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident\n\n\n## JavaScript\n\n#### 1. ECMAScript/JavaScript 中都有那些数据类型？\n\n**答**：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.\n\n#### 2. 把非数值转化为数值的函数都有哪些？\n\n**答**：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。\n\n#### 3. JavaScript 中的 new 关键词做了什么？\n\n* **答**：他做了五件事\n\n1. 他生成了一个新对象。这个对象的类型只是一个普通的对象；\n2. 他将新对象内部、不可访问的原型属性（例如：`__proto__`）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 `prototype` 属性）；\n3. 他将 `this` 变量指向这个新生成的对象；\n4. 他执行构造器函数，对于每个提及到 `this` 的地方使用新生成的对象执行；\n5. 他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；\n\n#### 4. JavaScript 的六种继承类型？\n\n* **答**：\n\n* 简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；\n\n```\nfunction Super(){\n    this.val = 1;\n}\nfunction Sub(){\n    // ...\n}\nSub.prototype = new Super();\nlet sub1 = new Sub();\n```\n\n* 借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 `fun` 函数，太多了就会影响性能；\n\n```\nfunction Super(val){\n    this.val = val;\n    this.fun = function(){\n        // ...\n    }\n}\nfunction Sub(val){\n    Super.call(this, val);   // 核心\n}\nlet sub1 = new Sub(1);\n```\n\n* 组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；\n\n```\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nSub.prototype = new Super();    // 核心\nlet sub1 = new Sub(1);\n```\n\n* 原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\n// 拿到父类对象\nlet sup = new Super();\n// 生孩子\nlet sub = beget(sup);\n```\n\n* 寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；\n\n```\nfunction beget(obj){   // 生孩子函数\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nfunction getSubObject(obj){\n    // 创建新对象\n    let clone = beget(obj); // 核心\n    // 增强\n    clone.attr1 = 1;\n    clone.attr2 = 2;\n    return clone;\n}\nvar sub = getSubObject(new Super());\n```\n\n* 寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；\n\n```\nfunction beget(obj){   // 生孩子函数 beget\n    let F = function(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n    this.arr = [1];\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nSuper.prototype.fun2 = function(){};\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nlet proto = beget(Super.prototype); // 核心\nproto.constructor = Sub;            // 核心\nSub.prototype = proto;              // 核心\nlet sub = new Sub();\n```\n\n#### 5. 箭头函数的适用规则？\n\n* **答**：\n\n* 如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=>箭头函数。\n* 如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=>箭头函数。\n* 对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=>函数语法。\n\n#### 6. 为什么我们区别 LHS 和 RHS 那么重要？\n\n**答**：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。\n\n#### 7. 如何区分声明和表达式？\n\n**答**：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。\n\n#### 8. IIFE 方式与变种？\n\n**答**：\n\n```javascript\n// 1\n(function foo(){ .. })()\n// 2\n(function(){ .. }())\n// 3，用于 UMD 项目\n(function IIFE( def ){\n\tdef( window );\n})(function def( global ){\n\tlet a = 3;\n\tconsole.log( a ); // 3\n\tconsole.log( global.a ); // 2\n});\n```\n\n#### 9. 请解释如下代码执行的结果？\n\n```\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n```\n\n**答**：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为\"\"因此{}也会被强制转换为一个string：\"[object Object]\"。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。\n\n#### 10. 什么是事件委托？\n\n**答**：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。\n\n#### 11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\n\n**答**：\n\n1. 捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；\n2. 目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；\n3. 冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；\n\n#### 12. 触摸事件都有哪些？\n\n**答**：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件\n\n1. touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。\n2. touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。\n3. touchend事件：当手指从屏幕上离开的时候触发。\n\n#### 13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\n\n**答**：\n\n1. event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。\n2. event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。**特别说明：IE不支持！**\n3. screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。\n4. event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。**特别说明：只有IE支持！**\n\n## CSS\n\n#### 1. 什么是盒子模型？\n\n**答**：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。\n\n#### 2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\n\n**答**：使用 CSS `word-break` 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS `text-overflow` 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。\n\n#### 3. 什么是 Data URI？\n\n**答**：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。\n\n#### 4. Data URI 的好处和缺点都有哪些？\n\n**答**：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：\n\n* 当访问外部资源很麻烦或受限时。\n* 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。\n* 当图片的体积太小，占用一个HTTP会话不是很值得时。\n\nData URL也有一些不适用的场合：\n\n* Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。\n* Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。\n\n#### 5. 内联元素和块级元素的区别？\n\n**答**：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。\n\n#### 6. CSS Transform / Transition / Animation 属性的区别？\n\n**答**：\n\n* transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；\n* transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；\n* animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；\n\n#### 7. position 布局方式都有哪些？\n\n**答**：\n\n* **static** - static 是默认值。任意 `position: static;` 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。\n* **relative** - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。\n* **fixed** - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。\n* **absolute** - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。\n\n*记住一个“positioned”元素是指 position 值不是 static 的元素。*\n\n#### 8. display 的属性都有哪些？\n\n**答**：块级元素默认值为 block，而行内元素为 inline。\n\n* **block** - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。\n* **inline** - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。\n* **none** - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。\n\n其他 display 值，例如 inline-block, list-item, table 和 flex。\n\n## Node 软件包管理\n\n#### 1. 简述同步和异步之间的区别？\n\n**答**：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率\n\n#### 2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 `\"d3\": \"^3.9.0\"` 或者 `\"d3\": \"~3.9.0\"`，请问 \"^\" 和 \"~\" 的含义分别是什么？\n\n**答**：根据 [\"npm install --save\" No Longer Using Tildes](http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/) 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。\n\n## 浏览器\n\n#### 3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\n\n**答**：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：\n\n```\nfunction inIframe () {\n    try {\n        return window.self !== window.top;\n    } catch (e) {\n        return true;\n    }\n}\n```\n\ntop 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。\n\n## HTTP\n\n#### 1. HTTP/0.9 只有一个命令 `GET`, HTTP/1.0 引入了 `POST` 命令和 `HEAD` 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\n\n**答**：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是\n\n1. OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'\\*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n2. HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\n3. GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法\n4. POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\n5. PUT：向指定资源位置上传其最新内容。\n6. DELETE：请求服务器删除Request-URI所标识的资源。\n7. TRACE：回显服务器收到的请求，主要用于测试或诊断。\n8. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\n\n#### 2. HTTP 状态码的主要类型有哪些？\n\n**答**：状态代码的第一个数字代表当前响应的类型，主要为五类\n\n1. 1xx消息——请求已被服务器接收，继续处理\n2. 2xx成功——请求已成功被服务器接收、理解、并接受\n3. 3xx重定向——需要后续操作才能完成这一请求\n4. 4xx请求错误——请求含有词法错误或者无法被执行\n5. 5xx服务器错误——服务器在处理某个正确请求时发生错误\n\n详细情况见 [维基百科](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)。\n\n#### 3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\n\n**答**：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n#### 4. HTTPS 建立连接的过程？\n\n**答**：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。\n\n1. 客户端发出握手请求 (Client Hello)，包含以下信息：\n\t* 支持的协议版本，比如TLS 1.0\n\t* 一个客户端生成的随机数(random\\_1)，这个随机数既需要客户端保存又需要发送给服务器\n\t* 支持的加密方法，比如RSA公钥加密\n\t* 支持的压缩方法\n2. 服务器回复 (Server Hello)，包含以下信息：\n\t* 确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信\n\t* 一个服务器生成的随机数 (random\\_2)\n\t* 确认使用的加密方法，比如RSA公钥加密\n\t* 服务器证书（其中包含服务器放入公钥）\n\t* 可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书\n3. 客户端回应，包含以下步骤：\n\t* 验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开\n\t* 客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验\n4. 服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random\\_1 和 random\\_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：\n\t* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送\n\t* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验\n\n在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。\n\n需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。\n\n![SSL 连接建立过程详解图](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png\")\n\n#### 4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\n\n**答**：\n\n* OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n* TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。\n* 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。\n* 每一层的协议如下：\n\t* 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）\n\t* 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）\n\t* 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）\n\t* 传输层：TCP、UDP、SPX\n\t* 会话层：NFS、SQL、NETBIOS、RPC\n\t* 表示层：JPEG、MPEG、ASII\n\t* 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n* 每一层的作用如下：\n\t* 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\n\t* 数据链路层：将比特组装成帧和点到点的传递（帧Frame）\n\t* 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\n\t* 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\n\t* 会话层：建立、管理和终止会话（会话协议数据单元SPDU）\n\t* 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\n\t* 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\n\n#### 5. IP 地址的分类？\n\n**答**：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—\n192.168.255.255 为 Internet 上保留地址用于内部。\n\n#### 6. 互联网上各类协议的介绍？\n\n**答**：\n\n1. ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。\n2. TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。\n3. HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。\n4. DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。\nNAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。\n5. DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。\n\n#### 7. TCP 和 UDP 的区别？\n\n**答**：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：\n\n```\nTCP 协议\n（1） FTP：定义了文件传输协议，使用21端口。\n（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。\n（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。\n（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。\n（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。\nUDP协议\n（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。\n（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\n（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。\n```\n","slug":"面试","published":1,"updated":"2019-07-21T11:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjydsksyf002whvs6u4zm3avj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。</p>\n<a id=\"more\"></a>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h4 id=\"1-DOCTYPE-作用？有哪些模式，模式怎么区分？\"><a href=\"#1-DOCTYPE-作用？有哪些模式，模式怎么区分？\" class=\"headerlink\" title=\"1. DOCTYPE 作用？有哪些模式，模式怎么区分？\"></a>1. DOCTYPE 作用？有哪些模式，模式怎么区分？</h4><p><strong>答</strong>：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：</p>\n<ol>\n<li>标准模式（standards mode）：浏览器根据标准规约来渲染页面。</li>\n<li>混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。</li>\n</ol>\n<p>如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。</p>\n<p>1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）<br>2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）<br>3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）<br>4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）</p>\n<h4 id=\"2-常用的DOCTYPE声明有几种？\"><a href=\"#2-常用的DOCTYPE声明有几种？\" class=\"headerlink\" title=\"2. 常用的DOCTYPE声明有几种？\"></a>2. 常用的DOCTYPE声明有几种？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>HTML5 <code>&lt;!DOCTYPE html&gt;</code></li>\n<li>HTML 4.01 Strict <code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li>\n<li>HTML 4.01 Transitional</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-什么是-HTML-语义化，为什么要语义化？\"><a href=\"#3-什么是-HTML-语义化，为什么要语义化？\" class=\"headerlink\" title=\"3. 什么是 HTML 语义化，为什么要语义化？\"></a>3. 什么是 HTML 语义化，为什么要语义化？</h4><p><strong>答</strong>：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含</p>\n<ol>\n<li>有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重</li>\n<li>语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构</li>\n<li>方便其他设备的解析</li>\n<li>便于团队开发和维护</li>\n</ol>\n<h4 id=\"4-行内元素、块级元素、空-void-元素都有那些？\"><a href=\"#4-行内元素、块级元素、空-void-元素都有那些？\" class=\"headerlink\" title=\"4. 行内元素、块级元素、空(void)元素都有那些？\"></a>4. 行内元素、块级元素、空(void)元素都有那些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</li>\n<li>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</li>\n<li>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</li>\n</ul>\n<h4 id=\"5-简述一下-src-与-href-的区别？\"><a href=\"#5-简述一下-src-与-href-的区别？\" class=\"headerlink\" title=\"5. 简述一下 src 与 href 的区别？\"></a>5. 简述一下 src 与 href 的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接</li>\n<li>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</li>\n</ul>\n<h4 id=\"6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\"><a href=\"#6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\" class=\"headerlink\" title=\"6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\"></a>6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？</h4><p><strong>答</strong>：Cookie, localStorage 和 sessionStorage.</p>\n<ol>\n<li>Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。</li>\n<li>LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。</li>\n</ol>\n<p>以下为三者之间的区别：</p>\n<table><br>    <thead><br>        <tr><br>            <th>特性</th><br>            <th>Cookie</th><br>            <th>localStorage</th><br>            <th>sessionStorage</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>数据的生命期</td><br>            <td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><br>            <td>除非被清除，否则永久保存</td><br>            <td>仅在当前会话下有效，关闭页面或浏览器后被清除</td><br>        </tr><br>        <tr><br>            <td>存放数据大小</td><br>            <td>4K左右</td><br>            <td colspan=\"2\">一般为5MB</td><br>        </tr><br>        <tr><br>            <td>与服务器端通信</td><br>            <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td><br>            <td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><br>        </tr><br>        <tr><br>            <td>易用性</td><br>            <td>需要程序员自己封装，源生的Cookie接口不友好</td><br>            <td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td><br>        </tr><br>    </tbody><br></table>\n\n<h4 id=\"7-什么是跨域请求？其限制原因有哪些？\"><a href=\"#7-什么是跨域请求？其限制原因有哪些？\" class=\"headerlink\" title=\"7. 什么是跨域请求？其限制原因有哪些？\"></a>7. 什么是跨域请求？其限制原因有哪些？</h4><p><strong>答</strong>：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>\n<p>跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<h4 id=\"8-前端跨域请求解决方案都有哪些？\"><a href=\"#8-前端跨域请求解决方案都有哪些？\" class=\"headerlink\" title=\"8. 前端跨域请求解决方案都有哪些？\"></a>8. 前端跨域请求解决方案都有哪些？</h4><p><strong>答</strong>：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 <a href=\"https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md\" target=\"_blank\" rel=\"noopener\">前端跨域请求解决方案汇总</a> 或者 <a href=\"https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/\" target=\"_blank\" rel=\"noopener\">Joe’s Blog</a>.</p>\n<h4 id=\"9-iframe-的优缺点？\"><a href=\"#9-iframe-的优缺点？\" class=\"headerlink\" title=\"9. iframe 的优缺点？\"></a>9. iframe 的优缺点？</h4><p><strong>答</strong>：</p>\n<p>优点</p>\n<ol>\n<li>程序调入静态页面比较方便</li>\n<li>页面和程序分离</li>\n<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)</li>\n<li>能够原封不动的把嵌入的网页展现出来</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>会产生很多页面，不容易管理</li>\n<li>不容易打印</li>\n<li>浏览器的后退按钮无效</li>\n<li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用<br>iframe会不利于搜索引擎优化</li>\n<li>多数小型的移动设备无法完全显示框架，设备兼容性差</li>\n<li>多框架的页面会增加服务器的http请求，对于大型网站是不可取的</li>\n</ol>\n<h4 id=\"10-iframe-有哪些使用场景？\"><a href=\"#10-iframe-有哪些使用场景？\" class=\"headerlink\" title=\"10. iframe 有哪些使用场景？\"></a>10. iframe 有哪些使用场景？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>沙箱隔离。</li>\n<li>引用第三方内容。</li>\n<li>独立的带有交互的内容，比如幻灯片。</li>\n<li>需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。</li>\n</ol>\n<h4 id=\"11-HTML-的全局属性都有哪些？\"><a href=\"#11-HTML-的全局属性都有哪些？\" class=\"headerlink\" title=\"11. HTML 的全局属性都有哪些？\"></a>11. HTML 的全局属性都有哪些？</h4><p><strong>答</strong>：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。</p>\n<ul>\n<li><code>accesskey</code>:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按<code>alt + shift + a</code>可激活元素</li>\n<li><code>class</code>:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li>\n<li><code>contenteditable</code>: 指定元素内容是否可编辑</li>\n<li><code>contextmenu</code>: 自定义鼠标右键弹出菜单内容</li>\n<li><code>data-*</code>: 为元素增加自定义属性</li>\n<li><code>dir</code>: 设置元素文本方向</li>\n<li><code>draggable</code>: 设置元素是否可拖拽</li>\n<li><code>dropzone</code>: 设置元素拖放类型： copy, move, link</li>\n<li><code>hidden</code>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li>\n<li><code>id</code>: 元素id，文档内唯一</li>\n<li><code>lang</code>: 元素内容的的语言</li>\n<li><code>spellcheck</code>: 是否启动拼写和语法检查</li>\n<li><code>style</code>: 行内css样式</li>\n<li><code>tabindex</code>: 设置元素可以获得焦点，通过tab可以导航</li>\n<li><code>title</code>: 元素相关的建议信息</li>\n<li><code>translate</code>: 元素和子孙节点内容是否需要本地化</li>\n</ul>\n<h4 id=\"12-常见的浏览器内核有哪些？\"><a href=\"#12-常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"12. 常见的浏览器内核有哪些？\"></a>12. 常见的浏览器内核有哪些？</h4><p>浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。</p>\n<ul>\n<li>Trident 为 IE 内核，又称 MSHTML</li>\n<li>Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核</li>\n<li>Webkit 内核：Safari, Chrome 等</li>\n<li>Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支</li>\n<li>Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink</li>\n<li>移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident</li>\n</ul>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h4 id=\"1-ECMAScript-JavaScript-中都有那些数据类型？\"><a href=\"#1-ECMAScript-JavaScript-中都有那些数据类型？\" class=\"headerlink\" title=\"1. ECMAScript/JavaScript 中都有那些数据类型？\"></a>1. ECMAScript/JavaScript 中都有那些数据类型？</h4><p><strong>答</strong>：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.</p>\n<h4 id=\"2-把非数值转化为数值的函数都有哪些？\"><a href=\"#2-把非数值转化为数值的函数都有哪些？\" class=\"headerlink\" title=\"2. 把非数值转化为数值的函数都有哪些？\"></a>2. 把非数值转化为数值的函数都有哪些？</h4><p><strong>答</strong>：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p>\n<h4 id=\"3-JavaScript-中的-new-关键词做了什么？\"><a href=\"#3-JavaScript-中的-new-关键词做了什么？\" class=\"headerlink\" title=\"3. JavaScript 中的 new 关键词做了什么？\"></a>3. JavaScript 中的 new 关键词做了什么？</h4><ul>\n<li><strong>答</strong>：他做了五件事</li>\n</ul>\n<ol>\n<li>他生成了一个新对象。这个对象的类型只是一个普通的对象；</li>\n<li>他将新对象内部、不可访问的原型属性（例如：<code>__proto__</code>）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 <code>prototype</code> 属性）；</li>\n<li>他将 <code>this</code> 变量指向这个新生成的对象；</li>\n<li>他执行构造器函数，对于每个提及到 <code>this</code> 的地方使用新生成的对象执行；</li>\n<li>他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；</li>\n</ol>\n<h4 id=\"4-JavaScript-的六种继承类型？\"><a href=\"#4-JavaScript-的六种继承类型？\" class=\"headerlink\" title=\"4. JavaScript 的六种继承类型？\"></a>4. JavaScript 的六种继承类型？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();</span><br><span class=\"line\">let sub1 = new Sub();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 <code>fun</code> 函数，太多了就会影响性能；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val = val;</span><br><span class=\"line\">    this.fun = function()&#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this, val);   // 核心</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();    // 核心</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 拿到父类对象</span><br><span class=\"line\">let sup = new Super();</span><br><span class=\"line\">// 生孩子</span><br><span class=\"line\">let sub = beget(sup);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getSubObject(obj)&#123;</span><br><span class=\"line\">    // 创建新对象</span><br><span class=\"line\">    let clone = beget(obj); // 核心</span><br><span class=\"line\">    // 增强</span><br><span class=\"line\">    clone.attr1 = 1;</span><br><span class=\"line\">    clone.attr2 = 2;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sub = getSubObject(new Super());</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">Super.prototype.fun2 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proto = beget(Super.prototype); // 核心</span><br><span class=\"line\">proto.constructor = Sub;            // 核心</span><br><span class=\"line\">Sub.prototype = proto;              // 核心</span><br><span class=\"line\">let sub = new Sub();</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-箭头函数的适用规则？\"><a href=\"#5-箭头函数的适用规则？\" class=\"headerlink\" title=\"5. 箭头函数的适用规则？\"></a>5. 箭头函数的适用规则？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=&gt;箭头函数。</p>\n</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=&gt;箭头函数。</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=&gt;箭头函数。</li>\n<li>对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=&gt;函数语法。</li>\n</ul>\n<h4 id=\"6-为什么我们区别-LHS-和-RHS-那么重要？\"><a href=\"#6-为什么我们区别-LHS-和-RHS-那么重要？\" class=\"headerlink\" title=\"6. 为什么我们区别 LHS 和 RHS 那么重要？\"></a>6. 为什么我们区别 LHS 和 RHS 那么重要？</h4><p><strong>答</strong>：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。</p>\n<h4 id=\"7-如何区分声明和表达式？\"><a href=\"#7-如何区分声明和表达式？\" class=\"headerlink\" title=\"7. 如何区分声明和表达式？\"></a>7. 如何区分声明和表达式？</h4><p><strong>答</strong>：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。</p>\n<h4 id=\"8-IIFE-方式与变种？\"><a href=\"#8-IIFE-方式与变种？\" class=\"headerlink\" title=\"8. IIFE 方式与变种？\"></a>8. IIFE 方式与变种？</h4><p><strong>答</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;)()</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;())</span><br><span class=\"line\"><span class=\"comment\">// 3，用于 UMD 项目</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>)</span>&#123;</span><br><span class=\"line\">\tdef( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-请解释如下代码执行的结果？\"><a href=\"#9-请解释如下代码执行的结果？\" class=\"headerlink\" title=\"9. 请解释如下代码执行的结果？\"></a>9. 请解释如下代码执行的结果？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + &#123;&#125;; // &quot;[object Object]&quot;</span><br><span class=\"line\">&#123;&#125; + []; // 0</span><br></pre></td></tr></table></figure>\n<p><strong>答</strong>：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为””因此{}也会被强制转换为一个string：”[object Object]”。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。</p>\n<h4 id=\"10-什么是事件委托？\"><a href=\"#10-什么是事件委托？\" class=\"headerlink\" title=\"10. 什么是事件委托？\"></a>10. 什么是事件委托？</h4><p><strong>答</strong>：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。</p>\n<h4 id=\"11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\"><a href=\"#11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\" class=\"headerlink\" title=\"11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\"></a>11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；</li>\n<li>目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；</li>\n<li>冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>\n</ol>\n<h4 id=\"12-触摸事件都有哪些？\"><a href=\"#12-触摸事件都有哪些？\" class=\"headerlink\" title=\"12. 触摸事件都有哪些？\"></a>12. 触摸事件都有哪些？</h4><p><strong>答</strong>：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件</p>\n<ol>\n<li>touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。</li>\n<li>touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。</li>\n<li>touchend事件：当手指从屏幕上离开的时候触发。</li>\n</ol>\n<h4 id=\"13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\"><a href=\"#13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\" class=\"headerlink\" title=\"13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\"></a>13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。</li>\n<li>event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。<strong>特别说明：IE不支持！</strong></li>\n<li>screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。</li>\n<li>event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。<strong>特别说明：只有IE支持！</strong></li>\n</ol>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h4 id=\"1-什么是盒子模型？\"><a href=\"#1-什么是盒子模型？\" class=\"headerlink\" title=\"1. 什么是盒子模型？\"></a>1. 什么是盒子模型？</h4><p><strong>答</strong>：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p>\n<h4 id=\"2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"><a href=\"#2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\" class=\"headerlink\" title=\"2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"></a>2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？</h4><p><strong>答</strong>：使用 CSS <code>word-break</code> 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS <code>text-overflow</code> 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。</p>\n<h4 id=\"3-什么是-Data-URI？\"><a href=\"#3-什么是-Data-URI？\" class=\"headerlink\" title=\"3. 什么是 Data URI？\"></a>3. 什么是 Data URI？</h4><p><strong>答</strong>：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。</p>\n<h4 id=\"4-Data-URI-的好处和缺点都有哪些？\"><a href=\"#4-Data-URI-的好处和缺点都有哪些？\" class=\"headerlink\" title=\"4. Data URI 的好处和缺点都有哪些？\"></a>4. Data URI 的好处和缺点都有哪些？</h4><p><strong>答</strong>：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：</p>\n<ul>\n<li>当访问外部资源很麻烦或受限时。</li>\n<li>当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。</li>\n<li>当图片的体积太小，占用一个HTTP会话不是很值得时。</li>\n</ul>\n<p>Data URL也有一些不适用的场合：</p>\n<ul>\n<li>Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。</li>\n<li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。</li>\n</ul>\n<h4 id=\"5-内联元素和块级元素的区别？\"><a href=\"#5-内联元素和块级元素的区别？\" class=\"headerlink\" title=\"5. 内联元素和块级元素的区别？\"></a>5. 内联元素和块级元素的区别？</h4><p><strong>答</strong>：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。</p>\n<h4 id=\"6-CSS-Transform-Transition-Animation-属性的区别？\"><a href=\"#6-CSS-Transform-Transition-Animation-属性的区别？\" class=\"headerlink\" title=\"6. CSS Transform / Transition / Animation 属性的区别？\"></a>6. CSS Transform / Transition / Animation 属性的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；</li>\n<li>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；</li>\n<li>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；</li>\n</ul>\n<h4 id=\"7-position-布局方式都有哪些？\"><a href=\"#7-position-布局方式都有哪些？\" class=\"headerlink\" title=\"7. position 布局方式都有哪些？\"></a>7. position 布局方式都有哪些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li><strong>static</strong> - static 是默认值。任意 <code>position: static;</code> 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。</li>\n<li><strong>relative</strong> - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。</li>\n<li><strong>fixed</strong> - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。</li>\n<li><strong>absolute</strong> - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。</li>\n</ul>\n<p><em>记住一个“positioned”元素是指 position 值不是 static 的元素。</em></p>\n<h4 id=\"8-display-的属性都有哪些？\"><a href=\"#8-display-的属性都有哪些？\" class=\"headerlink\" title=\"8. display 的属性都有哪些？\"></a>8. display 的属性都有哪些？</h4><p><strong>答</strong>：块级元素默认值为 block，而行内元素为 inline。</p>\n<ul>\n<li><strong>block</strong> - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。</li>\n<li><strong>inline</strong> - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。</li>\n<li><strong>none</strong> - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。</li>\n</ul>\n<p>其他 display 值，例如 inline-block, list-item, table 和 flex。</p>\n<h2 id=\"Node-软件包管理\"><a href=\"#Node-软件包管理\" class=\"headerlink\" title=\"Node 软件包管理\"></a>Node 软件包管理</h2><h4 id=\"1-简述同步和异步之间的区别？\"><a href=\"#1-简述同步和异步之间的区别？\" class=\"headerlink\" title=\"1. 简述同步和异步之间的区别？\"></a>1. 简述同步和异步之间的区别？</h4><p><strong>答</strong>：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率</p>\n<h4 id=\"2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\"><a href=\"#2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\" class=\"headerlink\" title=\"2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 &quot;d3&quot;: &quot;^3.9.0&quot; 或者 &quot;d3&quot;: &quot;~3.9.0&quot;，请问 “^” 和 “~” 的含义分别是什么？\"></a>2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 <code>&quot;d3&quot;: &quot;^3.9.0&quot;</code> 或者 <code>&quot;d3&quot;: &quot;~3.9.0&quot;</code>，请问 “^” 和 “~” 的含义分别是什么？</h4><p><strong>答</strong>：根据 <a href=\"http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/\" target=\"_blank\" rel=\"noopener\">“npm install –save” No Longer Using Tildes</a> 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。</p>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><h4 id=\"3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"><a href=\"#3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\" class=\"headerlink\" title=\"3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"></a>3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？</h4><p><strong>答</strong>：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inIframe () &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return window.self !== window.top;</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>top 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h4 id=\"1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\"><a href=\"#1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\" class=\"headerlink\" title=\"1. HTTP/0.9 只有一个命令 GET, HTTP/1.0 引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\"></a>1. HTTP/0.9 只有一个命令 <code>GET</code>, HTTP/1.0 引入了 <code>POST</code> 命令和 <code>HEAD</code> 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？</h4><p><strong>答</strong>：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是</p>\n<ol>\n<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*‘来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</li>\n<li>HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li>\n<li>GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法</li>\n<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>\n<li>PUT：向指定资源位置上传其最新内容。</li>\n<li>DELETE：请求服务器删除Request-URI所标识的资源。</li>\n<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>\n<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</li>\n</ol>\n<h4 id=\"2-HTTP-状态码的主要类型有哪些？\"><a href=\"#2-HTTP-状态码的主要类型有哪些？\" class=\"headerlink\" title=\"2. HTTP 状态码的主要类型有哪些？\"></a>2. HTTP 状态码的主要类型有哪些？</h4><p><strong>答</strong>：状态代码的第一个数字代表当前响应的类型，主要为五类</p>\n<ol>\n<li>1xx消息——请求已被服务器接收，继续处理</li>\n<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>\n<li>3xx重定向——需要后续操作才能完成这一请求</li>\n<li>4xx请求错误——请求含有词法错误或者无法被执行</li>\n<li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li>\n</ol>\n<p>详细情况见 <a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" rel=\"noopener\">维基百科</a>。</p>\n<h4 id=\"3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"><a href=\"#3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\" class=\"headerlink\" title=\"3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"></a>3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><p><strong>答</strong>：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>\n<h4 id=\"4-HTTPS-建立连接的过程？\"><a href=\"#4-HTTPS-建立连接的过程？\" class=\"headerlink\" title=\"4. HTTPS 建立连接的过程？\"></a>4. HTTPS 建立连接的过程？</h4><p><strong>答</strong>：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。</p>\n<ol>\n<li>客户端发出握手请求 (Client Hello)，包含以下信息：<ul>\n<li>支持的协议版本，比如TLS 1.0</li>\n<li>一个客户端生成的随机数(random_1)，这个随机数既需要客户端保存又需要发送给服务器</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回复 (Server Hello)，包含以下信息：<ul>\n<li>确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信</li>\n<li>一个服务器生成的随机数 (random_2)</li>\n<li>确认使用的加密方法，比如RSA公钥加密</li>\n<li>服务器证书（其中包含服务器放入公钥）</li>\n<li>可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书</li>\n</ul>\n</li>\n<li>客户端回应，包含以下步骤：<ul>\n<li>验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开</li>\n<li>客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验</li>\n</ul>\n</li>\n<li>服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random_1 和 random_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验</li>\n</ul>\n</li>\n</ol>\n<p>在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。</p>\n<p>需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png&quot;\" alt=\"SSL 连接建立过程详解图\"></p>\n<h4 id=\"4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\"><a href=\"#4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\" class=\"headerlink\" title=\"4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\"></a>4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>\n<li>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</li>\n<li>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</li>\n<li>每一层的协议如下：<ul>\n<li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）</li>\n<li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li>\n<li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>\n<li>传输层：TCP、UDP、SPX</li>\n<li>会话层：NFS、SQL、NETBIOS、RPC</li>\n<li>表示层：JPEG、MPEG、ASII</li>\n<li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>\n</ul>\n</li>\n<li>每一层的作用如下：<ul>\n<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li>\n<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>\n<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>\n<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>\n<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>\n<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>\n<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-IP-地址的分类？\"><a href=\"#5-IP-地址的分类？\" class=\"headerlink\" title=\"5. IP 地址的分类？\"></a>5. IP 地址的分类？</h4><p><strong>答</strong>：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—<br>192.168.255.255 为 Internet 上保留地址用于内部。</p>\n<h4 id=\"6-互联网上各类协议的介绍？\"><a href=\"#6-互联网上各类协议的介绍？\" class=\"headerlink\" title=\"6. 互联网上各类协议的介绍？\"></a>6. 互联网上各类协议的介绍？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li>\n<li>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</li>\n<li>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</li>\n<li>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。</li>\n<li>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</li>\n</ol>\n<h4 id=\"7-TCP-和-UDP-的区别？\"><a href=\"#7-TCP-和-UDP-的区别？\" class=\"headerlink\" title=\"7. TCP 和 UDP 的区别？\"></a>7. TCP 和 UDP 的区别？</h4><p><strong>答</strong>：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP 协议</span><br><span class=\"line\">（1） FTP：定义了文件传输协议，使用21端口。</span><br><span class=\"line\">（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</span><br><span class=\"line\">（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</span><br><span class=\"line\">（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</span><br><span class=\"line\">（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</span><br><span class=\"line\">UDP协议</span><br><span class=\"line\">（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</span><br><span class=\"line\">（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</span><br><span class=\"line\">（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。</p>","more":"<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h4 id=\"1-DOCTYPE-作用？有哪些模式，模式怎么区分？\"><a href=\"#1-DOCTYPE-作用？有哪些模式，模式怎么区分？\" class=\"headerlink\" title=\"1. DOCTYPE 作用？有哪些模式，模式怎么区分？\"></a>1. DOCTYPE 作用？有哪些模式，模式怎么区分？</h4><p><strong>答</strong>：DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。为了能够很好地显示满足标准的页面，又能最大程度兼容不合法的HTML。 浏览器厂商一般会提供两种浏览器模式：</p>\n<ol>\n<li>标准模式（standards mode）：浏览器根据标准规约来渲染页面。</li>\n<li>混杂模式（quirks mode）：浏览器采用更加宽松的、向后兼容的方式来渲染页面。</li>\n</ol>\n<p>如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。</p>\n<p>1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）<br>2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）<br>3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）<br>4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）</p>\n<h4 id=\"2-常用的DOCTYPE声明有几种？\"><a href=\"#2-常用的DOCTYPE声明有几种？\" class=\"headerlink\" title=\"2. 常用的DOCTYPE声明有几种？\"></a>2. 常用的DOCTYPE声明有几种？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>HTML5 <code>&lt;!DOCTYPE html&gt;</code></li>\n<li>HTML 4.01 Strict <code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li>\n<li>HTML 4.01 Transitional</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-什么是-HTML-语义化，为什么要语义化？\"><a href=\"#3-什么是-HTML-语义化，为什么要语义化？\" class=\"headerlink\" title=\"3. 什么是 HTML 语义化，为什么要语义化？\"></a>3. 什么是 HTML 语义化，为什么要语义化？</h4><p><strong>答</strong>：语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。语义化的好处包含</p>\n<ol>\n<li>有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重</li>\n<li>语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构</li>\n<li>方便其他设备的解析</li>\n<li>便于团队开发和维护</li>\n</ol>\n<h4 id=\"4-行内元素、块级元素、空-void-元素都有那些？\"><a href=\"#4-行内元素、块级元素、空-void-元素都有那些？\" class=\"headerlink\" title=\"4. 行内元素、块级元素、空(void)元素都有那些？\"></a>4. 行内元素、块级元素、空(void)元素都有那些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</li>\n<li>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</li>\n<li>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</li>\n</ul>\n<h4 id=\"5-简述一下-src-与-href-的区别？\"><a href=\"#5-简述一下-src-与-href-的区别？\" class=\"headerlink\" title=\"5. 简述一下 src 与 href 的区别？\"></a>5. 简述一下 src 与 href 的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接</li>\n<li>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</li>\n</ul>\n<h4 id=\"6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\"><a href=\"#6-请描述一下-HTML-本地化存储都有哪些方案，以及它们之间的区别？\" class=\"headerlink\" title=\"6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？\"></a>6. 请描述一下 HTML 本地化存储都有哪些方案，以及它们之间的区别？</h4><p><strong>答</strong>：Cookie, localStorage 和 sessionStorage.</p>\n<ol>\n<li>Cookie是存储在客户端的小型文本文件，可以包含若干键值对，每个键值对可以设置过期时间（默认过期时间为关闭浏览器时）。 Cookie会在每次发送HTTP请求时附加到Cookie头字段，服务器以此得知用户所处的状态。 在HTTP标准中，规定Cookie至少要有4K，至少支持300项Cookie，每个域名至少支持20项。</li>\n<li>LocalStorage/SessionStorage提供的存储也是基于字符串的键值对。可以通过setItem，getItem来访问其中的存储项，两者均为 HTML5 标准中新加入的技术，在存储时限上有差别。</li>\n</ol>\n<p>以下为三者之间的区别：</p>\n<table><br>    <thead><br>        <tr><br>            <th>特性</th><br>            <th>Cookie</th><br>            <th>localStorage</th><br>            <th>sessionStorage</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>数据的生命期</td><br>            <td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><br>            <td>除非被清除，否则永久保存</td><br>            <td>仅在当前会话下有效，关闭页面或浏览器后被清除</td><br>        </tr><br>        <tr><br>            <td>存放数据大小</td><br>            <td>4K左右</td><br>            <td colspan=\"2\">一般为5MB</td><br>        </tr><br>        <tr><br>            <td>与服务器端通信</td><br>            <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td><br>            <td colspan=\"2\">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><br>        </tr><br>        <tr><br>            <td>易用性</td><br>            <td>需要程序员自己封装，源生的Cookie接口不友好</td><br>            <td colspan=\"2\">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td><br>        </tr><br>    </tbody><br></table>\n\n<h4 id=\"7-什么是跨域请求？其限制原因有哪些？\"><a href=\"#7-什么是跨域请求？其限制原因有哪些？\" class=\"headerlink\" title=\"7. 什么是跨域请求？其限制原因有哪些？\"></a>7. 什么是跨域请求？其限制原因有哪些？</h4><p><strong>答</strong>：首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>\n<p>跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<h4 id=\"8-前端跨域请求解决方案都有哪些？\"><a href=\"#8-前端跨域请求解决方案都有哪些？\" class=\"headerlink\" title=\"8. 前端跨域请求解决方案都有哪些？\"></a>8. 前端跨域请求解决方案都有哪些？</h4><p><strong>答</strong>：现主流的解决方案包括： document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS 等等。详细描述见 <a href=\"https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-06-13-Cross-Origin-Resource-Sharing-Solutions.md\" target=\"_blank\" rel=\"noopener\">前端跨域请求解决方案汇总</a> 或者 <a href=\"https://hijiangtao.github.io/2017/06/13/Cross-Origin-Resource-Sharing-Solutions/\" target=\"_blank\" rel=\"noopener\">Joe’s Blog</a>.</p>\n<h4 id=\"9-iframe-的优缺点？\"><a href=\"#9-iframe-的优缺点？\" class=\"headerlink\" title=\"9. iframe 的优缺点？\"></a>9. iframe 的优缺点？</h4><p><strong>答</strong>：</p>\n<p>优点</p>\n<ol>\n<li>程序调入静态页面比较方便</li>\n<li>页面和程序分离</li>\n<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)</li>\n<li>能够原封不动的把嵌入的网页展现出来</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>会产生很多页面，不容易管理</li>\n<li>不容易打印</li>\n<li>浏览器的后退按钮无效</li>\n<li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用<br>iframe会不利于搜索引擎优化</li>\n<li>多数小型的移动设备无法完全显示框架，设备兼容性差</li>\n<li>多框架的页面会增加服务器的http请求，对于大型网站是不可取的</li>\n</ol>\n<h4 id=\"10-iframe-有哪些使用场景？\"><a href=\"#10-iframe-有哪些使用场景？\" class=\"headerlink\" title=\"10. iframe 有哪些使用场景？\"></a>10. iframe 有哪些使用场景？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>沙箱隔离。</li>\n<li>引用第三方内容。</li>\n<li>独立的带有交互的内容，比如幻灯片。</li>\n<li>需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。</li>\n</ol>\n<h4 id=\"11-HTML-的全局属性都有哪些？\"><a href=\"#11-HTML-的全局属性都有哪些？\" class=\"headerlink\" title=\"11. HTML 的全局属性都有哪些？\"></a>11. HTML 的全局属性都有哪些？</h4><p><strong>答</strong>：全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，尽管属性可能对某些元素没有影响。</p>\n<ul>\n<li><code>accesskey</code>:设置快捷键，提供快速访问元素如<a href=\"#\" accesskey=\"a\">aaa</a>在windows下的firefox中按<code>alt + shift + a</code>可激活元素</li>\n<li><code>class</code>:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li>\n<li><code>contenteditable</code>: 指定元素内容是否可编辑</li>\n<li><code>contextmenu</code>: 自定义鼠标右键弹出菜单内容</li>\n<li><code>data-*</code>: 为元素增加自定义属性</li>\n<li><code>dir</code>: 设置元素文本方向</li>\n<li><code>draggable</code>: 设置元素是否可拖拽</li>\n<li><code>dropzone</code>: 设置元素拖放类型： copy, move, link</li>\n<li><code>hidden</code>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li>\n<li><code>id</code>: 元素id，文档内唯一</li>\n<li><code>lang</code>: 元素内容的的语言</li>\n<li><code>spellcheck</code>: 是否启动拼写和语法检查</li>\n<li><code>style</code>: 行内css样式</li>\n<li><code>tabindex</code>: 设置元素可以获得焦点，通过tab可以导航</li>\n<li><code>title</code>: 元素相关的建议信息</li>\n<li><code>translate</code>: 元素和子孙节点内容是否需要本地化</li>\n</ul>\n<h4 id=\"12-常见的浏览器内核有哪些？\"><a href=\"#12-常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"12. 常见的浏览器内核有哪些？\"></a>12. 常见的浏览器内核有哪些？</h4><p>浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit，此处指浏览器内核。</p>\n<ul>\n<li>Trident 为 IE 内核，又称 MSHTML</li>\n<li>Gecko 内核：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核</li>\n<li>Webkit 内核：Safari, Chrome 等</li>\n<li>Blink 内核：Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支</li>\n<li>Presto 内核：Presto 是挪威产浏览器 opera 的 “前任” 内核，最新的 opera 浏览器内核现为 Blink</li>\n<li>移动端：目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident</li>\n</ul>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h4 id=\"1-ECMAScript-JavaScript-中都有那些数据类型？\"><a href=\"#1-ECMAScript-JavaScript-中都有那些数据类型？\" class=\"headerlink\" title=\"1. ECMAScript/JavaScript 中都有那些数据类型？\"></a>1. ECMAScript/JavaScript 中都有那些数据类型？</h4><p><strong>答</strong>：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.</p>\n<h4 id=\"2-把非数值转化为数值的函数都有哪些？\"><a href=\"#2-把非数值转化为数值的函数都有哪些？\" class=\"headerlink\" title=\"2. 把非数值转化为数值的函数都有哪些？\"></a>2. 把非数值转化为数值的函数都有哪些？</h4><p><strong>答</strong>：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p>\n<h4 id=\"3-JavaScript-中的-new-关键词做了什么？\"><a href=\"#3-JavaScript-中的-new-关键词做了什么？\" class=\"headerlink\" title=\"3. JavaScript 中的 new 关键词做了什么？\"></a>3. JavaScript 中的 new 关键词做了什么？</h4><ul>\n<li><strong>答</strong>：他做了五件事</li>\n</ul>\n<ol>\n<li>他生成了一个新对象。这个对象的类型只是一个普通的对象；</li>\n<li>他将新对象内部、不可访问的原型属性（例如：<code>__proto__</code>）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 <code>prototype</code> 属性）；</li>\n<li>他将 <code>this</code> 变量指向这个新生成的对象；</li>\n<li>他执行构造器函数，对于每个提及到 <code>this</code> 的地方使用新生成的对象执行；</li>\n<li>他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；</li>\n</ol>\n<h4 id=\"4-JavaScript-的六种继承类型？\"><a href=\"#4-JavaScript-的六种继承类型？\" class=\"headerlink\" title=\"4. JavaScript 的六种继承类型？\"></a>4. JavaScript 的六种继承类型？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();</span><br><span class=\"line\">let sub1 = new Sub();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 <code>fun</code> 函数，太多了就会影响性能；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super(val)&#123;</span><br><span class=\"line\">    this.val = val;</span><br><span class=\"line\">    this.fun = function()&#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub(val)&#123;</span><br><span class=\"line\">    Super.call(this, val);   // 核心</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = new Super();    // 核心</span><br><span class=\"line\">let sub1 = new Sub(1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 拿到父类对象</span><br><span class=\"line\">let sup = new Super();</span><br><span class=\"line\">// 生孩子</span><br><span class=\"line\">let sub = beget(sup);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getSubObject(obj)&#123;</span><br><span class=\"line\">    // 创建新对象</span><br><span class=\"line\">    let clone = beget(obj); // 核心</span><br><span class=\"line\">    // 增强</span><br><span class=\"line\">    clone.attr1 = 1;</span><br><span class=\"line\">    clone.attr2 = 2;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sub = getSubObject(new Super());</span><br></pre></td></tr></table></figure>\n<ul>\n<li>寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function beget(obj)&#123;   // 生孩子函数 beget</span><br><span class=\"line\">    let F = function()&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Super()&#123;</span><br><span class=\"line\">    // 只在此处声明基本属性和引用属性</span><br><span class=\"line\">    this.val = 1;</span><br><span class=\"line\">    this.arr = [1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  在此处声明函数</span><br><span class=\"line\">Super.prototype.fun1 = function()&#123;&#125;;</span><br><span class=\"line\">Super.prototype.fun2 = function()&#123;&#125;;</span><br><span class=\"line\">function Sub()&#123;</span><br><span class=\"line\">    Super.call(this);   // 核心</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proto = beget(Super.prototype); // 核心</span><br><span class=\"line\">proto.constructor = Sub;            // 核心</span><br><span class=\"line\">Sub.prototype = proto;              // 核心</span><br><span class=\"line\">let sub = new Sub();</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-箭头函数的适用规则？\"><a href=\"#5-箭头函数的适用规则？\" class=\"headerlink\" title=\"5. 箭头函数的适用规则？\"></a>5. 箭头函数的适用规则？</h4><ul>\n<li><p><strong>答</strong>：</p>\n</li>\n<li><p>如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=&gt;箭头函数。</p>\n</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=&gt;箭头函数。</li>\n<li>如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=&gt;箭头函数。</li>\n<li>对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=&gt;函数语法。</li>\n</ul>\n<h4 id=\"6-为什么我们区别-LHS-和-RHS-那么重要？\"><a href=\"#6-为什么我们区别-LHS-和-RHS-那么重要？\" class=\"headerlink\" title=\"6. 为什么我们区别 LHS 和 RHS 那么重要？\"></a>6. 为什么我们区别 LHS 和 RHS 那么重要？</h4><p><strong>答</strong>：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。</p>\n<h4 id=\"7-如何区分声明和表达式？\"><a href=\"#7-如何区分声明和表达式？\" class=\"headerlink\" title=\"7. 如何区分声明和表达式？\"></a>7. 如何区分声明和表达式？</h4><p><strong>答</strong>：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。</p>\n<h4 id=\"8-IIFE-方式与变种？\"><a href=\"#8-IIFE-方式与变种？\" class=\"headerlink\" title=\"8. IIFE 方式与变种？\"></a>8. IIFE 方式与变种？</h4><p><strong>答</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;)()</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; .. &#125;())</span><br><span class=\"line\"><span class=\"comment\">// 3，用于 UMD 项目</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>)</span>&#123;</span><br><span class=\"line\">\tdef( <span class=\"built_in\">window</span> );</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-请解释如下代码执行的结果？\"><a href=\"#9-请解释如下代码执行的结果？\" class=\"headerlink\" title=\"9. 请解释如下代码执行的结果？\"></a>9. 请解释如下代码执行的结果？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + &#123;&#125;; // &quot;[object Object]&quot;</span><br><span class=\"line\">&#123;&#125; + []; // 0</span><br></pre></td></tr></table></figure>\n<p><strong>答</strong>：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为””因此{}也会被强制转换为一个string：”[object Object]”。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。</p>\n<h4 id=\"10-什么是事件委托？\"><a href=\"#10-什么是事件委托？\" class=\"headerlink\" title=\"10. 什么是事件委托？\"></a>10. 什么是事件委托？</h4><p><strong>答</strong>：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。事件委托的好处包括：动态绑定事件与减少内存消耗。</p>\n<h4 id=\"11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\"><a href=\"#11-JavaScript-与-HTML-之间交互的事件模型分为几个阶段？\" class=\"headerlink\" title=\"11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？\"></a>11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；</li>\n<li>目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；</li>\n<li>冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>\n</ol>\n<h4 id=\"12-触摸事件都有哪些？\"><a href=\"#12-触摸事件都有哪些？\" class=\"headerlink\" title=\"12. 触摸事件都有哪些？\"></a>12. 触摸事件都有哪些？</h4><p><strong>答</strong>：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件</p>\n<ol>\n<li>touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。</li>\n<li>touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。</li>\n<li>touchend事件：当手指从屏幕上离开的时候触发。</li>\n</ol>\n<h4 id=\"13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\"><a href=\"#13-事件对象的-clientX-offsetX-screenX-pageX-有什么区别？\" class=\"headerlink\" title=\"13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？\"></a>13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。</li>\n<li>event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。<strong>特别说明：IE不支持！</strong></li>\n<li>screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。</li>\n<li>event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。<strong>特别说明：只有IE支持！</strong></li>\n</ol>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h4 id=\"1-什么是盒子模型？\"><a href=\"#1-什么是盒子模型？\" class=\"headerlink\" title=\"1. 什么是盒子模型？\"></a>1. 什么是盒子模型？</h4><p><strong>答</strong>：在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p>\n<h4 id=\"2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"><a href=\"#2-在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\" class=\"headerlink\" title=\"2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？\"></a>2. 在一些场景中文本内容不受控制过长超出，有哪些处理超长文本的方法？</h4><p><strong>答</strong>：使用 CSS <code>word-break</code> 属性（CSS 属性 word-break 指定了怎样在单词内断行的规则）或者 CSS <code>text-overflow</code> 属性（text-overflow CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）。</p>\n<h4 id=\"3-什么是-Data-URI？\"><a href=\"#3-什么是-Data-URI？\" class=\"headerlink\" title=\"3. 什么是 Data URI？\"></a>3. 什么是 Data URI？</h4><p><strong>答</strong>：Data URI 是一种提供让外置资源的直接内嵌在页面中的方案。这种技术允许我们只需单次 HTTP 请求即可获取所有需要引用的图片与样式资源，并因无需多次请求资源而变的高效。</p>\n<h4 id=\"4-Data-URI-的好处和缺点都有哪些？\"><a href=\"#4-Data-URI-的好处和缺点都有哪些？\" class=\"headerlink\" title=\"4. Data URI 的好处和缺点都有哪些？\"></a>4. Data URI 的好处和缺点都有哪些？</h4><p><strong>答</strong>：在 img 方式引用图片时，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，其中好处包括：</p>\n<ul>\n<li>当访问外部资源很麻烦或受限时。</li>\n<li>当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。</li>\n<li>当图片的体积太小，占用一个HTTP会话不是很值得时。</li>\n</ul>\n<p>Data URL也有一些不适用的场合：</p>\n<ul>\n<li>Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。</li>\n<li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。</li>\n</ul>\n<h4 id=\"5-内联元素和块级元素的区别？\"><a href=\"#5-内联元素和块级元素的区别？\" class=\"headerlink\" title=\"5. 内联元素和块级元素的区别？\"></a>5. 内联元素和块级元素的区别？</h4><p><strong>答</strong>：块级元素和内联元素对于CSS调用的不同效果 - 块级元素默认独占一行，默认宽度为父元素的100%，可以设置宽度、高度，外边距、内边距；内联元素默认不独占一行，宽度随着内容自动撑，无法设置宽度、高度、外边距。可以设置内边距。内联元素要设置宽高必须用css设置块显示。</p>\n<h4 id=\"6-CSS-Transform-Transition-Animation-属性的区别？\"><a href=\"#6-CSS-Transform-Transition-Animation-属性的区别？\" class=\"headerlink\" title=\"6. CSS Transform / Transition / Animation 属性的区别？\"></a>6. CSS Transform / Transition / Animation 属性的区别？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形；</li>\n<li>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线；</li>\n<li>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果；</li>\n</ul>\n<h4 id=\"7-position-布局方式都有哪些？\"><a href=\"#7-position-布局方式都有哪些？\" class=\"headerlink\" title=\"7. position 布局方式都有哪些？\"></a>7. position 布局方式都有哪些？</h4><p><strong>答</strong>：</p>\n<ul>\n<li><strong>static</strong> - static 是默认值。任意 <code>position: static;</code> 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。</li>\n<li><strong>relative</strong> - relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。</li>\n<li><strong>fixed</strong> - 一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。</li>\n<li><strong>absolute</strong> - absolute 与 fixed 的表现类似，它相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。</li>\n</ul>\n<p><em>记住一个“positioned”元素是指 position 值不是 static 的元素。</em></p>\n<h4 id=\"8-display-的属性都有哪些？\"><a href=\"#8-display-的属性都有哪些？\" class=\"headerlink\" title=\"8. display 的属性都有哪些？\"></a>8. display 的属性都有哪些？</h4><p><strong>答</strong>：块级元素默认值为 block，而行内元素为 inline。</p>\n<ul>\n<li><strong>block</strong> - div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。</li>\n<li><strong>inline</strong> - 一个行内元素可以在段落中包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素。</li>\n<li><strong>none</strong> - 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。</li>\n</ul>\n<p>其他 display 值，例如 inline-block, list-item, table 和 flex。</p>\n<h2 id=\"Node-软件包管理\"><a href=\"#Node-软件包管理\" class=\"headerlink\" title=\"Node 软件包管理\"></a>Node 软件包管理</h2><h4 id=\"1-简述同步和异步之间的区别？\"><a href=\"#1-简述同步和异步之间的区别？\" class=\"headerlink\" title=\"1. 简述同步和异步之间的区别？\"></a>1. 简述同步和异步之间的区别？</h4><p><strong>答</strong>：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率</p>\n<h4 id=\"2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\"><a href=\"#2-在每个-package-json-的-dependency-中都会有很多软件名以及随之跟上的版本号，例如-quot-d3-quot-quot-3-9-0-quot-或者-quot-d3-quot-quot-3-9-0-quot-，请问-“-”-和-“-”-的含义分别是什么？\" class=\"headerlink\" title=\"2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 &quot;d3&quot;: &quot;^3.9.0&quot; 或者 &quot;d3&quot;: &quot;~3.9.0&quot;，请问 “^” 和 “~” 的含义分别是什么？\"></a>2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 <code>&quot;d3&quot;: &quot;^3.9.0&quot;</code> 或者 <code>&quot;d3&quot;: &quot;~3.9.0&quot;</code>，请问 “^” 和 “~” 的含义分别是什么？</h4><p><strong>答</strong>：根据 <a href=\"http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/\" target=\"_blank\" rel=\"noopener\">“npm install –save” No Longer Using Tildes</a> 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。</p>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><h4 id=\"3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"><a href=\"#3-如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\" class=\"headerlink\" title=\"3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？\"></a>3. 如何识别网页是否正在iframe中加载或直接进入浏览器窗口？</h4><p><strong>答</strong>：由于same origin policy，浏览器可以阻止访问window.top。 IE也发生错误。以下是工作代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inIframe () &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return window.self !== window.top;</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>top 和 self 都是 window 对象(连同 parent )，所以能看到你的窗口是否是顶窗。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h4 id=\"1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\"><a href=\"#1-HTTP-0-9-只有一个命令-GET-HTTP-1-0-引入了-POST-命令和-HEAD-命令，丰富了浏览器与服务器的互动手段。请问-HTTP-1-1-的请求方法有哪些？\" class=\"headerlink\" title=\"1. HTTP/0.9 只有一个命令 GET, HTTP/1.0 引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？\"></a>1. HTTP/0.9 只有一个命令 <code>GET</code>, HTTP/1.0 引入了 <code>POST</code> 命令和 <code>HEAD</code> 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？</h4><p><strong>答</strong>：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是</p>\n<ol>\n<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*‘来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</li>\n<li>HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li>\n<li>GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法</li>\n<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>\n<li>PUT：向指定资源位置上传其最新内容。</li>\n<li>DELETE：请求服务器删除Request-URI所标识的资源。</li>\n<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>\n<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</li>\n</ol>\n<h4 id=\"2-HTTP-状态码的主要类型有哪些？\"><a href=\"#2-HTTP-状态码的主要类型有哪些？\" class=\"headerlink\" title=\"2. HTTP 状态码的主要类型有哪些？\"></a>2. HTTP 状态码的主要类型有哪些？</h4><p><strong>答</strong>：状态代码的第一个数字代表当前响应的类型，主要为五类</p>\n<ol>\n<li>1xx消息——请求已被服务器接收，继续处理</li>\n<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>\n<li>3xx重定向——需要后续操作才能完成这一请求</li>\n<li>4xx请求错误——请求含有词法错误或者无法被执行</li>\n<li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li>\n</ol>\n<p>详细情况见 <a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" rel=\"noopener\">维基百科</a>。</p>\n<h4 id=\"3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"><a href=\"#3-TCP-协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\" class=\"headerlink\" title=\"3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？\"></a>3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><p><strong>答</strong>：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>\n<h4 id=\"4-HTTPS-建立连接的过程？\"><a href=\"#4-HTTPS-建立连接的过程？\" class=\"headerlink\" title=\"4. HTTPS 建立连接的过程？\"></a>4. HTTPS 建立连接的过程？</h4><p><strong>答</strong>：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。</p>\n<ol>\n<li>客户端发出握手请求 (Client Hello)，包含以下信息：<ul>\n<li>支持的协议版本，比如TLS 1.0</li>\n<li>一个客户端生成的随机数(random_1)，这个随机数既需要客户端保存又需要发送给服务器</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回复 (Server Hello)，包含以下信息：<ul>\n<li>确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信</li>\n<li>一个服务器生成的随机数 (random_2)</li>\n<li>确认使用的加密方法，比如RSA公钥加密</li>\n<li>服务器证书（其中包含服务器放入公钥）</li>\n<li>可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书</li>\n</ul>\n</li>\n<li>客户端回应，包含以下步骤：<ul>\n<li>验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开</li>\n<li>客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验</li>\n</ul>\n</li>\n<li>服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random_1 和 random_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验</li>\n</ul>\n</li>\n</ol>\n<p>在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。</p>\n<p>需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。</p>\n<p><img src=\"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png&quot;\" alt=\"SSL 连接建立过程详解图\"></p>\n<h4 id=\"4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\"><a href=\"#4-OSI，TCP-IP，五层协议的体系结构，以及各层协议？\" class=\"headerlink\" title=\"4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？\"></a>4. OSI，TCP/IP，五层协议的体系结构，以及各层协议？</h4><p><strong>答</strong>：</p>\n<ul>\n<li>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>\n<li>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</li>\n<li>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</li>\n<li>每一层的协议如下：<ul>\n<li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）</li>\n<li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li>\n<li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>\n<li>传输层：TCP、UDP、SPX</li>\n<li>会话层：NFS、SQL、NETBIOS、RPC</li>\n<li>表示层：JPEG、MPEG、ASII</li>\n<li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>\n</ul>\n</li>\n<li>每一层的作用如下：<ul>\n<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li>\n<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>\n<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>\n<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>\n<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>\n<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>\n<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-IP-地址的分类？\"><a href=\"#5-IP-地址的分类？\" class=\"headerlink\" title=\"5. IP 地址的分类？\"></a>5. IP 地址的分类？</h4><p><strong>答</strong>：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—<br>192.168.255.255 为 Internet 上保留地址用于内部。</p>\n<h4 id=\"6-互联网上各类协议的介绍？\"><a href=\"#6-互联网上各类协议的介绍？\" class=\"headerlink\" title=\"6. 互联网上各类协议的介绍？\"></a>6. 互联网上各类协议的介绍？</h4><p><strong>答</strong>：</p>\n<ol>\n<li>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li>\n<li>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</li>\n<li>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</li>\n<li>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。</li>\n<li>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</li>\n</ol>\n<h4 id=\"7-TCP-和-UDP-的区别？\"><a href=\"#7-TCP-和-UDP-的区别？\" class=\"headerlink\" title=\"7. TCP 和 UDP 的区别？\"></a>7. TCP 和 UDP 的区别？</h4><p><strong>答</strong>：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP 协议</span><br><span class=\"line\">（1） FTP：定义了文件传输协议，使用21端口。</span><br><span class=\"line\">（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</span><br><span class=\"line\">（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</span><br><span class=\"line\">（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</span><br><span class=\"line\">（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</span><br><span class=\"line\">UDP协议</span><br><span class=\"line\">（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</span><br><span class=\"line\">（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</span><br><span class=\"line\">（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjydskrrz0006hvs64c0obxqe","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrs8000dhvs6zl4cf7km"},{"post_id":"cjydskrro0001hvs6fkgn0320","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrse000hhvs6sf2fawxf"},{"post_id":"cjydskrrt0002hvs6b3z21vfb","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsh000khvs6myyk4lmj"},{"post_id":"cjydskrs7000chvs68ssmq5zw","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsk000phvs63jgyncn4"},{"post_id":"cjydskrry0005hvs6f0m0t06o","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsm000shvs6gueu8l04"},{"post_id":"cjydskrsf000jhvs6a608txmu","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrso000whvs6lor2skzh"},{"post_id":"cjydskrsj000ohvs6620vt17i","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsp000zhvs6m172i4q0"},{"post_id":"cjydskrsl000rhvs602ygwqbe","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsr0013hvs6bxffon0z"},{"post_id":"cjydskrsb000ghvs6n0zwtn9l","category_id":"cjydskrsj000nhvs6e9788n5p","_id":"cjydskrss0016hvs6eynqc303"},{"post_id":"cjydskrso000yhvs6whn19dpy","category_id":"cjydskrsj000nhvs6e9788n5p","_id":"cjydskrsu0018hvs6jo2ce28h"},{"post_id":"cjydskrsr0015hvs6dogyypyq","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsw001ehvs64dteql4y"},{"post_id":"cjydskrss0017hvs6y2c6c3s9","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsy001ihvs6343hgdp4"},{"post_id":"cjydskrsu001bhvs66ypitors","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrsz001lhvs6smzzxw6a"},{"post_id":"cjydskrsv001dhvs6gl20t86m","category_id":"cjydskrsj000nhvs6e9788n5p","_id":"cjydskrt1001qhvs6mhwnvk2o"},{"post_id":"cjydskrt0001phvs6vr5hmf2j","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskrt4001vhvs6lrx8e8n8"},{"post_id":"cjydskrsx001hhvs6sg8esgwr","category_id":"cjydskrt0001nhvs646maig0q","_id":"cjydskrt5001yhvs66vxx4v48"},{"post_id":"cjydskst60023hvs6uruyhyh3","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskstf002chvs61ief8c5k"},{"post_id":"cjydskst80025hvs64r2h20ul","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskstg002fhvs6kf8iozew"},{"post_id":"cjydskstc0028hvs6lb6648ky","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydsksth002ihvs6fg686r6z"},{"post_id":"cjydskste002bhvs69mgxp84s","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskstj002lhvs604b3960s"},{"post_id":"cjydskstf002ehvs64o2ij9rw","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskstk002ohvs6mn1souc1"},{"post_id":"cjydsksth002hhvs64dkjo4nx","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskstl002phvs64i79whsv"},{"post_id":"cjydsksti002khvs6zu5bpktv","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydskstm002shvs6f56l8gqt"},{"post_id":"cjydsksye002vhvs6jcuj8uhi","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydsksyi002zhvs6pweiz0g0"},{"post_id":"cjydsksyf002whvs6u4zm3avj","category_id":"cjydskrrv0003hvs6bcyu9vdu","_id":"cjydsksyi0030hvs6h0mbhuqf"}],"PostTag":[{"post_id":"cjydskrro0001hvs6fkgn0320","tag_id":"cjydskrry0004hvs64ptaehsj","_id":"cjydskrs3000ahvs64ckp0f54"},{"post_id":"cjydskrrt0002hvs6b3z21vfb","tag_id":"cjydskrs20009hvs68uh4iwf1","_id":"cjydskrse000ihvs6ii7rb3bb"},{"post_id":"cjydskrs7000chvs68ssmq5zw","tag_id":"cjydskrry0004hvs64ptaehsj","_id":"cjydskrsh000lhvs6s1ptm6gr"},{"post_id":"cjydskrry0005hvs6f0m0t06o","tag_id":"cjydskrs20009hvs68uh4iwf1","_id":"cjydskrsk000qhvs6yxbaltzw"},{"post_id":"cjydskrsj000ohvs6620vt17i","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydskrsn000uhvs6fx7n37ak"},{"post_id":"cjydskrrz0006hvs64c0obxqe","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydskrso000xhvs6uje9cfut"},{"post_id":"cjydskrsl000rhvs602ygwqbe","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydskrsq0010hvs67dv4z5n6"},{"post_id":"cjydskrs00007hvs6gar59v6a","tag_id":"cjydskrsn000thvs62pb9x1ne","_id":"cjydskrsr0014hvs6q1vsm0d8"},{"post_id":"cjydskrsr0015hvs6dogyypyq","tag_id":"cjydskrry0004hvs64ptaehsj","_id":"cjydskrsu001ahvs6rb5c9l2w"},{"post_id":"cjydskrs4000bhvs647ofhpxg","tag_id":"cjydskrsq0011hvs6tsile6ft","_id":"cjydskrsv001chvs6fzw7dml2"},{"post_id":"cjydskrss0017hvs6y2c6c3s9","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydskrsx001ghvs6nzaf45yg"},{"post_id":"cjydskrsu001bhvs66ypitors","tag_id":"cjydskrry0004hvs64ptaehsj","_id":"cjydskrsy001jhvs615enq01d"},{"post_id":"cjydskrsb000ghvs6n0zwtn9l","tag_id":"cjydskrsu0019hvs6ixgdqj8h","_id":"cjydskrt0001ohvs6yk2hvzr0"},{"post_id":"cjydskrsv001dhvs6gl20t86m","tag_id":"cjydskrsu0019hvs6ixgdqj8h","_id":"cjydskrt2001rhvs6tspits2o"},{"post_id":"cjydskrsf000jhvs6a608txmu","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydskrt3001thvs6836l2btj"},{"post_id":"cjydskrt0001phvs6vr5hmf2j","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydskrt4001uhvs6o47y03c6"},{"post_id":"cjydskrsn000vhvs6y6wip0tu","tag_id":"cjydskrsz001mhvs6inoodyhg","_id":"cjydskrt5001xhvs6wme7eqp3"},{"post_id":"cjydskrso000yhvs6whn19dpy","tag_id":"cjydskrsu0019hvs6ixgdqj8h","_id":"cjydskrt5001zhvs6tjkq2td6"},{"post_id":"cjydskrsq0012hvs6prq6kpx4","tag_id":"cjydskrt5001whvs6vkznf8qb","_id":"cjydskrt60021hvs6wq6qy22q"},{"post_id":"cjydskrsx001hhvs6sg8esgwr","tag_id":"cjydskrt50020hvs62mwfombq","_id":"cjydskrt60022hvs6f9my0r9m"},{"post_id":"cjydskst60023hvs6uruyhyh3","tag_id":"cjydskrsz001mhvs6inoodyhg","_id":"cjydskstb0027hvs6bol19uxj"},{"post_id":"cjydskst80025hvs64r2h20ul","tag_id":"cjydskrt5001whvs6vkznf8qb","_id":"cjydskste002ahvs6wnl20hub"},{"post_id":"cjydskstc0028hvs6lb6648ky","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydskstf002dhvs6i20bxzne"},{"post_id":"cjydskste002bhvs69mgxp84s","tag_id":"cjydskrry0004hvs64ptaehsj","_id":"cjydskstg002ghvs67h14t2ii"},{"post_id":"cjydskstf002ehvs64o2ij9rw","tag_id":"cjydskrs20009hvs68uh4iwf1","_id":"cjydsksti002jhvs645lhnosy"},{"post_id":"cjydskstj002nhvs6zfser86l","tag_id":"cjydskrry0004hvs64ptaehsj","_id":"cjydskstl002qhvs6d0pj523r"},{"post_id":"cjydsksth002hhvs64dkjo4nx","tag_id":"cjydskstj002mhvs67k19xn9i","_id":"cjydskstn002thvs6tqbeafpq"},{"post_id":"cjydsksti002khvs6zu5bpktv","tag_id":"cjydskstl002rhvs6y6zfar0u","_id":"cjydsksto002uhvs6k3nib0yi"},{"post_id":"cjydsksyf002whvs6u4zm3avj","tag_id":"cjydskrsh000mhvs65rkt7x0h","_id":"cjydsksyh002yhvs6dm1beiby"},{"post_id":"cjydsksye002vhvs6jcuj8uhi","tag_id":"cjydsksyh002xhvs6akoi2olp","_id":"cjydsksyi0031hvs6ygs5yyyv"}],"Tag":[{"name":"vue","_id":"cjydskrry0004hvs64ptaehsj"},{"name":"React Native","_id":"cjydskrs20009hvs68uh4iwf1"},{"name":"javascript","_id":"cjydskrsh000mhvs65rkt7x0h"},{"name":"杂记","_id":"cjydskrsn000thvs62pb9x1ne"},{"name":"Hexo","_id":"cjydskrsq0011hvs6tsile6ft"},{"name":"指弹","_id":"cjydskrsu0019hvs6ixgdqj8h"},{"name":"react","_id":"cjydskrsz001mhvs6inoodyhg"},{"name":"学习","_id":"cjydskrt5001whvs6vkznf8qb"},{"name":"不知道归为哪一列系列","_id":"cjydskrt50020hvs62mwfombq"},{"name":"koa","_id":"cjydskstj002mhvs67k19xn9i"},{"name":"算法","_id":"cjydskstl002rhvs6y6zfar0u"},{"name":"http","_id":"cjydsksyh002xhvs6akoi2olp"}]}}
>>>>>>> 8695504697f489d8cb114d89c814545b6cc6d696
