---
title: 内存管理
date: 2018-03-10 00:24:22
tags: javascript
categories: 学习
---

>这篇文章准备聊聊内存管理，emmmmm，那就先来一道面试题吧。


### 所有之前

```bash
var a = {n:1};
var b = a;
a.x = a ={n:2};
console.log(a.x);
console.log(b.x);
```

<!--more-->
在下在刚看到这串代码时，{n:2}脱口而出，现在我都觉得臊的慌。
众所周知，js在微观上(以代码块为单位)是先定义，再执行的。
+ 第一行，将{n:1}对象所在的内存地址，存到变量a；
+ 第二行，将a保存的引用赋值给b，这样，a和b指向的是同一个对象。
+ 第三行，比较麻烦，js有意思的地方(坑)就在这。
    + 按操作符优先级，.的优先级高于=，所以先执行a.x，这似乎并不是一个表达式语句，但是它依然向{n:1}做了一个猥琐的事情，就是将它搞成了{n:1,x:undefined},别忘了一件事，a此时保存的正是对{n:1,x:undefined}的引用。
    + 接下来的连=就是从右往左依次执行，a={n:2}，这时的a的引用已经变了，注意，不是将{n:1,x:undefined}销毁，在它的空间里存放{n:2}，而是重新开辟一块内存，而是将a存放的地址，更换为{n:2}的地址。
    + a.x = a，重点来了，等号左表达式的a和和右表达式并不是同一个，换句话说前面的a和b一样指向的都是{n:1,x:undefined}，而后面的a指向的{n:2}。
+ 于是乎，结果就是undefined  {n:2}。

之所以用这道题开聊，是因为在解决这道题产生的疑问时，发现从内存的角度考虑，答案迎刃而解。
ok，开始BB....
### 内存模型
js中内存空间，大致分为三类：
+ 常量池：保存着诸如数字，字符的常量。
+ 栈内存：往往保存着变量，如果变量是值类型，保存的便是数据本身，如果是引用类型(数组，函数或者对象)，我是粗浅的认为保存的是其内存地址。
### 内存生命周期
js(应该说几乎所有的语言)运行时所产生的内存是有生命周期，大多包括以下三步：
#### 1.分配内存
分配内存往往意味着新的'值(包括变量，数字，字符，对象等)'的产生，个人认为，在声明一个变量和在变量初始化的时候，都会进行内存分配。举个例子：
```bash
var a = 1;  //预编译时，在栈中开辟一个a的内存空间，运行时将1保存在a的空间里

var b = 'laalal'; //给字符串分配内存

var obj ={
  n:1,
  x:2
};//给对象分配内存

function C(){
  console.log(a);
} //给函数(可调用对象)分配内存

var a = new C();//函数调用的的结果会分配内存
```
思考一段非常简单的代码:
```bash
var a ={n:1};
var b=a;
a = {n:2};
console.log(b); //{n:1}
```
从内存的角度分析一下，a和b都保存着{n:1}所在内存的地址，当a={n:2}重新赋值时，{n:2}是处于新开辟的内存中，并不是将原来a所指向的那块内存里的内容进行替换，a保有对{n:2}的引用，但是b依然指向的原来的{n:1},所以b的值为{n:1}，并且新的'值'的产生往往意味着新的内存被开辟。
#### 2.调用内存
使用值的过程实际上是对分配内存进行读取与写入的操作。比如对变量进行运算，函数调用等等。

#### 3.内存回收
全局变量的回收，往往是在关闭浏览器的时候进行的。开发时，尽量避免使用全局变量。<br>
而局部变量比如在函数作用域里声明的变量，则是在函数调用完之后，并且局部变量不被引用的时候，就会在适当的时候被回收。
来来来，再看一段代码
```bash
function A(){
  var obj = {n:1};
  console.log(obj);
}
A();
```
当函数A被调用时，运行时会为函数A开辟临时内存，临时内存里也有堆内存和栈内存，obj这个变量就是存贮在这个栈中,保存的是对堆中{n:1}的引用，函数结束后，栈中obj被释放，而{n:1}就没有变量去引用它，js引擎会在合适的时候释放这个对象。<br>
但是如果稍微改变一下代码
```bash
function A(){
  var obj = {n:1};
  console.log(obj);
  return obj;
}
var a = A();
```
函数执行完毕后，栈中的obj被释放，但是{n:1}却被引用到a，说明以后可能用到{n:1}，那么他就不会被回收，这就是函数调用结束后，内存也不会被释放的情况。
 闭包以后再说。
