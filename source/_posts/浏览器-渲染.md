---
title: 渲染
date: 2019-09-17 10:36:53
tags: 浏览器
categories: 学习
---
>本文是对浏览器工作原理与实践《我加书名号了》中渲染篇的总结，包括但不限于。
<!--more-->

先说一下浏览器，目前的浏览器都是多进程架构的。以chrome为例，它包括1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。
其中：
+ <strong>浏览器进程</strong>。主要负责界面显示、用户交互、自进程管理，同时提供存储等功能。
+ <strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript转换成用户可以与之交互的页面，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
+ <strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的。
+ <strong>GPU进程</strong>。用来绘制UI界面。
+ <strong>插件进程</strong>。主要负责插件的运行，因插件已崩溃，所以需要通过插件进程来隔离。

以前了解浏览器的渲染，我学到的是这样好的。
![浏览器渲染过程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png)

但是各种细节不是很清楚，这次做个总结。

## DOM树生成
+ 转换Bytes：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符

+ Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集

+ Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则

+ DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样

## 样式计算

样式计算分为以下三步

### 将CSS转换为浏览器能够理解的结构

来源：

+ 通过link引用的外部CSS文件
+ style标签引入的
+ DOM的style属性内嵌的
纯文本的CSS样式，浏览器是无法理解的，必须转换成StyleSheet

### 转换样式表中的属性值，使其标准化

css的某些属性值，渲染引擎是不容易理解的，比如em，red， bold，这些会被转化成px，rgb以及700的形式。

### 计算DOM树中每个节点的具体样式

主要是通过继承和层叠来实线。

+ 一个子元素的的样式可以从父元素继承而来，比如font-weight、font-family的font系列，text-align、line-height、color等文本系列，visibility以及cursor等。

+ css有个优先级策略，比如!important>行内>id>class>Tag>*，统一等级的下面的会覆盖上面的。

浏览器还有默认的userAgent。

通过这两种方式累计计算Dom的样式。

## 布局

布局是计算出元素的可见位置，分为创建布局树和布局计算两步。

### 创建布局树

+ 遍历DOM树中的可见节点，并将节点加到布局树中

+ 忽略不可见的元素，比如head标签里面的元素，display为none的元素。

### 布局计算

布局是一个递归的过程，这是因为一个节点的大小通常需要先计算他的自节点的位置、大小等信息。

计算布局的主要过程是的RenderObject的layout函数来完成的，步骤大致如下：


+ 通过检查位数组中的相应标记位、子元素是否需要计算布局来确定。

+ 确定网页的宽度和垂直方向上的外边距，这是因为网页通常是在垂直方向上滚动，而水平方向上不需要滚动。？？？？

+ 接着函数会便利其每一个子元素，以此计算他们的布局。如果元素定义了自身的狂傲，那么webkit按照定义的宽高来确定元素的大小，而对于像文本节点的內联元素则需要结合其字号大小及文字的多少等来确定其对应的狂傲，除非页面定义了页面元素的狂傲，一般来说页面元素的宽高是在布局的时候通过相关计算的出来的。如果有子元素，则递归这一过程。

+ 最后，节点根据计算他的子女们的大小计算出自己的高度，整个过程结束。

## 分层

渲染引擎为特定节点创建新的层的条件（满足两点任意一点就行）

+ 拥有层叠上下文，例如
    + 根元素 (HTML),
    + z-index 值不为 "auto"的 绝对/相对定位元素，
    + 固定（fixed）/ 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）
    + z-index值不为 "auto"的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex，
    + z-index值不为“auto”的grid子项，即：父元素display：grid
    + opacity 属性值小于 1 的元素（参考 the specification for opacity），
    + mix-blend-mode 属性值不为 "normal"的元素，
    + transform属性值不为“none”的元素 
    + filter值不为“none”的元素，
    + perspective值不为“none”的元素，
    + clip-path值不为“none”的元素
    + mask / mask-image / mask-border不为“none”的元素
    + isolation 属性被设置为 "isolate"的元素
    + 在 will-change 中指定了任意CSS属性（参考 这篇文章）
    + -webkit-overflow-scrolling 属性被设置 "touch"的元素
    + contain属性值为“layout”，“paint”，或者综合值比如“strict”，“content”


+ 需要裁剪的地方

## 图层绘制

渲染引擎会把一个图层拆分成很多小的绘制指令，然后这些指令按照顺序组成一个待绘制列表。包含绘制的形状、绘制、样式等。

## 栅格化（raster）操作

在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

<p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512</p>

<strong>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>

![](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)

## 合成和显示

<p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>