---
title: 前端面试收集
date: 2018-04-02 14:42:08
tags: javascript
categories: 学习
---

本部分内容大致分为以下几个方面： HTML, CSS, JavaScript, Node 和 HTTP。

<!--more-->

## JavaScript

#### 1. ECMAScript/JavaScript 中都有那些数据类型？

**答**：ECMAScript中5种简单数据类型（基本数据类型）: Undefined、Null、Boolean、Number和String, 1种复杂数据类型: Object.

#### 2. 把非数值转化为数值的函数都有哪些？

**答**：Number()、parseInt()和parseFloat()，第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。

#### 3. JavaScript 中的 new 关键词做了什么？

* **答**：他做了五件事

1. 他生成了一个新对象。这个对象的类型只是一个普通的对象；
2. 他将新对象内部、不可访问的原型属性（例如：`__proto__`）设置为构造器函数外在、可访问的 prototype 对象（每个函数对象都会自动拥有一个 `prototype` 属性）；
3. 他将 `this` 变量指向这个新生成的对象；
4. 他执行构造器函数，对于每个提及到 `this` 的地方使用新生成的对象执行；
5. 他返回这个新生成的对象，除非构造器函数返回了一个非空的对象引用。若是返回了一个非空对象，那么这个对象引用将会替代新生成的对象被返回；

```
function myNew(fn,...args) {
    const obj = Object.create(null)
    obj.__proto__ = fn.prototype
    const result = fn.apply(obj, args)
    const isObject = typeof result === 'object' && result !== null 
    const isFunction = typeof result === 'function'
    if(isObject || isFunction) return result
    return obj
}
```
#### 4. JavaScript 的六种继承类型？

* **答**：

* 简单原型链：这是实现继承最简单的方式了，核心在于用父类实例作为子类原型对象。优点是简单，缺点在于二 - 创建子类实例时，无法向父类构造函数传参；由于来自原型对象的引用属性是所有实例共享的，所以修改原型对象上的属性会在所有子类实例中体现出来；

```
function Super(){
    this.val = 1;
}
function Sub(){
    // ...
}
Sub.prototype = new Super();
let sub1 = new Sub();
```

* 借用构造函数：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）;缺点在于无法实现函数复用，每个子类实例都持有一个新的 `fun` 函数，太多了就会影响性能；

```
function Super(val){
    this.val = val;
    this.fun = function(){
        // ...
    }
}
function Sub(val){
    Super.call(this, val);   // 核心
}
let sub1 = new Sub(1);
```

* 组合继承（最常用）：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点；子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的定义，属于内存浪费；

```
function Super(){
    // 只在此处声明基本属性和引用属性
    this.val = 1;
}
//  在此处声明函数
Super.prototype.fun1 = function(){};
function Sub(){
    Super.call(this);   // 核心
    // ...
}
Sub.prototype = new Super();    // 核心
let sub1 = new Sub(1);
```

* 原型式继承：从已有的对象中衍生出新对象，不需要创建自定义类型；但原型引用属性会被所有实例共享，因为用整个父类对象来充当子类原型对象；无法实现代码复用；

```
function beget(obj){   // 生孩子函数 beget
    let F = function(){};
    F.prototype = obj;
    return new F();
}
function Super(){
    this.val = 1;
    this.arr = [1];
}
// 拿到父类对象
let sup = new Super();
// 生孩子
let sub = beget(sup);
```

* 寄生式继承：寄生式继承的思路和寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后像真的是它做了所有工作一样返回对象；但是这种形式依然不能复用函数；

```
function beget(obj){   // 生孩子函数
    let F = function(){};
    F.prototype = obj;
    return new F();
}
function Super(){
    this.val = 1;
    this.arr = [1];
}
function getSubObject(obj){
    // 创建新对象
    let clone = beget(obj); // 核心
    // 增强
    clone.attr1 = 1;
    clone.attr2 = 2;
    return clone;
}
var sub = getSubObject(new Super());
```

* 寄生组合继承（最佳方式）：用 beget(Super.prototype) 切掉了原型对象上多余的那份父类实例属性；

```
function beget(obj){   // 生孩子函数 beget
    let F = function(){};
    F.prototype = obj;
    return new F();
}
function Super(){
    // 只在此处声明基本属性和引用属性
    this.val = 1;
    this.arr = [1];
}
//  在此处声明函数
Super.prototype.fun1 = function(){};
Super.prototype.fun2 = function(){};
function Sub(){
    Super.call(this);   // 核心
    // ...
}
let proto = beget(Super.prototype); // 核心
proto.constructor = Sub;            // 核心
Sub.prototype = proto;              // 核心
let sub = new Sub();
```

#### 5. 箭头函数的适用规则？

* **答**：

* 如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=>箭头函数。
* 如果你有一个内部函数表达式，它依赖于外围函数的 var self = this 黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=>箭头函数。
* 如果你有一个内部函数表达式，它依赖于外围函数的类似于 var args = Array.prototype.slice.call(arguments) 这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=>箭头函数。
* 对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=>函数语法。

#### 6. 为什么我们区别 LHS 和 RHS 那么重要？

**答**：因为在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。如果 RHS 查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError。相比之下，如果引擎在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交还给引擎。而如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么引擎就会抛出一个不同种类的错误，称为 TypeError。

#### 7. 如何区分声明和表达式？

**答**：区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。

#### 8. IIFE 方式与变种？

**答**：

```javascript
// 1
(function foo(){ .. })()
// 2
(function(){ .. }())
// 3，用于 UMD 项目
(function IIFE( def ){
	def( window );
})(function def( global ){
	let a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2
});
```

#### 9. 请解释如下代码执行的结果？

```
[] + {}; // "[object Object]"
{} + []; // 0
```

**答**：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为""因此{}也会被强制转换为一个string："[object Object]"。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。

#### 10. 什么是事件委托？

**答**：：事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。
事件委托的好处包括：动态绑定事件与减少内存消耗。

#### 11. JavaScript 与 HTML 之间交互的事件模型分为几个阶段？

**答**：

1. 捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；
2. 目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；
3. 冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；

#### 12. 触摸事件都有哪些？

**答**：三种在规范中列出并获得跨移动设备广泛实现的基本触摸事件

1. touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。
2. touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。
3. touchend事件：当手指从屏幕上离开的时候触发。

#### 13. 事件对象的 clientX, offsetX, screenX, pageX 有什么区别？

**答**：

1. event.clientX、event.clientY: 鼠标相对于浏览器窗口可视区域的X, Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。
2. event.pageX、event.pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX, pageY的最大值就是它们了。**特别说明：IE不支持！**
3. screenX、screenY: 鼠标相对于用户显示器屏幕左上角的X, Y坐标。
4. event.offsetX、event.offsetY: 鼠标相对于事件父容器（srcElement）的X, Y坐标。**特别说明：只有IE支持！**

#### 什么是虚拟DOM（Virtual DOM），以及它与真实DOM的区别和优势。
虚拟DOM（Virtual DOM）是一种用于优化前端性能的概念和技术。它是一种在内存中以JavaScript对象的形式表示的轻量级的DOM树结构。

与真实DOM相比，虚拟DOM有以下区别和优势：

+ 结构轻量：虚拟DOM是基于JavaScript对象构建的，相对于真实DOM的复杂结构来说，它是一种轻量级的表示方式。这意味着在进行DOM操作时，虚拟DOM的创建和更新速度更快。

+ 批量更新：在使用虚拟DOM时，当应用程序状态发生变化时，虚拟DOM会将变化记录下来，并在适当的时机将这些变化批量更新到真实DOM中。这样可以减少对真实DOM的直接操作，从而提高性能。

+ 减少重绘和回流：虚拟DOM通过比较前后两个虚拟DOM树的差异，找到需要更新的部分，并只更新这些部分，而不是全局重新渲染整个DOM树。这样可以减少不必要的页面重绘和回流操作，提高渲染性能。

+ 跨平台支持：虚拟DOM是基于JavaScript对象的，因此可以在不同平台上使用，例如浏览器、服务器和移动应用程序等。这种跨平台的支持使得虚拟DOM成为一种通用的前端开发技术。

虽然虚拟DOM能够提高前端性能，但它也存在一些额外的开销，例如内存占用和运算消耗。因此，在某些情况下，使用虚拟DOM可能并不是最优选择。但总体来说，虚拟DOM作为一种优化手段，可以有效地提高前端应用程序的渲染性能和用户体验。
## Node 软件包管理

#### 1. 简述同步和异步之间的区别？

**答**：同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率

#### 2. 在每个 package.json 的 dependency 中都会有很多软件名以及随之跟上的版本号，例如 `"d3": "^3.9.0"` 或者 `"d3": "~3.9.0"`，请问 "^" 和 "~" 的含义分别是什么？

**答**：根据 ["npm install --save" No Longer Using Tildes](http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/) 一文可知，形如波浪号的编号（例如：~1.2.3）会匹配对应软件所有的 1.2.x 版本，并最终使用最新的符合要求的版本；相比之下倒 V 型编号（例如：^1.2.3）有更松弛的规则，所有 1.x.x 版本均在匹配列表中，但匹配过程会在 2.0.0 停止并返回最新的符合要求的版本。

## HTTP

#### 1. HTTP/0.9 只有一个命令 `GET`, HTTP/1.0 引入了 `POST` 命令和 `HEAD` 命令，丰富了浏览器与服务器的互动手段。请问 HTTP/1.1 的请求方法有哪些？

**答**：HTTP/1.1 提供八种方法以不同的方式操作指定的资源。分别是

1. OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'\*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。
2. HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。
3. GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法
4. POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。
5. PUT：向指定资源位置上传其最新内容。
6. DELETE：请求服务器删除Request-URI所标识的资源。
7. TRACE：回显服务器收到的请求，主要用于测试或诊断。
8. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。

#### 2. HTTP 状态码的主要类型有哪些？

**答**：状态代码的第一个数字代表当前响应的类型，主要为五类

1. 1xx消息——请求已被服务器接收，继续处理
2. 2xx成功——请求已成功被服务器接收、理解、并接受
3. 3xx重定向——需要后续操作才能完成这一请求
4. 4xx请求错误——请求含有词法错误或者无法被执行
5. 5xx服务器错误——服务器在处理某个正确请求时发生错误

详细情况见 [维基百科](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)。

#### 3. TCP 协议中为什么连接的时候是三次握手，关闭的时候却是四次握手？

**答**：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

#### 4. HTTPS 建立连接的过程？

**答**：按照通信过程的收发端来划分，可以将整个过程分成四个部分-客户端请求、服务端回复、客户端回应以及服务器回应。

1. 客户端发出握手请求 (Client Hello)，包含以下信息：
	* 支持的协议版本，比如TLS 1.0
	* 一个客户端生成的随机数(random\_1)，这个随机数既需要客户端保存又需要发送给服务器
	* 支持的加密方法，比如RSA公钥加密
	* 支持的压缩方法
2. 服务器回复 (Server Hello)，包含以下信息：
	* 确认使用的加密通信协议版本，比如TLS 1.0。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信
	* 一个服务器生成的随机数 (random\_2)
	* 确认使用的加密方法，比如RSA公钥加密
	* 服务器证书（其中包含服务器放入公钥）
	* 可选：如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书
3. 客户端回应，包含以下步骤：
	* 验证服务器证书的合法性，证书合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开
	* 客户端使用一些加密算法 (例如：RSA, Diffie-Hellman)产生一个48个字节的 key，这个 key 叫 PreMaster Secret。该 PreMaster Secret 用服务器发来的公钥加密后随同相关内容（如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息，即客户的证书以及含有签名的随机数）传送回服务器端，防止被窃听
	* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送
	* 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验
4. 服务器回应，服务器接收到浏览器送过来的消息，用自己的私钥解密，获得 PreMaster Secret。再结合另外两个随机数 random\_1 和 random\_2，计算出本次会话的会话密钥 (session secret)，然后向客户端发送下面信息：
	* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送
	* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验

在四个过程结束之后，握手阶段结束。接下来，客户端和服务端进入加密通信阶段，该阶段的通信采用普通的 HTTP 协议，只不过双方都采用相同的会话密钥对会话内容进行对称加密和解密。

需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以 SSL 在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对 HTTP 内容加密传输。下图为 SSL 连接建立过程详解图。

![SSL 连接建立过程详解图](https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/SSL-Connection-Setup.png")

#### 5. IP 地址的分类？

**答**：A 类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；B 类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C 类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）。其中，10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—
192.168.255.255 为 Internet 上保留地址用于内部。

#### 6. 互联网上各类协议的介绍？

**答**：

1. ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
2. TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
3. HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
4. DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。
5. DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

#### 7. TCP 和 UDP 的区别？

**答**：TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的数据流传输；TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报；TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般；TCP 对应的协议和 UDP 对应的协议如下：

```
TCP 协议
（1） FTP：定义了文件传输协议，使用21端口。
（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。
UDP协议
（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。
```

#### 三次握手（Three-way Handshake）：

第一步：客户端向服务器发送一个带有SYN（同步）标志的连接请求报文段，表示客户端希望建立连接。该报文段包含一个随机的初始序列号（ISN）。
第二步：服务器收到客户端的连接请求后，回复一个带有SYN和ACK（确认）标志的报文段。该报文段中的SYN是对客户端的请求的确认，ACK表示服务器已经接受了客户端的请求，并生成了自己的初始序列号（ISN）。
第三步：客户端收到服务器的确认后，再发送一个带有ACK标志的报文段，确认服务器的确认。至此，TCP连接建立成功，双方可以开始传输数据。

#### 四次挥手（Four-way Handshake）：

TCP的四次挥手是指在TCP连接的关闭过程中，客户端和服务器之间进行的一系列步骤。它用于确保双方都完成了数据传输并且安全地关闭连接。下面是TCP的四次挥手详细步骤：

+ 第一步（客户端发送FIN）：客户端首先发送一个带有FIN（Finish）标志的TCP报文段给服务器，表示客户端不再发送数据。客户端进入FIN_WAIT_1状态。

+ 第二步（服务器发送ACK）：服务器收到客户端的FIN后，发送一个确认ACK（Acknowledgment）报文段给客户端，表示已收到了客户端的关闭请求。服务器进入CLOSE_WAIT状态，而客户端进入FIN_WAIT_2状态。

+ 第三步（服务器发送FIN）：当服务器不再发送数据时，它会向客户端发送一个带有FIN标志的TCP报文段，表示服务器准备关闭连接。服务器进入LAST_ACK状态。

+ 第四步（客户端发送ACK）：客户端收到服务器的FIN后，发送一个确认ACK报文段给服务器，表示已收到了服务器的关闭请求。客户端进入TIME_WAIT状态。

在TIME_WAIT状态，客户端等待一段时间（通常是两倍的最大报文段生存时间，也称为MSL），以确保服务器收到了最后一个ACK。在等待期间，客户端保持连接的信息，以防止来自之前连接的延迟报文段干扰新的连接。

在完成四次挥手后，客户端和服务器都进入了CLOSED状态，连接正式关闭。

TCP的四次挥手过程可以确保双方都能正常关闭连接，并且在关闭之前完成数据的传输和确认。这样可以避免数据丢失或不完整的情况，确保网络通信的可靠性。

#### async和defer
script 是会阻碍 HTML 解析的，只有下载好并执行完脚本才会继续解析 HTML
defer 和 async有一个共同点：下载此类脚本都不会阻止页面呈现（异步加载），区别在于：

async 执行与文档顺序无关，先加载哪个就先执行哪个；defer会按照文档中的顺序执行
async 脚本加载完成后立即执行，可以在DOM尚未完全下载完成就加载和执行；而defer脚本需要等到文档所有元素解析完成之后才执行

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea091aed8364b88a653a13c4845a824~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)